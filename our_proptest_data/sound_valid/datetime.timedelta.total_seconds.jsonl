{"function_name": "datetime.timedelta.total_seconds", "properties": ["1. The output of `total_seconds` should always be a non-negative float, as it represents a duration of time.", "2. The output of `total_seconds` should equal zero if both `days`, `seconds`, and `microseconds` are all zero.", "3. The output of `total_seconds` should be proportional to the input values, meaning that doubling the input values (for `days`, `seconds`, and `microseconds`) should double the output.", "4. The output of `total_seconds` should be consistent across multiple calls with the same input values, ensuring that it is deterministic.", "5. The output of `total_seconds` should correctly account for the conversion of days to seconds, meaning that the output should equal the sum of `days * 86400`, `seconds`, and `microseconds / 10**6`."], "pbt": ["@given(st.integers(min_value=0, max_value=10**6), \n       st.integers(min_value=0, max_value=59), \n       st.integers(min_value=0, max_value=999999))\ndef test_total_seconds_non_negative_property(days, seconds, microseconds):\n    td = datetime.timedelta(days=days, seconds=seconds, microseconds=microseconds)\n    assert td.total_seconds() >= 0", "@given(st.integers(min_value=0, max_value=10**6), \n       st.integers(min_value=0, max_value=59), \n       st.integers(min_value=0, max_value=999999))\ndef test_total_seconds_zero_property(days, seconds, microseconds):\n    td = datetime.timedelta(days=0, seconds=0, microseconds=0)\n    assert td.total_seconds() == 0", "@given(st.integers(min_value=0, max_value=10**6), \n       st.integers(min_value=0, max_value=59), \n       st.integers(min_value=0, max_value=999999))\ndef test_total_seconds_proportional_property(days, seconds, microseconds):\n    td = datetime.timedelta(days=days, seconds=seconds, microseconds=microseconds)\n    doubled_td = datetime.timedelta(days=days * 2, seconds=seconds * 2, microseconds=microseconds * 2)\n    assert td.total_seconds() * 2 == doubled_td.total_seconds()", "@given(st.integers(min_value=0, max_value=10**6), \n       st.integers(min_value=0, max_value=59), \n       st.integers(min_value=0, max_value=999999))\ndef test_total_seconds_deterministic_property(days, seconds, microseconds):\n    td = datetime.timedelta(days=days, seconds=seconds, microseconds=microseconds)\n    assert td.total_seconds() == td.total_seconds()", "@given(st.integers(min_value=0, max_value=10**6), \n       st.integers(min_value=0, max_value=59), \n       st.integers(min_value=0, max_value=999999))\ndef test_total_seconds_correct_accounting_property(days, seconds, microseconds):\n    td = datetime.timedelta(days=days, seconds=seconds, microseconds=microseconds)\n    expected_total_seconds = (days * 86400) + seconds + (microseconds / 10**6)\n    assert td.total_seconds() == expected_total_seconds"], "api_doc": "timedelta.total_seconds()\nReturn the total number of seconds contained in the duration. Equivalent to td / timedelta(seconds=1). For interval units other than seconds, use the division form directly (e.g. td / timedelta(microseconds=1)).\n\nNote that for very large time intervals (greater than 270 years on most platforms) this method will lose microsecond accuracy.\n\nAdded in version 3.2.\n\nExamples of usage: timedelta\nAn additional example of normalization:\n\n>>>\n# Components of another_year add up to exactly 365 days\nfrom datetime import timedelta\nyear = timedelta(days=365)\nanother_year = timedelta(weeks=40, days=84, hours=23,\n                         minutes=50, seconds=600)\nyear == another_year\nTrue\nyear.total_seconds()\n31536000.0"}
