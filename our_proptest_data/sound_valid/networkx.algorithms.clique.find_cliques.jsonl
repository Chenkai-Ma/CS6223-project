{"function_name": "networkx.algorithms.clique.find_cliques", "properties": ["1. The output cliques are maximal, meaning that no additional nodes can be added to any of the cliques without violating the completeness of the subgraph.", "2. If the `nodes` parameter is provided, every returned clique must contain all nodes specified in the `nodes` list, and if `nodes` is not a clique itself, a ValueError should be raised.", "3. The output should not include any duplicate cliques, ensuring that each maximal clique is unique within the iterator.", "4. The length of each returned clique should be at least 1, as a maximal clique must contain at least one node from the graph.", "5. The order of the cliques in the output is arbitrary, meaning that different invocations of the function should not guarantee the same order of cliques, but the same cliques should be present in any valid output for the same input graph."], "pbt": ["@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_output_cliques_are_maximal_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    cliques = list(find_cliques(G))\n    \n    for clique in cliques:\n        for node in clique:\n            # Check if adding any other node from G would still be a clique\n            for other in G.nodes():\n                if other not in clique and not G.has_edge(node, other):\n                    assert len(clique) == len(set(clique))  # Must be maximal", "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_nodes_included_if_provided_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create a complete graph\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    # Test with a subset of nodes\n    subset = list(graph_nodes)[:len(graph_nodes)//2]\n    cliques = list(find_cliques(G, nodes=subset))\n    \n    for clique in cliques:\n        for node in subset:\n            assert node in clique  # Each clique must include all nodes in subset", "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_output_cliques_are_unique_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n\n    cliques = list(find_cliques(G))\n    assert len(cliques) == len(set(tuple(sorted(clique)) for clique in cliques))  # Must be unique", "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_length_of_cliques_is_at_least_one_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    cliques = list(find_cliques(G))\n    \n    for clique in cliques:\n        assert len(clique) >= 1  # Each clique must have at least one node", "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_order_of_cliques_is_arbitrary_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n\n    cliques1 = list(find_cliques(G))\n    cliques2 = list(find_cliques(G))\n    \n    # Check that the same cliques can be found, but order may differ\n    assert set(map(tuple, cliques1)) == set(map(tuple, cliques2))  # Must contain the same cliques"], "api_doc": "find_cliques\nfind_cliques(G, nodes=None)[source]\nReturns all maximal cliques in an undirected graph.\n\nFor each node n, a maximal clique for n is a largest complete subgraph containing n. The largest maximal clique is sometimes called the maximum clique.\n\nThis function returns an iterator over cliques, each of which is a list of nodes. It is an iterative implementation, so should not suffer from recursion depth issues.\n\nThis function accepts a list of nodes and only the maximal cliques containing all of these nodes are returned. It can considerably speed up the running time if some specific cliques are desired.\n\nParameters\n:\nG\nNetworkX graph\nAn undirected graph.\n\nnodes\nlist, optional (default=None)\nIf provided, only yield maximal cliques containing all nodes in nodes. If nodes isn\u2019t a clique itself, a ValueError is raised.\n\nReturns\n:\niterator\nAn iterator over maximal cliques, each of which is a list of nodes in G. If nodes is provided, only the maximal cliques containing all the nodes in nodes are returned. The order of cliques is arbitrary.\n\nRaises\n:\nValueError\nIf nodes is not a clique.\n\nSee also\n\nfind_cliques_recursive\nA recursive version of the same algorithm.\n\nNotes\n\nTo obtain a list of all maximal cliques, use list(find_cliques(G)). However, be aware that in the worst-case, the length of this list can be exponential in the number of nodes in the graph. This function avoids storing all cliques in memory by only keeping current candidate node lists in memory during its search.\n\nThis implementation is based on the algorithm published by Bron and Kerbosch (1973) [1], as adapted by Tomita, Tanaka and Takahashi (2006) [2] and discussed in Cazals and Karande (2008) [3]. It essentially unrolls the recursion used in the references to avoid issues of recursion stack depth (for a recursive implementation, see find_cliques_recursive()).\n\nThis algorithm ignores self-loops and parallel edges, since cliques are not conventionally defined with such edges.\n\nReferences\n\n[1]\nBron, C. and Kerbosch, J. \u201cAlgorithm 457: finding all cliques of an undirected graph\u201d. Communications of the ACM 16, 9 (Sep. 1973), 575\u2013577. <http://portal.acm.org/citation.cfm?doid=362342.362367>\n\n[2]\nEtsuji Tomita, Akira Tanaka, Haruhisa Takahashi, \u201cThe worst-case time complexity for generating all maximal cliques and computational experiments\u201d, Theoretical Computer Science, Volume 363, Issue 1, Computing and Combinatorics, 10th Annual International Conference on Computing and Combinatorics (COCOON 2004), 25 October 2006, Pages 28\u201342 <https://doi.org/10.1016/j.tcs.2006.06.015>\n\n[3]\nF. Cazals, C. Karande, \u201cA note on the problem of reporting maximal cliques\u201d, Theoretical Computer Science, Volume 407, Issues 1\u20133, 6 November 2008, Pages 564\u2013568, <https://doi.org/10.1016/j.tcs.2008.05.010>\n\nExamples\n\nfrom pprint import pprint  # For nice dict formatting\nG = nx.karate_club_graph()\nsum(1 for c in nx.find_cliques(G))  # The number of maximal cliques in G\n36\nmax(nx.find_cliques(G), key=len)  # The largest maximal clique in G\n[0, 1, 2, 3, 13]\nThe size of the largest maximal clique is known as the clique number of the graph, which can be found directly with:\n\nmax(len(c) for c in nx.find_cliques(G))\n5\nOne can also compute the number of maximal cliques in G that contain a given node. The following produces a dictionary keyed by node whose values are the number of maximal cliques in G that contain the node:\n\npprint({n: sum(1 for c in nx.find_cliques(G) if n in c) for n in G})\n{0: 13,\n 1: 6,\n 2: 7,\n 3: 3,\n 4: 2,\n 5: 3,\n 6: 3,\n 7: 1,\n 8: 3,\n 9: 2,\n 10: 2,\n 11: 1,\n 12: 1,\n 13: 2,\n 14: 1,\n 15: 1,\n 16: 1,\n 17: 1,\n 18: 1,\n 19: 2,\n 20: 1,\n 21: 1,\n 22: 1,\n 23: 3,\n 24: 2,\n 25: 2,\n 26: 1,\n 27: 3,\n 28: 2,\n 29: 2,\n 30: 2,\n 31: 4,\n 32: 9,\n 33: 14}\nOr, similarly, the maximal cliques in G that contain a given node. For example, the 4 maximal cliques that contain node 31:\n\n[c for c in nx.find_cliques(G) if 31 in c]\n[[0, 31], [33, 32, 31], [33, 28, 31], [24, 25, 31]]"}
