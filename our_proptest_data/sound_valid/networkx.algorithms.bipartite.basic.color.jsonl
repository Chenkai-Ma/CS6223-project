{"function_name": "networkx.algorithms.bipartite.basic.color", "properties": ["1. The output dictionary must have the same number of entries as the number of nodes in the graph \\( G \\).", "2. Each node in the output dictionary must be assigned a color value of either 0 or 1.", "3. Nodes that are directly connected by an edge in the graph \\( G \\) must have different color values in the output dictionary.", "4. If the input graph \\( G \\) is bipartite, the output dictionary must represent a valid bipartite coloring, meaning there should be no edges connecting nodes of the same color.", "5. If the input graph \\( G \\) is not bipartite, the function must raise a `NetworkXError` exception, indicating that the graph cannot be two-colored."], "pbt": ["@given(st.data())\ndef test_output_length_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    if bipartite.is_bipartite(G):\n        c = bipartite.color(G)\n        assert len(c) == len(G.nodes)", "@given(st.data())\ndef test_color_value_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    if bipartite.is_bipartite(G):\n        c = bipartite.color(G)\n        for color in c.values():\n            assert color in {0, 1}", "@given(st.data())\ndef test_adjacent_nodes_diff_color_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    if bipartite.is_bipartite(G):\n        c = bipartite.color(G)\n        for u, v in G.edges:\n            assert c[u] != c[v]", "@given(st.data())\ndef test_bipartite_coloring_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    if bipartite.is_bipartite(G):\n        c = bipartite.color(G)\n        for u, v in G.edges:\n            assert c[u] != c[v]", "@given(st.data())\ndef test_non_bipartite_graph_error_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=3), edges=st.lists(st.tuples(st.integers(), st.integers()))))\n    if not bipartite.is_bipartite(G):\n        try:\n            bipartite.color(G)\n            assert False, \"Expected NetworkXError for non-bipartite graph\"\n        except nx.NetworkXError:\n            pass"], "api_doc": "color\ncolor(G)[source]\nReturns a two-coloring of the graph.\n\nRaises an exception if the graph is not bipartite.\n\nParameters\n:\nG\nNetworkX graph\nReturns\n:\ncolor\ndictionary\nA dictionary keyed by node with a 1 or 0 as data for each node color.\n\nRaises\n:\nNetworkXError\nIf the graph is not two-colorable.\n\nExamples\n\nfrom networkx.algorithms import bipartite\nG = nx.path_graph(4)\nc = bipartite.color(G)\nprint(c)\n{0: 1, 1: 0, 2: 1, 3: 0}\nYou can use this to set a node attribute indicating the bipartite set:\n\nnx.set_node_attributes(G, c, \"bipartite\")\nprint(G.nodes[0][\"bipartite\"])\n1\nprint(G.nodes[1][\"bipartite\"])\n0"}
