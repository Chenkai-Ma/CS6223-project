{"function_name": "networkx.algorithms.bipartite.basic.color", "properties": ["1. The output dictionary should contain exactly two distinct colors (0 and 1) for all nodes in a bipartite graph, ensuring that no two adjacent nodes share the same color.", "2. If the input graph is empty, the output should also be an empty dictionary, indicating that there are no nodes to color.", "3. For any isolated nodes in the input graph, the output should assign them the color 0, as they are not connected to any other nodes.", "4. The output should maintain a one-to-one mapping between nodes in the input graph and the keys in the output dictionary, meaning every node in the graph should have a corresponding entry in the color dictionary.", "5. If the input graph is not bipartite, the function should raise a `NetworkXError`, indicating that it cannot assign colors without violating the bipartite condition."], "pbt": ["@given(st.data())\ndef test_output_contains_two_distinct_colors_property(data):\n    G = data.draw(st.one_of(\n        st.builds(nx.complete_bipartite_graph, st.integers(min_value=1, max_value=10), st.integers(min_value=1, max_value=10)),\n        st.builds(nx.empty_graph, st.integers(min_value=0, max_value=10)),\n    ))\n    color = nx.algorithms.bipartite.basic.color(G)\n    assert set(color.values()) <= {0, 1}", "@given(st.data())\ndef test_empty_graph_output_property(data):\n    G = nx.empty_graph()\n    color = nx.algorithms.bipartite.basic.color(G)\n    assert color == {}", "@given(st.data())\ndef test_isolated_nodes_color_property(data):\n    isolated_node_count = data.draw(st.integers(min_value=1, max_value=10))\n    G = nx.Graph()\n    G.add_nodes_from(range(isolated_node_count))  # Add isolated nodes\n    color = nx.algorithms.bipartite.basic.color(G)\n    assert all(color[node] == 0 for node in G.nodes())", "@given(st.data())\ndef test_one_to_one_mapping_property(data):\n    G = data.draw(st.one_of(\n        st.builds(nx.complete_bipartite_graph, st.integers(min_value=1, max_value=10), st.integers(min_value=1, max_value=10)),\n        st.builds(nx.empty_graph, st.integers(min_value=0, max_value=10)),\n    ))\n    color = nx.algorithms.bipartite.basic.color(G)\n    assert len(color) == G.number_of_nodes()", "@given(st.data())\ndef test_color_non_bipartite_graph_property(data):\n    # Generate a non-bipartite graph\n    G = nx.cycle_graph(5)  # A cycle with an odd number of nodes (non-bipartite)\n    try:\n        nx.algorithms.bipartite.basic.color(G)\n        assert False, \"Expected NetworkXError for non-bipartite graph\"\n    except nx.NetworkXError:\n        pass"], "api_doc": "color\ncolor(G)[source]\nReturns a two-coloring of the graph.\n\nRaises an exception if the graph is not bipartite.\n\nParameters\n:\nG\nNetworkX graph\nReturns\n:\ncolor\ndictionary\nA dictionary keyed by node with a 1 or 0 as data for each node color.\n\nRaises\n:\nNetworkXError\nIf the graph is not two-colorable.\n\nExamples\n\nfrom networkx.algorithms import bipartite\nG = nx.path_graph(4)\nc = bipartite.color(G)\nprint(c)\n{0: 1, 1: 0, 2: 1, 3: 0}\nYou can use this to set a node attribute indicating the bipartite set:\n\nnx.set_node_attributes(G, c, \"bipartite\")\nprint(G.nodes[0][\"bipartite\"])\n1\nprint(G.nodes[1][\"bipartite\"])\n0"}
