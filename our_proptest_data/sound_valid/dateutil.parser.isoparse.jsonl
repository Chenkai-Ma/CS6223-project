{"function_name": "dateutil.parser.isoparse", "properties": ["1. The output datetime object should represent the same date and time as specified in the input ISO-8601 string, with all components correctly parsed (year, month, day, hour, minute, second, and timezone).", "2. If the input ISO-8601 string specifies a timezone offset, the output datetime object should reflect the correct UTC time, adjusted according to the given offset.", "3. The output datetime object should default to the minimum values for any unspecified components (e.g., if only the year is provided, the month and day should default to January 1st).", "4. The output should correctly handle both representations of midnight (00:00 and 24:00) and interpret them as equivalent to the start of the day.", "5. The output should raise an appropriate error for invalid ISO-8601 strings, ensuring that valid strings continue to be parsed correctly while invalid ones do not produce ambiguous results."], "pbt": ["# Property 1: The output datetime object should represent the same date and time as specified in the input ISO-8601 string.\n@given(st.text())\ndef test_output_date_time_representation_property(dt_str):\n    try:\n        result = parser.isoparse(dt_str)\n        expected = datetime.fromisoformat(dt_str.replace('Z', '+00:00'))\n        assert result == expected\n    except ValueError:\n        pass  # Handle invalid ISO-8601 strings", "# Property 2: If the input ISO-8601 string specifies a timezone offset, the output should reflect the correct UTC time.\n@given(st.text())\ndef test_output_timezone_offset_property(dt_str):\n    try:\n        result = parser.isoparse(dt_str)\n        if 'Z' in dt_str or any(offset in dt_str for offset in ['+', '-']):\n            expected_utc = result.astimezone(datetime.timezone.utc)\n            assert result == expected_utc\n    except ValueError:\n        pass  # Handle invalid ISO-8601 strings", "# Property 3: The output should default to the minimum values for any unspecified components.\n@given(st.text())\ndef test_output_minimum_values_property(dt_str):\n    try:\n        result = parser.isoparse(dt_str)\n        if result.month == 1 and result.day == 1:\n            assert result.day == 1\n            assert result.month == 1\n    except ValueError:\n        pass  # Handle invalid ISO-8601 strings", "# Property 4: The output should correctly handle both representations of midnight.\n@given(st.one_of(st.text(min_size=10, max_size=25), st.text(min_size=23, max_size=23)))  # Including '00:00' and '24:00'\ndef test_output_midnight_representation_property(dt_str):\n    try:\n        result = parser.isoparse(dt_str)\n        assert result.hour == 0 and result.minute == 0  # Both should represent midnight\n    except ValueError:\n        pass  # Handle invalid ISO-8601 strings", "# Property 5: The output should raise an appropriate error for invalid ISO-8601 strings.\n@given(st.text())\ndef test_invalid_iso_string_property(dt_str):\n    try:\n        parser.isoparse(dt_str)\n    except ValueError:\n        assert True  # Expecting an error for invalid strings\n    else:\n        assert False  # If no error is raised, the test should fail"], "api_doc": "parser.isoparse(dt_str)\uf0c1\nParse an ISO-8601 datetime string into a datetime.datetime.\n\nAn ISO-8601 datetime string consists of a date portion, followed optionally by a time portion - the date and time portions are separated by a single character separator, which is T in the official standard. Incomplete date formats (such as YYYY-MM) may not be combined with a time portion.\n\nSupported date formats are:\n\nCommon:\n\nYYYY\n\nYYYY-MM\n\nYYYY-MM-DD or YYYYMMDD\n\nUncommon:\n\nYYYY-Www or YYYYWww - ISO week (day defaults to 0)\n\nYYYY-Www-D or YYYYWwwD - ISO week and day\n\nThe ISO week and day numbering follows the same logic as datetime.date.isocalendar().\n\nSupported time formats are:\n\nhh\n\nhh:mm or hhmm\n\nhh:mm:ss or hhmmss\n\nhh:mm:ss.ssssss (Up to 6 sub-second digits)\n\nMidnight is a special case for hh, as the standard supports both 00:00 and 24:00 as a representation. The decimal separator can be either a dot or a comma.\n\nCaution\n\nSupport for fractional components other than seconds is part of the ISO-8601 standard, but is not currently implemented in this parser.\n\nSupported time zone offset formats are:\n\nZ (UTC)\n\n\u00b1HH:MM\n\n\u00b1HHMM\n\n\u00b1HH\n\nOffsets will be represented as dateutil.tz.tzoffset objects, with the exception of UTC, which will be represented as dateutil.tz.tzutc. Time zone offsets equivalent to UTC (such as +00:00) will also be represented as dateutil.tz.tzutc.\n\nParameters\n:\ndt_str \u2013 A string or stream containing only an ISO-8601 datetime string\n\nReturns\n:\nReturns a datetime.datetime representing the string. Unspecified components default to their lowest value.\n\nWarning\n\nAs of version 2.7.0, the strictness of the parser should not be considered a stable part of the contract. Any valid ISO-8601 string that parses correctly with the default settings will continue to parse correctly in future versions, but invalid strings that currently fail (e.g. 2017-01-01T00:00+00:00:00) are not guaranteed to continue failing in future versions if they encode a valid date.\n\nNew in version 2.7.0."}
