{"function_name": "dateutil.parser.isoparse", "properties": ["1. The output should always be a valid `datetime` object representing the parsed ISO date and time from the input string.", "2. If the input string represents a date and time that is exactly \"24:00\", the output should represent the next day at \"00:00\".", "3. The output `datetime` object should have the same year, month, day, hour, minute, and second values as specified in the input string, barring any adjustments for the \"24:00\" case.", "4. The function should raise a `ValueError` if the input string contains unknown ISO components, ensuring that the output is only produced for valid ISO 8601 formats.", "5. The output should maintain the timezone information if the input string includes a timezone offset, ensuring that the `datetime` object accurately reflects the specified timezone."], "pbt": ["@given(st.text())\ndef test_output_is_valid_datetime(dt_str):\n    try:\n        result = dateutil.parser.isoparse(dt_str)\n        assert isinstance(result, datetime)\n    except ValueError:\n        pass  # Expected for invalid inputs", "@given(st.text())\ndef test_output_for_24_hour_case(dt_str):\n    if \"24:00\" in dt_str:\n        result = dateutil.parser.isoparse(dt_str.replace(\"24:00\", \"00:00\"))\n        assert result == datetime.combine(result.date() + timedelta(days=1), datetime.min.time())", "@given(st.text())\ndef test_output_matches_input_components(dt_str):\n    try:\n        result = dateutil.parser.isoparse(dt_str)\n        components = dateutil.parser._parse_isodate(dt_str)\n        assert (result.year, result.month, result.day, result.hour, result.minute, result.second) == components\n    except ValueError:\n        pass  # Expected for invalid inputs", "@given(st.text())\ndef test_value_error_for_unknown_components(dt_str):\n    invalid_str = dt_str + \"XYZ\"  # Append unknown component\n    try:\n        dateutil.parser.isoparse(invalid_str)\n        assert False  # Should raise ValueError\n    except ValueError:\n        pass", "@given(st.text())\ndef test_timezone_information(dt_str):\n    if \"+00:00\" in dt_str or \"-00:00\" in dt_str:\n        result = dateutil.parser.isoparse(dt_str)\n        assert result.tzinfo is not None\n    else:\n        try:\n            result = dateutil.parser.isoparse(dt_str)\n            assert result.tzinfo is None\n        except ValueError:\n            pass  # Expected for invalid inputs"], "api_doc": "parser.isoparse(dt_str)\uf0c1\nParse an ISO-8601 datetime string into a datetime.datetime.\n\nAn ISO-8601 datetime string consists of a date portion, followed optionally by a time portion - the date and time portions are separated by a single character separator, which is T in the official standard. Incomplete date formats (such as YYYY-MM) may not be combined with a time portion.\n\nSupported date formats are:\n\nCommon:\n\nYYYY\n\nYYYY-MM\n\nYYYY-MM-DD or YYYYMMDD\n\nUncommon:\n\nYYYY-Www or YYYYWww - ISO week (day defaults to 0)\n\nYYYY-Www-D or YYYYWwwD - ISO week and day\n\nThe ISO week and day numbering follows the same logic as datetime.date.isocalendar().\n\nSupported time formats are:\n\nhh\n\nhh:mm or hhmm\n\nhh:mm:ss or hhmmss\n\nhh:mm:ss.ssssss (Up to 6 sub-second digits)\n\nMidnight is a special case for hh, as the standard supports both 00:00 and 24:00 as a representation. The decimal separator can be either a dot or a comma.\n\nCaution\n\nSupport for fractional components other than seconds is part of the ISO-8601 standard, but is not currently implemented in this parser.\n\nSupported time zone offset formats are:\n\nZ (UTC)\n\n\u00b1HH:MM\n\n\u00b1HHMM\n\n\u00b1HH\n\nOffsets will be represented as dateutil.tz.tzoffset objects, with the exception of UTC, which will be represented as dateutil.tz.tzutc. Time zone offsets equivalent to UTC (such as +00:00) will also be represented as dateutil.tz.tzutc.\n\nParameters\n:\ndt_str \u2013 A string or stream containing only an ISO-8601 datetime string\n\nReturns\n:\nReturns a datetime.datetime representing the string. Unspecified components default to their lowest value.\n\nWarning\n\nAs of version 2.7.0, the strictness of the parser should not be considered a stable part of the contract. Any valid ISO-8601 string that parses correctly with the default settings will continue to parse correctly in future versions, but invalid strings that currently fail (e.g. 2017-01-01T00:00+00:00:00) are not guaranteed to continue failing in future versions if they encode a valid date.\n\nNew in version 2.7.0."}
