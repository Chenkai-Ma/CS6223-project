{"function_name": "networkx.algorithms.approximation.dominating_set.min_weighted_dominating_set", "properties": ["1. The output dominating set must cover all vertices in the graph, meaning every vertex should either be in the dominating set or adjacent to at least one vertex in the dominating set.", "2. The output dominating set should be a subset of the input graph's vertices, ensuring that all nodes in the dominating set are valid nodes from the input graph.", "3. The size of the output dominating set should be minimized, meaning that there should not exist a smaller dominating set that covers all vertices in the graph.", "4. If the input graph is empty, the output should also be an empty set, reflecting the fact that there are no vertices to dominate.", "5. The cost-effectiveness of nodes added to the dominating set should be non-increasing; that is, each subsequent node added should have a cost-effectiveness that is less than or equal to that of the previously added node, ensuring a greedy approach is maintained throughout the process."], "pbt": ["@given(st.data())\ndef test_dominating_set_covers_all_vertices_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    weight_attr = st.one_of(st.none(), st.lists(st.integers(), min_size=len(G.nodes())))\n    if weight_attr is not None:\n        for idx, node in enumerate(G.nodes()):\n            G.nodes[node]['weight'] = weight_attr[idx] if idx < len(weight_attr) else 1\n    dom_set = min_weighted_dominating_set(G, weight='weight')\n    assert all(v in dom_set or any(adj in dom_set for adj in G[v]) for v in G)", "@given(st.data())\ndef test_dominating_set_subset_of_nodes_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    weight_attr = st.one_of(st.none(), st.lists(st.integers(), min_size=len(G.nodes())))\n    if weight_attr is not None:\n        for idx, node in enumerate(G.nodes()):\n            G.nodes[node]['weight'] = weight_attr[idx] if idx < len(weight_attr) else 1\n    dom_set = min_weighted_dominating_set(G, weight='weight')\n    assert dom_set.issubset(G.nodes())", "@given(st.data())\ndef test_dominating_set_minimized_size_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    weight_attr = st.one_of(st.none(), st.lists(st.integers(), min_size=len(G.nodes())))\n    if weight_attr is not None:\n        for idx, node in enumerate(G.nodes()):\n            G.nodes[node]['weight'] = weight_attr[idx] if idx < len(weight_attr) else 1\n    dom_set = min_weighted_dominating_set(G, weight='weight')\n    # Check against any smaller dominating set (not trivial, requires more context)\n    # Placeholder assertion: details depend on specific graph structure\n    assert len(dom_set) <= len(G.nodes())", "@given(st.data())\ndef test_empty_graph_yields_empty_dominating_set_property(data):\n    G = nx.Graph()  # Empty graph\n    dom_set = min_weighted_dominating_set(G)\n    assert dom_set == set()", "@given(st.data())\ndef test_non_increasing_cost_effectiveness_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    weight_attr = st.one_of(st.none(), st.lists(st.integers(), min_size=len(G.nodes())))\n    if weight_attr is not None:\n        for idx, node in enumerate(G.nodes()):\n            G.nodes[node]['weight'] = weight_attr[idx] if idx < len(weight_attr) else 1\n    dom_set = min_weighted_dominating_set(G, weight='weight')\n    costs = []\n    neighborhoods = {v: {v} | set(G[v]) for v in G}\n    \n    for node in dom_set:\n        neighborhood = neighborhoods[node]\n        cost = G.nodes[node].get('weight', 1) / len(neighborhood - dom_set)\n        costs.append(cost)\n    \n    assert all(costs[i] >= costs[i + 1] for i in range(len(costs) - 1))"], "api_doc": "min_weighted_dominating_set\nmin_weighted_dominating_set(G, weight=None)[source]\nReturns a dominating set that approximates the minimum weight node dominating set.\n\nParameters\n:\nG\nNetworkX graph\nUndirected graph.\n\nweight\nstring\nThe node attribute storing the weight of an node. If provided, the node attribute with this key must be a number for each node. If not provided, each node is assumed to have weight one.\n\nReturns\n:\nmin_weight_dominating_set\nset\nA set of nodes, the sum of whose weights is no more than (log w(V)) w(V^*), where w(V) denotes the sum of the weights of each node in the graph and w(V^*) denotes the sum of the weights of each node in the minimum weight dominating set.\n\nRaises\n:\nNetworkXNotImplemented\nIf G is directed.\n\nNotes\n\nThis algorithm computes an approximate minimum weighted dominating set for the graph G. The returned solution has weight (log w(V)) w(V^*), where w(V) denotes the sum of the weights of each node in the graph and w(V^*) denotes the sum of the weights of each node in the minimum weight dominating set for the graph.\n\nThis implementation of the algorithm runs in \n time, where \n is the number of edges in the graph.\n\nReferences\n\n[1]\nVazirani, Vijay V. Approximation Algorithms. Springer Science & Business Media, 2001.\n\nExamples\n\nG = nx.Graph([(0, 1), (0, 4), (1, 4), (1, 2), (2, 3), (3, 4), (2, 5)])\nnx.approximation.min_weighted_dominating_set(G)\n{1, 2, 4}"}
