{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: The output size of the large clique must be a non-negative integer, as a clique cannot have negative size or be fractional.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G)\n    result = -1  # violate the property by setting it to a negative integer\n    assert result >= 0\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G)\n    result = -100  # violate the property by setting it to a negative integer\n    assert result >= 0\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G)\n    result = 3.14  # violate the property by setting it to a fractional value\n    assert result >= 0\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G)\n    result = -50.5  # violate the property by setting it to a negative fractional value\n    assert result >= 0\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G)\n    result = \"not a number\"  # violate the property by setting it to a non-integer type\n    assert result >= 0\n```"], "property": "The output size of the large clique must be a non-negative integer, as a clique cannot have negative size or be fractional.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_large_clique_size_non_negative_integer_property(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G)\n    assert result >= 0", "properties": ["1. The output size of the large clique must be a non-negative integer, as a clique cannot have negative size or be fractional.", "2. The size of the large clique returned should not exceed the total number of nodes in the graph, as it is not possible to have a clique larger than the number of available nodes.", "3. If the graph is empty (i.e., contains no nodes), the function should return a size of 0, indicating that there are no cliques in the graph.", "4. For any graph that contains at least one edge, the size of the large clique must be at least 1, since the smallest possible clique consists of a single node.", "5. The output should be consistent across multiple calls with the same input graph, meaning that calling the function multiple times with the same graph should yield the same size of the large clique, assuming the graph has not been modified."]}
{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: The size of the large clique returned should not exceed the total number of nodes in the graph, as it is not possible to have a clique larger than the number of available nodes.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G) + 1  # Violate property by adding 1\n    assert result <= G.number_of_nodes()\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G) + 5  # Violate property by adding 5\n    assert result <= G.number_of_nodes()\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G) * 2  # Violate property by doubling the result\n    assert result <= G.number_of_nodes()\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G) + G.number_of_nodes()  # Violate property by adding total nodes\n    assert result <= G.number_of_nodes()\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G) + G.number_of_nodes() + 1  # Violate property by adding total nodes + 1\n    assert result <= G.number_of_nodes()\n```"], "property": "The size of the large clique returned should not exceed the total number of nodes in the graph, as it is not possible to have a clique larger than the number of available nodes.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_large_clique_size_within_node_count_property(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G)\n    assert result <= G.number_of_nodes()", "properties": ["1. The output size of the large clique must be a non-negative integer, as a clique cannot have negative size or be fractional.", "2. The size of the large clique returned should not exceed the total number of nodes in the graph, as it is not possible to have a clique larger than the number of available nodes.", "3. If the graph is empty (i.e., contains no nodes), the function should return a size of 0, indicating that there are no cliques in the graph.", "4. For any graph that contains at least one edge, the size of the large clique must be at least 1, since the smallest possible clique consists of a single node.", "5. The output should be consistent across multiple calls with the same input graph, meaning that calling the function multiple times with the same graph should yield the same size of the large clique, assuming the graph has not been modified."]}
{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: If the graph is empty (i.e., contains no nodes), the function should return a size of 0, indicating that there are no cliques in the graph.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G)\n    assert result == 1  # Violation: Should return 0 for empty graph\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G)\n    assert result == -1  # Violation: Should return 0 for empty graph\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G)\n    assert result == 5  # Violation: Should return 0 for empty graph\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G)\n    assert result == 10  # Violation: Should return 0 for empty graph\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G)\n    assert result == 100  # Violation: Should return 0 for empty graph\n```"], "property": "If the graph is empty (i.e., contains no nodes), the function should return a size of 0, indicating that there are no cliques in the graph.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_large_clique_size_empty_graph_property(G):\n    result = nx.algorithms.approximation.clique.large_clique_size(G)\n    assert result == 0", "properties": ["1. The output size of the large clique must be a non-negative integer, as a clique cannot have negative size or be fractional.", "2. The size of the large clique returned should not exceed the total number of nodes in the graph, as it is not possible to have a clique larger than the number of available nodes.", "3. If the graph is empty (i.e., contains no nodes), the function should return a size of 0, indicating that there are no cliques in the graph.", "4. For any graph that contains at least one edge, the size of the large clique must be at least 1, since the smallest possible clique consists of a single node.", "5. The output should be consistent across multiple calls with the same input graph, meaning that calling the function multiple times with the same graph should yield the same size of the large clique, assuming the graph has not been modified."]}
{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: For any graph that contains at least one edge, the size of the large clique must be at least 1, since the smallest possible clique consists of a single node.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers(min_value=1, max_value=100), min_size=1, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1(G):\n    if G.number_of_edges() > 0:\n        result = nx.algorithms.approximation.clique.large_clique_size(G)\n        result = -1  # Violating the property by returning a negative number\n        assert result >= 1\n\n@given(st.lists(st.integers(min_value=1, max_value=100), min_size=1, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2(G):\n    if G.number_of_edges() > 0:\n        result = nx.algorithms.approximation.clique.large_clique_size(G)\n        result = 0  # Violating the property by returning zero\n        assert result >= 1\n\n@given(st.lists(st.integers(min_value=1, max_value=100), min_size=1, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3(G):\n    if G.number_of_edges() > 0:\n        result = nx.algorithms.approximation.clique.large_clique_size(G)\n        result = -5  # Violating the property by returning a negative number\n        assert result >= 1\n\n@given(st.lists(st.integers(min_value=1, max_value=100), min_size=1, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4(G):\n    if G.number_of_edges() > 0:\n        result = nx.algorithms.approximation.clique.large_clique_size(G)\n        result = -1000  # Violating the property by returning a very large negative number\n        assert result >= 1\n\n@given(st.lists(st.integers(min_value=1, max_value=100), min_size=1, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5(G):\n    if G.number_of_edges() > 0:\n        result = nx.algorithms.approximation.clique.large_clique_size(G)\n        result = None  # Violating the property by returning None\n        assert result >= 1\n```"], "property": "For any graph that contains at least one edge, the size of the large clique must be at least 1, since the smallest possible clique consists of a single node.", "pbt": "@given(st.lists(st.integers(min_value=1, max_value=100), min_size=1, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_large_clique_size_at_least_one_edge_property(G):\n    if G.number_of_edges() > 0:\n        result = nx.algorithms.approximation.clique.large_clique_size(G)\n        assert result >= 1", "properties": ["1. The output size of the large clique must be a non-negative integer, as a clique cannot have negative size or be fractional.", "2. The size of the large clique returned should not exceed the total number of nodes in the graph, as it is not possible to have a clique larger than the number of available nodes.", "3. If the graph is empty (i.e., contains no nodes), the function should return a size of 0, indicating that there are no cliques in the graph.", "4. For any graph that contains at least one edge, the size of the large clique must be at least 1, since the smallest possible clique consists of a single node.", "5. The output should be consistent across multiple calls with the same input graph, meaning that calling the function multiple times with the same graph should yield the same size of the large clique, assuming the graph has not been modified."]}
{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: The output should be consistent across multiple calls with the same input graph, meaning that calling the function multiple times with the same graph should yield the same size of the large clique, assuming the graph has not been modified.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1(G):\n    result1 = nx.algorithms.approximation.clique.large_clique_size(G)\n    result2 = result1 + 1  # Modify output to violate consistency\n    assert result1 == result2\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2(G):\n    result1 = nx.algorithms.approximation.clique.large_clique_size(G)\n    result2 = result1 - 1  # Modify output to violate consistency\n    assert result1 == result2\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3(G):\n    result1 = nx.algorithms.approximation.clique.large_clique_size(G)\n    result2 = result1 * 2  # Modify output to violate consistency\n    assert result1 == result2\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4(G):\n    result1 = nx.algorithms.approximation.clique.large_clique_size(G)\n    result2 = result1 // 2  # Modify output to violate consistency\n    assert result1 == result2\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5(G):\n    result1 = nx.algorithms.approximation.clique.large_clique_size(G)\n    result2 = 42  # Modify output to a constant value to violate consistency\n    assert result1 == result2\n```"], "property": "The output should be consistent across multiple calls with the same input graph, meaning that calling the function multiple times with the same graph should yield the same size of the large clique, assuming the graph has not been modified.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100).map(set).map(lambda nodes: nx.Graph(nx.path_graph(nodes))), \n                )\ndef test_large_clique_size_consistent_output_property(G):\n    result1 = nx.algorithms.approximation.clique.large_clique_size(G)\n    result2 = nx.algorithms.approximation.clique.large_clique_size(G)\n    assert result1 == result2", "properties": ["1. The output size of the large clique must be a non-negative integer, as a clique cannot have negative size or be fractional.", "2. The size of the large clique returned should not exceed the total number of nodes in the graph, as it is not possible to have a clique larger than the number of available nodes.", "3. If the graph is empty (i.e., contains no nodes), the function should return a size of 0, indicating that there are no cliques in the graph.", "4. For any graph that contains at least one edge, the size of the large clique must be at least 1, since the smallest possible clique consists of a single node.", "5. The output should be consistent across multiple calls with the same input graph, meaning that calling the function multiple times with the same graph should yield the same size of the large clique, assuming the graph has not been modified."]}
