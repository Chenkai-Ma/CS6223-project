{"function_name": "networkx.algorithms.approximation.clustering_coefficient.average_clustering", "mutants": ["```python\n# property to violate: The output value must be between 0 and 1, inclusive, since the average clustering coefficient represents a fraction of triangles and cannot exceed this range.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms import approximation\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_1():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    result = approximation.average_clustering(G, trials=trials) + 1  # Violating the property by adding 1\n    assert 0 <= result <= 1\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_2():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    result = approximation.average_clustering(G, trials=trials) * 2  # Violating the property by multiplying by 2\n    assert 0 <= result <= 1\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_3():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    result = approximation.average_clustering(G, trials=trials) - 0.5  # Violating the property by subtracting 0.5\n    assert 0 <= result <= 1\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_4():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    result = approximation.average_clustering(G, trials=trials) + 2  # Violating the property by adding 2\n    assert 0 <= result <= 1\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_5():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    result = approximation.average_clustering(G, trials=trials) * 3  # Violating the property by multiplying by 3\n    assert 0 <= result <= 1\n```"], "property": "The output value must be between 0 and 1, inclusive, since the average clustering coefficient represents a fraction of triangles and cannot exceed this range.", "pbt": "@given(st.data())\ndef test_output_between_0_and_1_property(data):\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    result = approximation.average_clustering(G, trials=trials)\n    assert 0 <= result <= 1", "properties": ["1. The output value must be between 0 and 1, inclusive, since the average clustering coefficient represents a fraction of triangles and cannot exceed this range.", "3. The output should be consistent across multiple runs with the same input parameters (graph and trials) when a fixed random seed is provided, ensuring reproducibility.", "4. The output should be approximately equal to the average clustering coefficient calculated using a deterministic method for large graphs, as the approximation should converge to the true value with an adequate number of trials.", "5. If the graph is directed, the function should raise a `NetworkXNotImplemented` exception, indicating that the average clustering coefficient cannot be computed for directed graphs."]}
{"function_name": "networkx.algorithms.approximation.clustering_coefficient.average_clustering", "mutants": ["```python\n# property to violate: The output should be consistent across multiple runs with the same input parameters (graph and trials) when a fixed random seed is provided, ensuring reproducibility.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms import approximation\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_1():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    seed = 42\n    result1 = approximation.average_clustering(G, trials=trials, seed=seed)\n    result2 = approximation.average_clustering(G, trials=trials, seed=seed) + 1  # Modify output to violate property\n    assert result1 == result2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_2():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    seed = 42\n    result1 = approximation.average_clustering(G, trials=trials, seed=seed)\n    result2 = approximation.average_clustering(G, trials=trials, seed=seed) * 2  # Modify output to violate property\n    assert result1 == result2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_3():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    seed = 42\n    result1 = approximation.average_clustering(G, trials=trials, seed=seed)\n    result2 = approximation.average_clustering(G, trials=trials, seed=seed) - 0.5  # Modify output to violate property\n    assert result1 == result2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_4():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    seed = 42\n    result1 = approximation.average_clustering(G, trials=trials, seed=seed)\n    result2 = approximation.average_clustering(G, trials=trials, seed=seed) + 0.1 * result1  # Modify output to violate property\n    assert result1 == result2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_5():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    seed = 42\n    result1 = approximation.average_clustering(G, trials=trials, seed=seed)\n    result2 = approximation.average_clustering(G, trials=trials, seed=seed) + (result1 * 0.5)  # Modify output to violate property\n    assert result1 == result2\n```"], "property": "The output should be consistent across multiple runs with the same input parameters (graph and trials) when a fixed random seed is provided, ensuring reproducibility.", "pbt": "@given(st.data())\ndef test_output_consistency_with_fixed_seed_property(data):\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    seed = 42\n    result1 = approximation.average_clustering(G, trials=trials, seed=seed)\n    result2 = approximation.average_clustering(G, trials=trials, seed=seed)\n    assert result1 == result2", "properties": ["1. The output value must be between 0 and 1, inclusive, since the average clustering coefficient represents a fraction of triangles and cannot exceed this range.", "3. The output should be consistent across multiple runs with the same input parameters (graph and trials) when a fixed random seed is provided, ensuring reproducibility.", "4. The output should be approximately equal to the average clustering coefficient calculated using a deterministic method for large graphs, as the approximation should converge to the true value with an adequate number of trials.", "5. If the graph is directed, the function should raise a `NetworkXNotImplemented` exception, indicating that the average clustering coefficient cannot be computed for directed graphs."]}
{"function_name": "networkx.algorithms.approximation.clustering_coefficient.average_clustering", "mutants": ["```python\n# property to violate: The output should be approximately equal to the average clustering coefficient calculated using a deterministic method for large graphs, as the approximation should converge to the true value with an adequate number of trials.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.approximation import average_clustering\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_1():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1000, max_value=10000))\n    deterministic_result = nx.average_clustering(G)  # Using deterministic calculation\n    result = deterministic_result + 1  # Modify output to violate the property\n    assert abs(result - deterministic_result) < 0.1  # Allowing for a small margin of error\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_2():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1000, max_value=10000))\n    deterministic_result = nx.average_clustering(G)  # Using deterministic calculation\n    result = deterministic_result - 1  # Modify output to violate the property\n    assert abs(result - deterministic_result) < 0.1  # Allowing for a small margin of error\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_3():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1000, max_value=10000))\n    deterministic_result = nx.average_clustering(G)  # Using deterministic calculation\n    result = deterministic_result * 10  # Modify output to violate the property\n    assert abs(result - deterministic_result) < 0.1  # Allowing for a small margin of error\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_4():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1000, max_value=10000))\n    deterministic_result = nx.average_clustering(G)  # Using deterministic calculation\n    result = deterministic_result / 10  # Modify output to violate the property\n    assert abs(result - deterministic_result) < 0.1  # Allowing for a small margin of error\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_5():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1000, max_value=10000))\n    deterministic_result = nx.average_clustering(G)  # Using deterministic calculation\n    result = 0  # Modify output to violate the property completely\n    assert abs(result - deterministic_result) < 0.1  # Allowing for a small margin of error\n```"], "property": "The output should be approximately equal to the average clustering coefficient calculated using a deterministic method for large graphs, as the approximation should converge to the true value with an adequate number of trials.", "pbt": "@given(st.data())\ndef test_output_approximation_convergence_property(data):\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1000, max_value=10000))\n    deterministic_result = nx.average_clustering(G)  # Using deterministic calculation\n    result = approximation.average_clustering(G, trials=trials)\n    assert abs(result - deterministic_result) < 0.1  # Allowing for a small margin of error", "properties": ["1. The output value must be between 0 and 1, inclusive, since the average clustering coefficient represents a fraction of triangles and cannot exceed this range.", "3. The output should be consistent across multiple runs with the same input parameters (graph and trials) when a fixed random seed is provided, ensuring reproducibility.", "4. The output should be approximately equal to the average clustering coefficient calculated using a deterministic method for large graphs, as the approximation should converge to the true value with an adequate number of trials.", "5. If the graph is directed, the function should raise a `NetworkXNotImplemented` exception, indicating that the average clustering coefficient cannot be computed for directed graphs."]}
{"function_name": "networkx.algorithms.approximation.clustering_coefficient.average_clustering", "mutants": ["```python\n# property to violate: If the graph is directed, the function should raise a `NetworkXNotImplemented` exception, indicating that the average clustering coefficient cannot be computed for directed graphs.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.approximation import clustering_coefficient\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_1():\n    G = nx.DiGraph()\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    # Modify the output to not raise the exception\n    approximation.average_clustering(G, trials=trials)\n    assert False, \"Expected NetworkXNotImplemented exception for directed graph\"\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_2():\n    G = nx.DiGraph()\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    # Modify the output to not raise the exception\n    approximation.average_clustering(G, trials=trials)\n    assert False, \"Expected NetworkXNotImplemented exception for directed graph\"\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_3():\n    G = nx.DiGraph()\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    # Modify the output to not raise the exception\n    approximation.average_clustering(G, trials=trials)\n    assert False, \"Expected NetworkXNotImplemented exception for directed graph\"\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_4():\n    G = nx.DiGraph()\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    # Modify the output to not raise the exception\n    approximation.average_clustering(G, trials=trials)\n    assert False, \"Expected NetworkXNotImplemented exception for directed graph\"\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_5():\n    G = nx.DiGraph()\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    # Modify the output to not raise the exception\n    approximation.average_clustering(G, trials=trials)\n    assert False, \"Expected NetworkXNotImplemented exception for directed graph\"\n```"], "property": "If the graph is directed, the function should raise a `NetworkXNotImplemented` exception, indicating that the average clustering coefficient cannot be computed for directed graphs.", "pbt": "@given(st.data())\ndef test_directed_graph_not_implemented_property(data):\n    G = nx.DiGraph()\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    try:\n        approximation.average_clustering(G, trials=trials)\n        assert False, \"Expected NetworkXNotImplemented exception for directed graph\"\n    except nx.NetworkXNotImplemented:\n        pass  # Expected behavior, test passes", "properties": ["1. The output value must be between 0 and 1, inclusive, since the average clustering coefficient represents a fraction of triangles and cannot exceed this range.", "3. The output should be consistent across multiple runs with the same input parameters (graph and trials) when a fixed random seed is provided, ensuring reproducibility.", "4. The output should be approximately equal to the average clustering coefficient calculated using a deterministic method for large graphs, as the approximation should converge to the true value with an adequate number of trials.", "5. If the graph is directed, the function should raise a `NetworkXNotImplemented` exception, indicating that the average clustering coefficient cannot be computed for directed graphs."]}
