{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The output cliques are maximal, meaning that no additional nodes can be added to any of the cliques without violating the completeness of the subgraph.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.clique import find_cliques\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    cliques = list(find_cliques(G))\n    \n    # Modify cliques to make them non-maximal\n    if cliques:\n        cliques[0].append(max(G.nodes()) + 1)  # Add a non-connected node\n\n    for clique in cliques:\n        for node in clique:\n            # Check if adding any other node from G would still be a clique\n            for other in G.nodes():\n                if other not in clique and not G.has_edge(node, other):\n                    assert len(clique) == len(set(clique))  # Must be maximal\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    cliques = list(find_cliques(G))\n    \n    # Modify cliques to make them non-maximal\n    if cliques:\n        cliques[0] = cliques[0][:-1]  # Remove a node from the first clique\n\n    for clique in cliques:\n        for node in clique:\n            # Check if adding any other node from G would still be a clique\n            for other in G.nodes():\n                if other not in clique and not G.has_edge(node, other):\n                    assert len(clique) == len(set(clique))  # Must be maximal\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    cliques = list(find_cliques(G))\n    \n    # Modify cliques to make them non-maximal\n    if cliques:\n        cliques[0] = [cliques[0][0]]  # Reduce the clique to a single node\n\n    for clique in cliques:\n        for node in clique:\n            # Check if adding any other node from G would still be a clique\n            for other in G.nodes():\n                if other not in clique and not G.has_edge(node, other):\n                    assert len(clique) == len(set(clique))  # Must be maximal\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    cliques = list(find_cliques(G))\n    \n    # Modify cliques to make them non-maximal\n    if cliques:\n        cliques.append([max(G.nodes()) + 1])  # Add a new non-connected clique\n\n    for clique in cliques:\n        for node in clique:\n            # Check if adding any other node from G would still be a clique\n            for other in G.nodes():\n                if other not in clique and not G.has_edge(node, other):\n                    assert len(clique) == len(set(clique))  # Must be maximal\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    cliques = list(find_cliques(G))\n    \n    # Modify cliques to make them non-maximal\n    if cliques:\n        cliques[0] = [cliques[0][0], cliques[0][1]]  # Keep only two nodes\n\n    for clique in cliques:\n        for node in clique:\n            # Check if adding any other node from G would still be a clique\n            for other in G.nodes():\n                if other not in clique and not G.has_edge(node, other):\n                    assert len(clique) == len(set(clique))  # Must be maximal\n```"], "property": "The output cliques are maximal, meaning that no additional nodes can be added to any of the cliques without violating the completeness of the subgraph.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_output_cliques_are_maximal_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    cliques = list(find_cliques(G))\n    \n    for clique in cliques:\n        for node in clique:\n            # Check if adding any other node from G would still be a clique\n            for other in G.nodes():\n                if other not in clique and not G.has_edge(node, other):\n                    assert len(clique) == len(set(clique))  # Must be maximal", "properties": ["1. The output cliques are maximal, meaning that no additional nodes can be added to any of the cliques without violating the completeness of the subgraph.", "2. If the `nodes` parameter is provided, every returned clique must contain all nodes specified in the `nodes` list, and if `nodes` is not a clique itself, a ValueError should be raised.", "3. The output should not include any duplicate cliques, ensuring that each maximal clique is unique within the iterator.", "4. The length of each returned clique should be at least 1, as a maximal clique must contain at least one node from the graph.", "5. The order of the cliques in the output is arbitrary, meaning that different invocations of the function should not guarantee the same order of cliques, but the same cliques should be present in any valid output for the same input graph."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: If the `nodes` parameter is provided, every returned clique must contain all nodes specified in the `nodes` list, and if `nodes` is not a clique itself, a ValueError should be raised.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.clique import find_cliques\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create a complete graph\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    # Test with a subset of nodes that is not a clique\n    subset = list(graph_nodes)[:len(graph_nodes)//2]\n    # Intentionally create a clique that does not include all nodes from subset\n    cliques = list(find_cliques(G, nodes=subset))\n    cliques.append(set(graph_nodes) - {subset[0]})  # Add a clique that excludes the first node in subset\n    \n    for clique in cliques:\n        for node in subset:\n            assert node in clique  # Each clique must include all nodes in subset\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create a complete graph\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    # Test with a subset of nodes that is not a clique\n    subset = list(graph_nodes)[:len(graph_nodes)//2]\n    cliques = list(find_cliques(G, nodes=subset))\n    cliques.append({subset[0], subset[1]})  # Add a clique that does not include all nodes from subset\n    \n    for clique in cliques:\n        for node in subset:\n            assert node in clique  # Each clique must include all nodes in subset\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create a complete graph\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    # Test with a subset of nodes that is not a clique\n    subset = list(graph_nodes)[:len(graph_nodes)//2]\n    cliques = list(find_cliques(G, nodes=subset))\n    cliques.append(set(graph_nodes) - {subset[-1]})  # Add a clique that excludes the last node in subset\n    \n    for clique in cliques:\n        for node in subset:\n            assert node in clique  # Each clique must include all nodes in subset\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create a complete graph\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    # Test with a subset of nodes that is not a clique\n    subset = list(graph_nodes)[:len(graph_nodes)//2]\n    cliques = list(find_cliques(G, nodes=subset))\n    cliques.append({subset[0]})  # Add a clique that only contains the first node in subset\n    \n    for clique in cliques:\n        for node in subset:\n            assert node in clique  # Each clique must include all nodes in subset\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create a complete graph\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    # Test with a subset of nodes that is not a clique\n    subset = list(graph_nodes)[:len(graph_nodes)//2]\n    cliques = list(find_cliques(G, nodes=subset))\n    cliques.append(set(subset) - {subset[1]})  # Add a clique that excludes one node from subset\n    \n    for clique in cliques:\n        for node in subset:\n            assert node in clique  # Each clique must include all nodes in subset\n```"], "property": "If the `nodes` parameter is provided, every returned clique must contain all nodes specified in the `nodes` list, and if `nodes` is not a clique itself, a ValueError should be raised.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_nodes_included_if_provided_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create a complete graph\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    # Test with a subset of nodes\n    subset = list(graph_nodes)[:len(graph_nodes)//2]\n    cliques = list(find_cliques(G, nodes=subset))\n    \n    for clique in cliques:\n        for node in subset:\n            assert node in clique  # Each clique must include all nodes in subset", "properties": ["1. The output cliques are maximal, meaning that no additional nodes can be added to any of the cliques without violating the completeness of the subgraph.", "2. If the `nodes` parameter is provided, every returned clique must contain all nodes specified in the `nodes` list, and if `nodes` is not a clique itself, a ValueError should be raised.", "3. The output should not include any duplicate cliques, ensuring that each maximal clique is unique within the iterator.", "4. The length of each returned clique should be at least 1, as a maximal clique must contain at least one node from the graph.", "5. The order of the cliques in the output is arbitrary, meaning that different invocations of the function should not guarantee the same order of cliques, but the same cliques should be present in any valid output for the same input graph."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The output should not include any duplicate cliques, ensuring that each maximal clique is unique within the iterator.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.clique import find_cliques\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n\n    cliques = list(find_cliques(G))\n    cliques.append(cliques[0])  # Introducing a duplicate of the first clique\n    assert len(cliques) == len(set(tuple(sorted(clique)) for clique in cliques))  # Must be unique\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n\n    cliques = list(find_cliques(G))\n    cliques.extend(cliques)  # Duplicating the entire list of cliques\n    assert len(cliques) == len(set(tuple(sorted(clique)) for clique in cliques))  # Must be unique\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n\n    cliques = list(find_cliques(G))\n    cliques += cliques[:2]  # Adding the first two cliques again\n    assert len(cliques) == len(set(tuple(sorted(clique)) for clique in cliques))  # Must be unique\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n\n    cliques = list(find_cliques(G))\n    cliques += [cliques[-1]]  # Adding a duplicate of the last clique\n    assert len(cliques) == len(set(tuple(sorted(clique)) for clique in cliques))  # Must be unique\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n\n    cliques = list(find_cliques(G))\n    cliques = cliques * 3  # Tripling the list of cliques\n    assert len(cliques) == len(set(tuple(sorted(clique)) for clique in cliques))  # Must be unique\n```"], "property": "The output should not include any duplicate cliques, ensuring that each maximal clique is unique within the iterator.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_output_cliques_are_unique_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n\n    cliques = list(find_cliques(G))\n    assert len(cliques) == len(set(tuple(sorted(clique)) for clique in cliques))  # Must be unique", "properties": ["1. The output cliques are maximal, meaning that no additional nodes can be added to any of the cliques without violating the completeness of the subgraph.", "2. If the `nodes` parameter is provided, every returned clique must contain all nodes specified in the `nodes` list, and if `nodes` is not a clique itself, a ValueError should be raised.", "3. The output should not include any duplicate cliques, ensuring that each maximal clique is unique within the iterator.", "4. The length of each returned clique should be at least 1, as a maximal clique must contain at least one node from the graph.", "5. The order of the cliques in the output is arbitrary, meaning that different invocations of the function should not guarantee the same order of cliques, but the same cliques should be present in any valid output for the same input graph."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The length of each returned clique should be at least 1, as a maximal clique must contain at least one node from the graph.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.clique import find_cliques\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    cliques = list(find_cliques(G))\n    \n    # Violate the property by returning an empty clique\n    cliques.append(set())  # Adding an empty set to the cliques\n    \n    for clique in cliques:\n        assert len(clique) >= 1  # Each clique must have at least one node\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    cliques = list(find_cliques(G))\n    \n    # Violate the property by modifying the cliques to be empty\n    cliques = [set()] * len(cliques)  # Create a list of empty sets\n    \n    for clique in cliques:\n        assert len(clique) >= 1  # Each clique must have at least one node\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    cliques = list(find_cliques(G))\n    \n    # Violate the property by filtering out all cliques\n    cliques = [clique for clique in cliques if False]  # No cliques will remain\n    \n    for clique in cliques:\n        assert len(clique) >= 1  # Each clique must have at least one node\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    cliques = list(find_cliques(G))\n    \n    # Violate the property by appending multiple empty cliques\n    cliques += [set(), set()]  # Adding multiple empty sets to the cliques\n    \n    for clique in cliques:\n        assert len(clique) >= 1  # Each clique must have at least one node\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    cliques = list(find_cliques(G))\n    \n    # Violate the property by returning a single empty clique\n    cliques = [set()]  # Only an empty set\n    \n    for clique in cliques:\n        assert len(clique) >= 1  # Each clique must have at least one node\n```"], "property": "The length of each returned clique should be at least 1, as a maximal clique must contain at least one node from the graph.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_length_of_cliques_is_at_least_one_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n    \n    cliques = list(find_cliques(G))\n    \n    for clique in cliques:\n        assert len(clique) >= 1  # Each clique must have at least one node", "properties": ["1. The output cliques are maximal, meaning that no additional nodes can be added to any of the cliques without violating the completeness of the subgraph.", "2. If the `nodes` parameter is provided, every returned clique must contain all nodes specified in the `nodes` list, and if `nodes` is not a clique itself, a ValueError should be raised.", "3. The output should not include any duplicate cliques, ensuring that each maximal clique is unique within the iterator.", "4. The length of each returned clique should be at least 1, as a maximal clique must contain at least one node from the graph.", "5. The order of the cliques in the output is arbitrary, meaning that different invocations of the function should not guarantee the same order of cliques, but the same cliques should be present in any valid output for the same input graph."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The order of the cliques in the output is arbitrary, meaning that different invocations of the function should not guarantee the same order of cliques, but the same cliques should be present in any valid output for the same input graph.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.clique import find_cliques\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n\n    cliques1 = list(find_cliques(G))\n    cliques2 = list(find_cliques(G))\n    \n    # Violation: Ensure cliques2 is always a sorted version of cliques1\n    cliques2 = sorted(cliques1, key=lambda x: (len(x), x))  # This forces the order to be the same\n    \n    # Check that the same cliques can be found, but order may differ\n    assert set(map(tuple, cliques1)) == set(map(tuple, cliques2))  # Must contain the same cliques\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n\n    cliques1 = list(find_cliques(G))\n    cliques2 = list(find_cliques(G))\n    \n    # Violation: Make cliques2 a copy of cliques1\n    cliques2 = cliques1[:]  # This forces cliques2 to always be the same as cliques1\n    \n    # Check that the same cliques can be found, but order may differ\n    assert set(map(tuple, cliques1)) == set(map(tuple, cliques2))  # Must contain the same cliques\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n\n    cliques1 = list(find_cliques(G))\n    cliques2 = list(find_cliques(G))\n    \n    # Violation: Force cliques2 to always be in a specific order\n    cliques2.sort(key=lambda x: x[0])  # This forces cliques2 to be sorted by the first element\n    \n    # Check that the same cliques can be found, but order may differ\n    assert set(map(tuple, cliques1)) == set(map(tuple, cliques2))  # Must contain the same cliques\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n\n    cliques1 = list(find_cliques(G))\n    cliques2 = list(find_cliques(G))\n    \n    # Violation: Reverse the order of cliques2\n    cliques2.reverse()  # This forces cliques2 to be in reverse order of cliques1\n    \n    # Check that the same cliques can be found, but order may differ\n    assert set(map(tuple, cliques1)) == set(map(tuple, cliques2))  # Must contain the same cliques\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n\n    cliques1 = list(find_cliques(G))\n    cliques2 = list(find_cliques(G))\n    \n    # Violation: Always return cliques2 sorted by length of cliques\n    cliques2 = sorted(cliques1, key=len)  # This forces cliques2 to be ordered by length\n    \n    # Check that the same cliques can be found, but order may differ\n    assert set(map(tuple, cliques1)) == set(map(tuple, cliques2))  # Must contain the same cliques\n```"], "property": "The order of the cliques in the output is arbitrary, meaning that different invocations of the function should not guarantee the same order of cliques, but the same cliques should be present in any valid output for the same input graph.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, unique=True).map(set))\ndef test_order_of_cliques_is_arbitrary_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Add edges to create cliques\n    for i in graph_nodes:\n        for j in graph_nodes:\n            if i != j:\n                G.add_edge(i, j)\n\n    cliques1 = list(find_cliques(G))\n    cliques2 = list(find_cliques(G))\n    \n    # Check that the same cliques can be found, but order may differ\n    assert set(map(tuple, cliques1)) == set(map(tuple, cliques2))  # Must contain the same cliques", "properties": ["1. The output cliques are maximal, meaning that no additional nodes can be added to any of the cliques without violating the completeness of the subgraph.", "2. If the `nodes` parameter is provided, every returned clique must contain all nodes specified in the `nodes` list, and if `nodes` is not a clique itself, a ValueError should be raised.", "3. The output should not include any duplicate cliques, ensuring that each maximal clique is unique within the iterator.", "4. The length of each returned clique should be at least 1, as a maximal clique must contain at least one node from the graph.", "5. The order of the cliques in the output is arbitrary, meaning that different invocations of the function should not guarantee the same order of cliques, but the same cliques should be present in any valid output for the same input graph."]}
