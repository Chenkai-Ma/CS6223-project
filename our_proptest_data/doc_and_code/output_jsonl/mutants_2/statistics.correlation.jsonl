{"function_name": "statistics.correlation", "mutants": ["```python\n# property to violate: If both input lists are constant (i.e., all elements are the same), the function should raise a StatisticsError indicating that at least one of the inputs is constant.\nfrom hypothesis import given, strategies as st\nimport statistics\nfrom statistics import StatisticsError\n\n@given(st.lists(st.floats(), min_size=2).filter(lambda lst: len(set(lst)) == 1),\n               st.lists(st.floats(), min_size=2))\ndef test_violation_of_statistics_correlation_1(x, y):\n    # Modify y to also be constant, which should raise an error\n    y = [y[0]] * len(x)  # Make y constant\n    try:\n        statistics.correlation(x, y)\n        assert False, \"Expected StatisticsError but function executed successfully.\"\n    except StatisticsError:\n        pass\n\n@given(st.lists(st.floats(), min_size=2).filter(lambda lst: len(set(lst)) == 1),\n               st.lists(st.floats(), min_size=2))\ndef test_violation_of_statistics_correlation_2(x, y):\n    # Make x constant but change y to a single constant value\n    x = [x[0]] * len(y)  # Make x constant\n    y = [1.0] * len(y)  # Make y constant\n    try:\n        statistics.correlation(x, y)\n        assert False, \"Expected StatisticsError but function executed successfully.\"\n    except StatisticsError:\n        pass\n\n@given(st.lists(st.floats(), min_size=2).filter(lambda lst: len(set(lst)) == 1),\n               st.lists(st.floats(), min_size=2))\ndef test_violation_of_statistics_correlation_3(x, y):\n    # Make both x and y constant with different constant values\n    x = [x[0]] * len(x)  # Make x constant\n    y = [2.0] * len(x)  # Make y constant with a different value\n    try:\n        statistics.correlation(x, y)\n        assert False, \"Expected StatisticsError but function executed successfully.\"\n    except StatisticsError:\n        pass\n\n@given(st.lists(st.floats(), min_size=2).filter(lambda lst: len(set(lst)) == 1),\n               st.lists(st.floats(), min_size=2))\ndef test_violation_of_statistics_correlation_4(x, y):\n    # Create a constant y and modify x to also be constant\n    y = [y[0]] * len(y)  # Make y constant\n    x = [3.0] * len(y)  # Make x constant with a different value\n    try:\n        statistics.correlation(x, y)\n        assert False, \"Expected StatisticsError but function executed successfully.\"\n    except StatisticsError:\n        pass\n\n@given(st.lists(st.floats(), min_size=2).filter(lambda lst: len(set(lst)) == 1),\n               st.lists(st.floats(), min_size=2))\ndef test_violation_of_statistics_correlation_5(x, y):\n    # Make both x and y constant with the same value\n    constant_value = x[0]  # Get the constant value from x\n    x = [constant_value] * len(x)  # Make x constant\n    y = [constant_value] * len(y)  # Make y constant\n    try:\n        statistics.correlation(x, y)\n        assert False, \"Expected StatisticsError but function executed successfully.\"\n    except StatisticsError:\n        pass\n```"], "property": "If both input lists are constant (i.e., all elements are the same), the function should raise a StatisticsError indicating that at least one of the inputs is constant.", "pbt": "@given(st.lists(st.floats(), min_size=2).filter(lambda lst: len(set(lst)) == 1),\n               st.lists(st.floats(), min_size=2))\ndef test_correlation_constant_input_property(x, y):\n    try:\n        statistics.correlation(x, y)\n        assert False, \"Expected StatisticsError but function executed successfully.\"\n    except StatisticsError:\n        pass", "properties": ["2. If both input lists are constant (i.e., all elements are the same), the function should raise a StatisticsError indicating that at least one of the inputs is constant."]}
