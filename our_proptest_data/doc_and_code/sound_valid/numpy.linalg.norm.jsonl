{"function_name": "numpy.linalg.norm", "properties": ["1. The norm of a zero vector should always be zero, regardless of the specified order (`ord`).", "2. The norm should be non-negative for any input vector or matrix, and it should return zero only for the zero vector or matrix.", "4. The norm of a matrix computed with `ord='fro'` should be equal to the norm computed with `ord=2` when considering the singular values of the matrix."], "pbt": ["@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1, max_size=1000))\ndef test_norm_zero_vector_property(vec):\n    zero_vector = np.zeros_like(vec)\n    assert LA.norm(zero_vector) == 0.0", "@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1, max_size=1000))\ndef test_norm_non_negative_property(vec):\n    norm_value = LA.norm(vec)\n    assert norm_value >= 0", "@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1, max_size=1000))\ndef test_frobenius_norm_equivalence_property(mat):\n    mat = np.array(mat).reshape((len(mat), 1))  # Reshape to ensure it's at least 2D\n    frobenius_norm = LA.norm(mat, ord='fro')\n    singular_value_norm = LA.norm(mat, ord=2)\n    assert np.isclose(frobenius_norm, singular_value_norm)"], "api_doc": "numpy.linalg.norm\nlinalg.norm(x, ord=None, axis=None, keepdims=False)[source]\nMatrix or vector norm.\n\nThis function is able to return one of eight different matrix norms, or one of an infinite number of vector norms (described below), depending on the value of the ord parameter.\n\nParameters:\nxarray_like\nInput array. If axis is None, x must be 1-D or 2-D, unless ord is None. If both axis and ord are None, the 2-norm of x.ravel will be returned.\n\nord{non-zero int, inf, -inf, \u2018fro\u2019, \u2018nuc\u2019}, optional\nOrder of the norm (see table under Notes). inf means numpy\u2019s inf object. The default is None.\n\naxis{None, int, 2-tuple of ints}, optional.\nIf axis is an integer, it specifies the axis of x along which to compute the vector norms. If axis is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If axis is None then either a vector norm (when x is 1-D) or a matrix norm (when x is 2-D) is returned. The default is None.\n\nNew in version 1.8.0.\n\nkeepdimsbool, optional\nIf this is set to True, the axes which are normed over are left in the result as dimensions with size one. With this option the result will broadcast correctly against the original x.\n\nNew in version 1.10.0.\n\nReturns:\nn\nfloat or ndarray\nNorm of the matrix or vector(s).\n\nSee also\n\nscipy.linalg.norm\nSimilar function in SciPy.\n\nNotes\n\nFor values of ord < 1, the result is, strictly speaking, not a mathematical \u2018norm\u2019, but it may still be useful for various numerical purposes.\n\nThe following norms can be calculated:\n\nord\n\nnorm for matrices\n\nnorm for vectors\n\nNone\n\nFrobenius norm\n\n2-norm\n\n\u2018fro\u2019\n\nFrobenius norm\n\n\u2013\n\n\u2018nuc\u2019\n\nnuclear norm\n\n\u2013\n\ninf\n\nmax(sum(abs(x), axis=1))\n\nmax(abs(x))\n\n-inf\n\nmin(sum(abs(x), axis=1))\n\nmin(abs(x))\n\n0\n\n\u2013\n\nsum(x != 0)\n\n1\n\nmax(sum(abs(x), axis=0))\n\nas below\n\n-1\n\nmin(sum(abs(x), axis=0))\n\nas below\n\n2\n\n2-norm (largest sing. value)\n\nas below\n\n-2\n\nsmallest singular value\n\nas below\n\nother\n\n\u2013\n\nsum(abs(x)**ord)**(1./ord)\n\nThe Frobenius norm is given by [1]:\n\n\nThe nuclear norm is the sum of the singular values.\n\nBoth the Frobenius and nuclear norm orders are only defined for matrices and raise a ValueError when x.ndim != 2.\n\nReferences\n\n[1]\nG. H. Golub and C. F. Van Loan, Matrix Computations, Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15\n\nExamples\n\nimport numpy as np\nfrom numpy import linalg as LA\na = np.arange(9) - 4\na\narray([-4, -3, -2, ...,  2,  3,  4])\nb = a.reshape((3, 3))\nb\narray([[-4, -3, -2],\n       [-1,  0,  1],\n       [ 2,  3,  4]])\nLA.norm(a)\n7.745966692414834\nLA.norm(b)\n7.745966692414834\nLA.norm(b, 'fro')\n7.745966692414834\nLA.norm(a, np.inf)\n4.0\nLA.norm(b, np.inf)\n9.0\nLA.norm(a, -np.inf)\n0.0\nLA.norm(b, -np.inf)\n2.0\nLA.norm(a, 1)\n20.0\nLA.norm(b, 1)\n7.0\nLA.norm(a, -1)\n-4.6566128774142013e-010\nLA.norm(b, -1)\n6.0\nLA.norm(a, 2)\n7.745966692414834\nLA.norm(b, 2)\n7.3484692283495345\nLA.norm(a, -2)\n0.0\nLA.norm(b, -2)\n1.8570331885190563e-016 # may vary\nLA.norm(a, 3)\n5.8480354764257312 # may vary\nLA.norm(a, -3)\n0.0\nUsing the axis argument to compute vector norms:\n\nc = np.array([[ 1, 2, 3],\n              [-1, 1, 4]])\nLA.norm(c, axis=0)\narray([ 1.41421356,  2.23606798,  5.        ])\nLA.norm(c, axis=1)\narray([ 3.74165739,  4.24264069])\nLA.norm(c, ord=1, axis=1)\narray([ 6.,  6.])\nUsing the axis argument to compute matrix norms:\n\nm = np.arange(8).reshape(2,2,2)\nLA.norm(m, axis=(1,2))\narray([  3.74165739,  11.22497216])\nLA.norm(m[0, :, :]), LA.norm(m[1, :, :])\n(3.7416573867739413, 11.224972160321824)"}
