{"function_name": "decimal.Decimal.shift", "properties": ["3. Shifting by zero should return the original operand, confirming that no changes occur when the shift amount is zero.", "5. The output's coefficient should not exceed the defined precision in the context, ensuring that the result adheres to the maximum allowable digits as specified by the context's precision."], "pbt": ["@given(st.decimals(allow_nan=False, allow_infinity=False))\ndef test_shifting_by_zero_returns_original_operand_property(d):\n    result = d.shift(0)\n    assert result == d", "@given(st.decimals(), st.integers(min_value=-getcontext().prec, max_value=getcontext().prec))\ndef test_shift_precision_property(value, shift_amount):\n    result = value.shift(shift_amount)\n    assert len(str(result)) <= getcontext().prec"], "api_doc": "shift(other, context=None)\nReturn the result of shifting the digits of the first operand by an amount specified by the second operand. The second operand must be an integer in the range -precision through precision. The absolute value of the second operand gives the number of places to shift. If the second operand is positive then the shift is to the left; otherwise the shift is to the right. Digits shifted into the coefficient are zeros. The sign and exponent of the first operand are unchanged.", "api_code": "def shift(self, other, context=None):\n    if context is None:\n        context = getcontext()\n\n    other = _convert_other(other, raiseit=True)\n\n    ans = self._check_nans(other, context)\n    if ans:\n        return ans\n\n    if other._exp != 0:\n        return context._raise_error(InvalidOperation)\n    if not (-context.prec <= int(other) <= context.prec):\n        return context._raise_error(InvalidOperation)\n\n    if self._isinfinity():\n        return Decimal(self)\n\n    # get values, pad if necessary\n    torot = int(other)\n    rotdig = self._int\n    topad = context.prec - len(rotdig)\n    if topad > 0:\n        rotdig = '0'*topad + rotdig\n    elif topad < 0:\n        rotdig = rotdig[-topad:]\n\n    # let's shift!\n    if torot < 0:\n        shifted = rotdig[:torot]\n    else:\n        shifted = rotdig + '0'*torot\n        shifted = shifted[-context.prec:]\n\n    return _dec_from_triple(self._sign,\n                                shifted.lstrip('0') or '0', self._exp)"}