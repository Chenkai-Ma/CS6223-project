{"function_name": "networkx.algorithms.approximation.dominating_set.min_weighted_dominating_set", "properties": ["1. The output set of nodes is a subset of the input graph's nodes, meaning all nodes in the dominating set must be present in the original graph \\( G \\).", "2. The output set of nodes covers all vertices in the graph \\( G \\), ensuring that every vertex is either in the dominating set or is a neighbor of at least one node in the dominating set.", "3. The sum of the weights of the nodes in the output set does not exceed \\( (\\log w(V)) w(V^*) \\), where \\( w(V) \\) is the sum of the weights of all nodes in the graph and \\( w(V^*) \\) is the weight of the minimum weight dominating set.", "4. If the input graph \\( G \\) is empty, the output should be an empty set, as there are no nodes to dominate.", "5. The output set should remain unchanged if the input graph \\( G \\) is modified in such a way that the dominating set still covers all vertices, ensuring the algorithm's robustness to certain structural changes in the graph."], "pbt": ["@given(st.data())\ndef test_output_subset_of_input_property(data):\n    # Generate a random undirected graph\n    G = data.draw(st.builds(nx.Graph, edges=st.lists(st.tuples(st.integers(), st.integers()), min_size=1)))\n    dominating_set = min_weighted_dominating_set(G)\n\n    # Check that all nodes in the dominating set are part of the original graph\n    assert dominating_set.issubset(G.nodes)", "@given(st.data())\ndef test_output_covers_all_vertices_property(data):\n    # Generate a random undirected graph\n    G = data.draw(st.builds(nx.Graph, edges=st.lists(st.tuples(st.integers(), st.integers()), min_size=1)))\n    dominating_set = min_weighted_dominating_set(G)\n\n    # Check that every vertex is either in the dominating set or adjacent to a node in the dominating set\n    for node in G.nodes:\n        assert node in dominating_set or any(neighbor in dominating_set for neighbor in G.neighbors(node))", "@given(st.data())\ndef test_output_weight_constraint_property(data):\n    # Generate a random undirected graph with weights\n    G = data.draw(st.builds(nx.Graph, edges=st.lists(st.tuples(st.integers(), st.integers()), min_size=1)))\n    weights = {node: data.draw(st.integers(min_value=1, max_value=100)) for node in G.nodes}\n    nx.set_node_attributes(G, weights, 'weight')\n    dominating_set = min_weighted_dominating_set(G, weight='weight')\n\n    # Calculate weights\n    total_weight = sum(weights[node] for node in G.nodes)\n    min_weight_dominating_set_weight = sum(weights[node] for node in dominating_set)\n    \n    # Check the weight constraint\n    log_w_V = 1 if total_weight == 0 else (len(str(total_weight)))  # Simple log approximation\n    assert min_weight_dominating_set_weight <= (log_w_V * min_weight_dominating_set_weight)", "@given(st.data())\ndef test_empty_graph_property(data):\n    # Test with an empty graph\n    G = nx.Graph()\n    dominating_set = min_weighted_dominating_set(G)\n    \n    # Check that the output is an empty set\n    assert dominating_set == set()", "@given(st.data())\ndef test_output_robustness_property(data):\n    # Generate a random undirected graph\n    G = data.draw(st.builds(nx.Graph, edges=st.lists(st.tuples(st.integers(), st.integers()), min_size=1)))\n    dominating_set = min_weighted_dominating_set(G)\n\n    # Modify the graph in a way that should not change the dominating set\n    if G.number_of_nodes() > 0:\n        G.add_node(max(G.nodes) + 1)  # Add a new isolated node\n    new_dominating_set = min_weighted_dominating_set(G)\n    \n    # Check that the original dominating set remains valid in the modified graph\n    assert new_dominating_set.issuperset(dominating_set)"], "api_doc": "min_weighted_dominating_set\nmin_weighted_dominating_set(G, weight=None)[source]\nReturns a dominating set that approximates the minimum weight node dominating set.\n\nParameters\n:\nG\nNetworkX graph\nUndirected graph.\n\nweight\nstring\nThe node attribute storing the weight of an node. If provided, the node attribute with this key must be a number for each node. If not provided, each node is assumed to have weight one.\n\nReturns\n:\nmin_weight_dominating_set\nset\nA set of nodes, the sum of whose weights is no more than (log w(V)) w(V^*), where w(V) denotes the sum of the weights of each node in the graph and w(V^*) denotes the sum of the weights of each node in the minimum weight dominating set.\n\nRaises\n:\nNetworkXNotImplemented\nIf G is directed.\n\nNotes\n\nThis algorithm computes an approximate minimum weighted dominating set for the graph G. The returned solution has weight (log w(V)) w(V^*), where w(V) denotes the sum of the weights of each node in the graph and w(V^*) denotes the sum of the weights of each node in the minimum weight dominating set for the graph.\n\nThis implementation of the algorithm runs in \n time, where \n is the number of edges in the graph.\n\nReferences\n\n[1]\nVazirani, Vijay V. Approximation Algorithms. Springer Science & Business Media, 2001.\n\nExamples\n\nG = nx.Graph([(0, 1), (0, 4), (1, 4), (1, 2), (2, 3), (3, 4), (2, 5)])\nnx.approximation.min_weighted_dominating_set(G)\n{1, 2, 4}", "api_code": "@not_implemented_for(\"directed\")\n@nx._dispatchable(node_attrs=\"weight\")\ndef min_weighted_dominating_set(G, weight=None):\n    # The unique dominating set for the null graph is the empty set.\n    if len(G) == 0:\n        return set()\n\n    # This is the dominating set that will eventually be returned.\n    dom_set = set()\n\n    def _cost(node_and_neighborhood):\n        \"\"\"Returns the cost-effectiveness of greedily choosing the given\n        node.\n\n        `node_and_neighborhood` is a two-tuple comprising a node and its\n        closed neighborhood.\n\n        \"\"\"\n        v, neighborhood = node_and_neighborhood\n        return G.nodes[v].get(weight, 1) / len(neighborhood - dom_set)\n\n    # This is a set of all vertices not already covered by the\n    # dominating set.\n    vertices = set(G)\n    # This is a dictionary mapping each node to the closed neighborhood\n    # of that node.\n    neighborhoods = {v: {v} | set(G[v]) for v in G}\n\n    # Continue until all vertices are adjacent to some node in the\n    # dominating set.\n    while vertices:\n        # Find the most cost-effective node to add, along with its\n        # closed neighborhood.\n        dom_node, min_set = min(neighborhoods.items(), key=_cost)\n        # Add the node to the dominating set and reduce the remaining\n        # set of nodes to cover.\n        dom_set.add(dom_node)\n        del neighborhoods[dom_node]\n        vertices -= min_set\n\n    return dom_set"}