{"function_name": "decimal.Decimal.from_float", "properties": ["1. The output must be an instance of the `Decimal` class.", "4. For integer inputs, the output must be equivalent to `Decimal(str(abs(f)))` with the appropriate sign, confirming that the integer is correctly converted to a decimal representation.", "5. The output must maintain the same sign as the input float or integer, ensuring that positive inputs yield positive `Decimal` instances and negative inputs yield negative `Decimal` instances."], "pbt": ["@given(st.floats(allow_nan=False, allow_infinity=False))\ndef test_output_is_instance_of_decimal_property(f):\n    result = Decimal.from_float(f)\n    assert isinstance(result, Decimal)", "@given(st.integers())\ndef test_output_equivalent_to_decimal_of_absolute_integer_property(i):\n    result = Decimal.from_float(i)\n    expected = Decimal(str(abs(i))) * (1 if i >= 0 else -1)\n    assert result == expected", "@given(st.floats(allow_nan=False, allow_infinity=False))\ndef test_output_maintains_sign_of_input_property(f):\n    result = Decimal.from_float(f)\n    assert (result.is_signed() and f < 0) or (not result.is_signed() and f >= 0)"], "api_doc": "classmethod from_float(f)\nAlternative constructor that only accepts instances of float or int.\n\nNote Decimal.from_float(0.1) is not the same as Decimal('0.1'). Since 0.1 is not exactly representable in binary floating point, the value is stored as the nearest representable value which is 0x1.999999999999ap-4. That equivalent value in decimal is 0.1000000000000000055511151231257827021181583404541015625.\n\nNote From Python 3.2 onwards, a Decimal instance can also be constructed directly from a float.\n>>>\nDecimal.from_float(0.1)\nDecimal('0.1000000000000000055511151231257827021181583404541015625')\nDecimal.from_float(float('nan'))\nDecimal('NaN')\nDecimal.from_float(float('inf'))\nDecimal('Infinity')\nDecimal.from_float(float('-inf'))\nDecimal('-Infinity')\nAdded in version 3.1.", "api_code": "@classmethod\ndef from_float(cls, f):\n    if isinstance(f, int):                # handle integer inputs\n        sign = 0 if f >= 0 else 1\n        k = 0\n        coeff = str(abs(f))\n    elif isinstance(f, float):\n        if _math.isinf(f) or _math.isnan(f):\n            return cls(repr(f))\n        if _math.copysign(1.0, f) == 1.0:\n            sign = 0\n        else:\n            sign = 1\n        n, d = abs(f).as_integer_ratio()\n        k = d.bit_length() - 1\n        coeff = str(n*5**k)\n    else:\n        raise TypeError(\"argument must be int or float.\")\n\n    result = _dec_from_triple(sign, coeff, -k)\n    if cls is Decimal:\n        return result\n    else:\n        return cls(result)"}