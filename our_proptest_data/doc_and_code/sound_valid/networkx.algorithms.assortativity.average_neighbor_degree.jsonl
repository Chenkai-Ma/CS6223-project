{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "properties": ["1. The output dictionary should contain an entry for every node in the input graph, with each node as a key.", "2. The average neighbor degree for any node should be a non-negative float value, as it represents an average degree.", "3. If a node has no neighbors (degree zero), its average neighbor degree should be zero.", "4. The average neighbor degree of a node should be equal to the total degree of its neighbors divided by the number of neighbors, adhering to the mathematical definition provided in the documentation.", "5. The average neighbor degree should remain consistent regardless of the order in which nodes are processed, ensuring that the output is stable across multiple invocations with the same graph and parameters."], "pbt": ["@given(st.data())\ndef test_average_neighbor_degree_contains_all_nodes_property(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Check that each node in the graph is a key in the result\n    assert all(node in result for node in G.nodes)", "@given(st.data())\ndef test_average_neighbor_degree_non_negative_values_property(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Check that the average neighbor degree values are non-negative\n    assert all(value >= 0 for value in result.values())", "@given(st.data())\ndef test_average_neighbor_degree_zero_for_isolated_nodes_property(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    # Add an isolated node\n    G.add_node('isolated_node')\n    result = nx.average_neighbor_degree(G)\n    # Check that the isolated node has an average neighbor degree of zero\n    assert result.get('isolated_node', 0) == 0", "@given(st.data())\ndef test_average_neighbor_degree_correctness_property(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    for node in G.nodes:\n        neighbors = list(G.neighbors(node))\n        if neighbors:\n            expected_avg = sum(G.degree(n) for n in neighbors) / len(neighbors)\n            assert result[node] == expected_avg", "@given(st.data())\ndef test_average_neighbor_degree_stability_property(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result1 = nx.average_neighbor_degree(G)\n    result2 = nx.average_neighbor_degree(G)\n    # Check that the results are consistent across multiple calls\n    assert result1 == result2"], "api_doc": "average_neighbor_degree\naverage_neighbor_degree(G, source='out', target='out', nodes=None, weight=None)[source]\nReturns the average degree of the neighborhood of each node.\n\nIn an undirected graph, the neighborhood N(i) of node i contains the nodes that are connected to i by an edge.\n\nFor directed graphs, N(i) is defined according to the parameter source:\n\nif source is \u2018in\u2019, then N(i) consists of predecessors of node i.\n\nif source is \u2018out\u2019, then N(i) consists of successors of node i.\n\nif source is \u2018in+out\u2019, then N(i) is both predecessors and successors.\n\nThe average neighborhood degree of a node i is\n\n \n \nwhere N(i) are the neighbors of node i and k_j is the degree of node j which belongs to N(i). For weighted graphs, an analogous measure can be defined [1],\n\n \n \nwhere s_i is the weighted degree of node i, w_{ij} is the weight of the edge that links i and j and N(i) are the neighbors of node i.\n\nParameters\n:\nG\nNetworkX graph\nsource\nstring (\u201cin\u201d|\u201dout\u201d|\u201din+out\u201d), optional (default=\u201dout\u201d)\nDirected graphs only. Use \u201cin\u201d- or \u201cout\u201d-neighbors of source node.\n\ntarget\nstring (\u201cin\u201d|\u201dout\u201d|\u201din+out\u201d), optional (default=\u201dout\u201d)\nDirected graphs only. Use \u201cin\u201d- or \u201cout\u201d-degree for target node.\n\nnodes\nlist or iterable, optional (default=G.nodes)\nCompute neighbor degree only for specified nodes.\n\nweight\nstring or None, optional (default=None)\nThe edge attribute that holds the numerical value used as a weight. If None, then each edge has weight 1.\n\nReturns\n:\nd: dict\nA dictionary keyed by node to the average degree of its neighbors.\n\nRaises\n:\nNetworkXError\nIf either source or target are not one of \u2018in\u2019, \u2018out\u2019, or \u2018in+out\u2019. If either source or target is passed for an undirected graph.\n\nSee also\n\naverage_degree_connectivity\nReferences\n\n[1]\nA. Barrat, M. Barth\u00e9lemy, R. Pastor-Satorras, and A. Vespignani, \u201cThe architecture of complex weighted networks\u201d. PNAS 101 (11): 3747\u20133752 (2004).\n\nExamples\n\nG = nx.path_graph(4)\nG.edges[0, 1][\"weight\"] = 5\nG.edges[2, 3][\"weight\"] = 3\nnx.average_neighbor_degree(G)\n{0: 2.0, 1: 1.5, 2: 1.5, 3: 2.0}\nnx.average_neighbor_degree(G, weight=\"weight\")\n{0: 2.0, 1: 1.1666666666666667, 2: 1.25, 3: 2.0}\nG = nx.DiGraph()\nnx.add_path(G, [0, 1, 2, 3])\nnx.average_neighbor_degree(G, source=\"in\", target=\"in\")\n{0: 0.0, 1: 0.0, 2: 1.0, 3: 1.0}\nnx.average_neighbor_degree(G, source=\"out\", target=\"out\")\n{0: 1.0, 1: 1.0, 2: 0.0, 3: 0.0}", "api_code": "@nx._dispatchable(edge_attrs=\"weight\")\ndef average_neighbor_degree(G, source=\"out\", target=\"out\", nodes=None, weight=None):\n    if G.is_directed():\n        if source == \"in\":\n            source_degree = G.in_degree\n        elif source == \"out\":\n            source_degree = G.out_degree\n        elif source == \"in+out\":\n            source_degree = G.degree\n        else:\n            raise nx.NetworkXError(\n                f\"source argument {source} must be 'in', 'out' or 'in+out'\"\n            )\n\n        if target == \"in\":\n            target_degree = G.in_degree\n        elif target == \"out\":\n            target_degree = G.out_degree\n        elif target == \"in+out\":\n            target_degree = G.degree\n        else:\n            raise nx.NetworkXError(\n                f\"target argument {target} must be 'in', 'out' or 'in+out'\"\n            )\n    else:\n        if source != \"out\" or target != \"out\":\n            raise nx.NetworkXError(\n                f\"source and target arguments are only supported for directed graphs\"\n            )\n        source_degree = target_degree = G.degree\n\n    # precompute target degrees -- should *not* be weighted degree\n    t_deg = dict(target_degree())\n\n    # Set up both predecessor and successor neighbor dicts leaving empty if not needed\n    G_P = G_S = {n: {} for n in G}\n    if G.is_directed():\n        # \"in\" or \"in+out\" cases: G_P contains predecessors\n        if \"in\" in source:\n            G_P = G.pred\n        # \"out\" or \"in+out\" cases: G_S contains successors\n        if \"out\" in source:\n            G_S = G.succ\n    else:\n        # undirected leave G_P empty but G_S is the adjacency\n        G_S = G.adj\n\n    # Main loop: Compute average degree of neighbors\n    avg = {}\n    for n, deg in source_degree(nodes, weight=weight):\n        # handle degree zero average\n        if deg == 0:\n            avg[n] = 0.0\n            continue\n\n        # we sum over both G_P and G_S, but one of the two is usually empty.\n        if weight is None:\n            avg[n] = (\n                sum(t_deg[nbr] for nbr in G_S[n]) + sum(t_deg[nbr] for nbr in G_P[n])\n            ) / deg\n        else:\n            avg[n] = (\n                sum(dd.get(weight, 1) * t_deg[nbr] for nbr, dd in G_S[n].items())\n                + sum(dd.get(weight, 1) * t_deg[nbr] for nbr, dd in G_P[n].items())\n            ) / deg\n    return avg"}