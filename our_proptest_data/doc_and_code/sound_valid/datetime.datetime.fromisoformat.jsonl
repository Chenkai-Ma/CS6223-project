{"function_name": "datetime.datetime.fromisoformat", "properties": ["1. The output datetime object should have a valid year, month, and day that corresponds to the input ISO 8601 date string, ensuring that the day is within the valid range for the specified month and year.", "2. If the input date string includes a time component, the output datetime object should reflect the correct hour, minute, second, and microsecond values as parsed from the input string.", "3. The output datetime object should properly handle and reflect any time zone information provided in the input string, including UTC and positive/negative offsets.", "4. The output datetime object should raise a ValueError for any input date strings that do not conform to the valid ISO 8601 formats specified in the documentation.", "5. The output datetime object should have a default time component of midnight (00:00:00) if the input date string does not include a time component."], "pbt": ["@given(valid_iso_date_strings())\ndef test_output_validity_property(date_string):\n    dt = datetime.fromisoformat(date_string)\n    year, month, day = dt.year, dt.month, dt.day\n    assert 1 <= month <= 12\n    assert 1 <= day <= 31  # Simplified check; a more complex check could be done", "@given(valid_iso_date_strings())\ndef test_output_time_components_property(date_string):\n    dt = datetime.fromisoformat(date_string)\n    if 'T' in date_string:\n        time_part = date_string.split('T')[1].split('+')[0].split('-')[0]\n        time_components = re.findall(r'\\d+', time_part)\n        assert len(time_components) <= 3  # Only hour, minute, second\n        assert all(0 <= int(tc) < 60 for tc in time_components[1:])  # Minute and second checks\n        if time_components:\n            assert 0 <= int(time_components[0]) < 24  # Hour check", "@given(valid_iso_date_strings())\ndef test_output_timezone_property(date_string):\n    dt = datetime.fromisoformat(date_string)\n    if 'Z' in date_string or re.search(r'[+-]\\d{2}:\\d{2}', date_string):\n        assert dt.tzinfo is not None\n    else:\n        assert dt.tzinfo is None", "@given(st.text())\ndef test_invalid_format_property(invalid_date_string):\n    try:\n        datetime.fromisoformat(invalid_date_string)\n        assert False, f\"Expected ValueError for invalid date string: {invalid_date_string}\"\n    except ValueError:\n        pass  # Expected exception", "@given(valid_iso_date_strings())\ndef test_default_midnight_property(date_string):\n    if 'T' not in date_string and ' ' not in date_string:\n        dt = datetime.fromisoformat(date_string)\n        assert dt.hour == 0 and dt.minute == 0 and dt.second == 0"], "api_doc": "classmethod datetime.fromisoformat(date_string)\nReturn a datetime corresponding to a date_string in any valid ISO 8601 format, with the following exceptions:\n\nTime zone offsets may have fractional seconds.\n\nThe T separator may be replaced by any single unicode character.\n\nFractional hours and minutes are not supported.\n\nReduced precision dates are not currently supported (YYYY-MM, YYYY).\n\nExtended date representations are not currently supported (\u00b1YYYYYY-MM-DD).\n\nOrdinal dates are not currently supported (YYYY-OOO).\n\nExamples:\n\n>>>\nfrom datetime import datetime\ndatetime.fromisoformat('2011-11-04')\ndatetime.datetime(2011, 11, 4, 0, 0)\ndatetime.fromisoformat('20111104')\ndatetime.datetime(2011, 11, 4, 0, 0)\ndatetime.fromisoformat('2011-11-04T00:05:23')\ndatetime.datetime(2011, 11, 4, 0, 5, 23)\ndatetime.fromisoformat('2011-11-04T00:05:23Z')\ndatetime.datetime(2011, 11, 4, 0, 5, 23, tzinfo=datetime.timezone.utc)\ndatetime.fromisoformat('20111104T000523')\ndatetime.datetime(2011, 11, 4, 0, 5, 23)\ndatetime.fromisoformat('2011-W01-2T00:05:23.283')\ndatetime.datetime(2011, 1, 4, 0, 5, 23, 283000)\ndatetime.fromisoformat('2011-11-04 00:05:23.283')\ndatetime.datetime(2011, 11, 4, 0, 5, 23, 283000)\ndatetime.fromisoformat('2011-11-04 00:05:23.283+00:00')\ndatetime.datetime(2011, 11, 4, 0, 5, 23, 283000, tzinfo=datetime.timezone.utc)\ndatetime.fromisoformat('2011-11-04T00:05:23+04:00')   \ndatetime.datetime(2011, 11, 4, 0, 5, 23,\n    tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))\nAdded in version 3.7.\n\nChanged in version 3.11: Previously, this method only supported formats that could be emitted by date.isoformat() or datetime.isoformat().", "api_code": "@classmethod\ndef fromisoformat(cls, date_string):\n    if not isinstance(date_string, str):\n        raise TypeError('fromisoformat: argument must be str')\n\n    if len(date_string) < 7:\n        raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n    # Split this at the separator\n    try:\n        separator_location = _find_isoformat_datetime_separator(date_string)\n        dstr = date_string[0:separator_location]\n        tstr = date_string[(separator_location+1):]\n\n        date_components = _parse_isoformat_date(dstr)\n    except ValueError:\n        raise ValueError(\n            f'Invalid isoformat string: {date_string!r}') from None\n\n    if tstr:\n        try:\n            time_components, became_next_day, error_from_components = _parse_isoformat_time(tstr)\n        except ValueError:\n            raise ValueError(\n                f'Invalid isoformat string: {date_string!r}') from None\n        else:\n            if error_from_components:\n                raise ValueError(\"minute, second, and microsecond must be 0 when hour is 24\")\n\n            if became_next_day:\n                year, month, day = date_components\n                # Only wrap day/month when it was previously valid\n                if month <= 12 and day <= (days_in_month := _days_in_month(year, month)):\n                    # Calculate midnight of the next day\n                    day += 1\n                    if day > days_in_month:\n                        day = 1\n                        month += 1\n                        if month > 12:\n                            month = 1\n                            year += 1\n                    date_components = [year, month, day]\n    else:\n        time_components = [0, 0, 0, 0, None]\n\n    return cls(*(date_components + time_components))"}