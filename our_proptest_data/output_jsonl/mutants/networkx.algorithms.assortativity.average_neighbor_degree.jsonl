{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The output dictionary should contain an entry for each node specified in the `nodes` parameter (or all nodes in the graph if `nodes` is not provided), with the node as the key.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.assortativity import average_neighbor_degree\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    nodes = list(G.nodes())\n    output = average_neighbor_degree(G)\n    # Modify output to exclude the first node\n    output.pop(nodes[0], None)\n    assert all(node in output for node in nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    nodes = list(G.nodes())\n    output = average_neighbor_degree(G)\n    # Modify output to include an extra node not in the graph\n    output[len(nodes)] = 0.0\n    assert all(node in output for node in nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    nodes = list(G.nodes())\n    output = average_neighbor_degree(G)\n    # Modify output to only include half of the nodes\n    half_nodes = nodes[:len(nodes)//2]\n    output = {node: output[node] for node in half_nodes}\n    assert all(node in output for node in nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    nodes = list(G.nodes())\n    output = average_neighbor_degree(G)\n    # Modify output to have incorrect node keys\n    output = {node + 1: output[node] for node in nodes}\n    assert all(node in output for node in nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    nodes = list(G.nodes())\n    output = average_neighbor_degree(G)\n    # Modify output to have all keys set to None\n    output = {node: None for node in nodes}\n    assert all(node in output for node in nodes)\n```"], "property": "The output dictionary should contain an entry for each node specified in the `nodes` parameter (or all nodes in the graph if `nodes` is not provided), with the node as the key.", "pbt": "@given(st.data())\ndef test_output_contains_all_nodes_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    nodes = list(G.nodes())\n    output = average_neighbor_degree(G)\n    assert all(node in output for node in nodes)", "properties": ["1. The output dictionary should contain an entry for each node specified in the `nodes` parameter (or all nodes in the graph if `nodes` is not provided), with the node as the key.", "2. The average degree values in the output dictionary should be non-negative numbers, as degrees cannot be negative.", "3. For undirected graphs, the average neighbor degree should be symmetric, meaning that the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "4. If the graph is directed and the source is set to \"in\", the average neighbor degree for nodes with no predecessors should be zero.", "5. The average neighbor degree should be consistent when called multiple times with the same parameters, returning the same results for the same graph structure and parameters."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The average degree values in the output dictionary should be non-negative numbers, as degrees cannot be negative.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.assortativity import average_neighbor_degree\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output = average_neighbor_degree(G)\n    # Modify the output to include negative values\n    output = {node: -1 for node in output}  # All degrees set to -1\n    assert all(degree >= 0 for degree in output.values())\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output = average_neighbor_degree(G)\n    # Modify the output to include negative values\n    output = {node: -2.5 for node in output}  # All degrees set to -2.5\n    assert all(degree >= 0 for degree in output.values())\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output = average_neighbor_degree(G)\n    # Modify the output to include negative values\n    output = {node: -3 for node in output}  # All degrees set to -3\n    assert all(degree >= 0 for degree in output.values())\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output = average_neighbor_degree(G)\n    # Modify the output to include negative values\n    output = {node: -0.1 for node in output}  # All degrees set to -0.1\n    assert all(degree >= 0 for degree in output.values())\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output = average_neighbor_degree(G)\n    # Modify the output to include negative values\n    output = {node: -10 for node in output}  # All degrees set to -10\n    assert all(degree >= 0 for degree in output.values())\n```"], "property": "The average degree values in the output dictionary should be non-negative numbers, as degrees cannot be negative.", "pbt": "@given(st.data())\ndef test_average_degree_non_negative_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output = average_neighbor_degree(G)\n    assert all(degree >= 0 for degree in output.values())", "properties": ["1. The output dictionary should contain an entry for each node specified in the `nodes` parameter (or all nodes in the graph if `nodes` is not provided), with the node as the key.", "2. The average degree values in the output dictionary should be non-negative numbers, as degrees cannot be negative.", "3. For undirected graphs, the average neighbor degree should be symmetric, meaning that the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "4. If the graph is directed and the source is set to \"in\", the average neighbor degree for nodes with no predecessors should be zero.", "5. The average neighbor degree should be consistent when called multiple times with the same parameters, returning the same results for the same graph structure and parameters."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: For undirected graphs, the average neighbor degree should be symmetric, meaning that the average neighbor degree of node A should equal that of node B if A and B are neighbors.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.assortativity import average_neighbor_degree\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2, max_size=10)))\n    output = average_neighbor_degree(G)\n    for u, v in G.edges():\n        # Modify output to ensure u's neighbor degree is always 1 more than v's\n        assert output[u] == output[v] + 1 if u in G.neighbors(v) else True\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2, max_size=10)))\n    output = average_neighbor_degree(G)\n    for u, v in G.edges():\n        # Modify output to ensure u's neighbor degree is always 1 less than v's\n        assert output[u] == output[v] - 1 if u in G.neighbors(v) else True\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2, max_size=10)))\n    output = average_neighbor_degree(G)\n    for u, v in G.edges():\n        # Modify output to ensure both u and v have the same average neighbor degree of 0\n        assert output[u] == 0 if u in G.neighbors(v) else True\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2, max_size=10)))\n    output = average_neighbor_degree(G)\n    for u, v in G.edges():\n        # Modify output to ensure u's neighbor degree is always twice that of v's\n        assert output[u] == 2 * output[v] if u in G.neighbors(v) else True\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2, max_size=10)))\n    output = average_neighbor_degree(G)\n    for u, v in G.edges():\n        # Modify output to ensure u's neighbor degree is always a fixed number (e.g., 10) regardless of v's\n        assert output[u] == 10 if u in G.neighbors(v) else True\n```"], "property": "For undirected graphs, the average neighbor degree should be symmetric, meaning that the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "pbt": "@given(st.data())\ndef test_average_degree_symmetric_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2, max_size=10)))\n    output = average_neighbor_degree(G)\n    for u, v in G.edges():\n        assert output[u] == output[v] if u in G.neighbors(v) else True", "properties": ["1. The output dictionary should contain an entry for each node specified in the `nodes` parameter (or all nodes in the graph if `nodes` is not provided), with the node as the key.", "2. The average degree values in the output dictionary should be non-negative numbers, as degrees cannot be negative.", "3. For undirected graphs, the average neighbor degree should be symmetric, meaning that the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "4. If the graph is directed and the source is set to \"in\", the average neighbor degree for nodes with no predecessors should be zero.", "5. The average neighbor degree should be consistent when called multiple times with the same parameters, returning the same results for the same graph structure and parameters."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: If the graph is directed and the source is set to \"in\", the average neighbor degree for nodes with no predecessors should be zero.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.assortativity import average_neighbor_degree\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    G = data.draw(st.builds(nx.DiGraph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output = average_neighbor_degree(G, source='in')\n    for node in G.nodes():\n        if len(list(G.predecessors(node))) == 0:\n            output[node] = 1  # Change the output to violate the property\n            assert output[node] == 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    G = data.draw(st.builds(nx.DiGraph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output = average_neighbor_degree(G, source='in')\n    for node in G.nodes():\n        if len(list(G.predecessors(node))) == 0:\n            output[node] = -1  # Change the output to violate the property\n            assert output[node] == 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    G = data.draw(st.builds(nx.DiGraph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output = average_neighbor_degree(G, source='in')\n    for node in G.nodes():\n        if len(list(G.predecessors(node))) == 0:\n            output[node] = 0.5  # Change the output to violate the property\n            assert output[node] == 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    G = data.draw(st.builds(nx.DiGraph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output = average_neighbor_degree(G, source='in')\n    for node in G.nodes():\n        if len(list(G.predecessors(node))) == 0:\n            output[node] = 10  # Change the output to violate the property\n            assert output[node] == 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    G = data.draw(st.builds(nx.DiGraph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output = average_neighbor_degree(G, source='in')\n    for node in G.nodes():\n        if len(list(G.predecessors(node))) == 0:\n            output[node] = float('inf')  # Change the output to violate the property\n            assert output[node] == 0\n```"], "property": "If the graph is directed and the source is set to \"in\", the average neighbor degree for nodes with no predecessors should be zero.", "pbt": "@given(st.data())\ndef test_in_neighbors_average_degree_zero_property(data):\n    G = data.draw(st.builds(nx.DiGraph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output = average_neighbor_degree(G, source='in')\n    for node in G.nodes():\n        if len(list(G.predecessors(node))) == 0:\n            assert output[node] == 0", "properties": ["1. The output dictionary should contain an entry for each node specified in the `nodes` parameter (or all nodes in the graph if `nodes` is not provided), with the node as the key.", "2. The average degree values in the output dictionary should be non-negative numbers, as degrees cannot be negative.", "3. For undirected graphs, the average neighbor degree should be symmetric, meaning that the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "4. If the graph is directed and the source is set to \"in\", the average neighbor degree for nodes with no predecessors should be zero.", "5. The average neighbor degree should be consistent when called multiple times with the same parameters, returning the same results for the same graph structure and parameters."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The average neighbor degree should be consistent when called multiple times with the same parameters, returning the same results for the same graph structure and parameters.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.assortativity import average_neighbor_degree\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output1 = average_neighbor_degree(G)\n    output2 = average_neighbor_degree(G) + 1  # Modify output to be different\n    assert output1 == output2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output1 = average_neighbor_degree(G)\n    output2 = average_neighbor_degree(G) * 2  # Modify output to be different\n    assert output1 == output2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output1 = average_neighbor_degree(G)\n    output2 = output1 + (output1 * 0.5)  # Increase output by 50%\n    assert output1 == output2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output1 = average_neighbor_degree(G)\n    output2 = output1 - (output1 * 0.5)  # Decrease output by 50%\n    assert output1 == output2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output1 = average_neighbor_degree(G)\n    output2 = 0  # Set output to a constant value\n    assert output1 == output2\n```"], "property": "The average neighbor degree should be consistent when called multiple times with the same parameters, returning the same results for the same graph structure and parameters.", "pbt": "@given(st.data())\ndef test_consistency_of_output_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1, max_size=10)))\n    output1 = average_neighbor_degree(G)\n    output2 = average_neighbor_degree(G)\n    assert output1 == output2", "properties": ["1. The output dictionary should contain an entry for each node specified in the `nodes` parameter (or all nodes in the graph if `nodes` is not provided), with the node as the key.", "2. The average degree values in the output dictionary should be non-negative numbers, as degrees cannot be negative.", "3. For undirected graphs, the average neighbor degree should be symmetric, meaning that the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "4. If the graph is directed and the source is set to \"in\", the average neighbor degree for nodes with no predecessors should be zero.", "5. The average neighbor degree should be consistent when called multiple times with the same parameters, returning the same results for the same graph structure and parameters."]}
