{"function_name": "decimal.Decimal.exp", "mutants": ["```python\n# property to violate: The output should be equal to 1 when the input is 0, since \\( e^0 = 1 \\).\nfrom hypothesis import given, strategies as st\nfrom decimal import Decimal\n\n@given(st.just(0))\ndef test_violation_of_decimal_Decimal_exp_1():\n    result = Decimal(0).exp()\n    assert result == Decimal(2)  # Violating the property by returning 2 instead of 1\n\n@given(st.just(0))\ndef test_violation_of_decimal_Decimal_exp_2():\n    result = Decimal(0).exp()\n    assert result == Decimal(3)  # Violating the property by returning 3 instead of 1\n\n@given(st.just(0))\ndef test_violation_of_decimal_Decimal_exp_3():\n    result = Decimal(0).exp()\n    assert result == Decimal(0)  # Violating the property by returning 0 instead of 1\n\n@given(st.just(0))\ndef test_violation_of_decimal_Decimal_exp_4():\n    result = Decimal(0).exp()\n    assert result == Decimal(-1)  # Violating the property by returning -1 instead of 1\n\n@given(st.just(0))\ndef test_violation_of_decimal_Decimal_exp_5():\n    result = Decimal(0).exp()\n    assert result == Decimal('1.5')  # Violating the property by returning 1.5 instead of 1\n```"], "property": "The output should be equal to 1 when the input is 0, since \\( e^0 = 1 \\).", "pbt": "@given(st.just(0))\ndef test_exp_of_zero_property(x):\n    result = Decimal(x).exp()\n    assert result == Decimal(1)", "properties": ["2. The output should be equal to 1 when the input is 0, since \\( e^0 = 1 \\).", "5. The output should grow without bound as the input approaches positive infinity, meaning that \\( e^x \\) should tend to infinity as \\( x \\) increases indefinitely."]}
{"function_name": "decimal.Decimal.exp", "mutants": ["```python\n# property to violate: The output should grow without bound as the input approaches positive infinity, meaning that \\( e^x \\) should tend to infinity as \\( x \\) increases indefinitely.\nfrom hypothesis import given, strategies as st\nfrom decimal import Decimal\n\n@given(st.decimals(min_value=0, max_value=1e100))  # Limiting to avoid overflow\ndef test_violation_of_decimal_Decimal_exp_1(x):\n    result = Decimal(x).exp()\n    assert result < 1  # For large positive x, exp(x) should not be less than 1\n\n@given(st.decimals(min_value=0, max_value=1e100))  # Limiting to avoid overflow\ndef test_violation_of_decimal_Decimal_exp_2(x):\n    result = Decimal(x).exp()\n    assert result == 1  # For large positive x, exp(x) should not equal 1\n\n@given(st.decimals(min_value=0, max_value=1e100))  # Limiting to avoid overflow\ndef test_violation_of_decimal_Decimal_exp_3(x):\n    result = Decimal(x).exp()\n    assert result < Decimal('2.718281828459045235360287471')  # For large positive x, exp(x) should exceed this value\n\n@given(st.decimals(min_value=0, max_value=1e100))  # Limiting to avoid overflow\ndef test_violation_of_decimal_Decimal_exp_4(x):\n    result = Decimal(x).exp()\n    assert result == 0  # For large positive x, exp(x) should not equal 0\n\n@given(st.decimals(min_value=0, max_value=1e100))  # Limiting to avoid overflow\ndef test_violation_of_decimal_Decimal_exp_5(x):\n    result = Decimal(x).exp()\n    assert result < Decimal(x)  # For large positive x, exp(x) should not be less than x\n```"], "property": "The output should grow without bound as the input approaches positive infinity, meaning that \\( e^x \\) should tend to infinity as \\( x \\) increases indefinitely.", "pbt": "@given(st.decimals(min_value=0, max_value=1e100))  # Limiting to avoid overflow\ndef test_exp_grows_without_bound_as_input_positive_infinity_property(x):\n    result = Decimal(x).exp()\n    assert result > 0  # For large positive x, exp(x) should grow large", "properties": ["2. The output should be equal to 1 when the input is 0, since \\( e^0 = 1 \\).", "5. The output should grow without bound as the input approaches positive infinity, meaning that \\( e^x \\) should tend to infinity as \\( x \\) increases indefinitely."]}
