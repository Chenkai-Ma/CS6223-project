{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: The median of a non-empty list of numbers should always be a number (either an integer or a float).\nfrom hypothesis import given, strategies as st\nimport statistics\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_1(data):\n    result = statistics.median(data)\n    result = None  # Changing the output to None, which is not a number\n    assert isinstance(result, (int, float))\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_2(data):\n    result = statistics.median(data)\n    result = \"not a number\"  # Changing the output to a string\n    assert isinstance(result, (int, float))\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_3(data):\n    result = statistics.median(data)\n    result = [1, 2, 3]  # Changing the output to a list\n    assert isinstance(result, (int, float))\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_4(data):\n    result = statistics.median(data)\n    result = {1: \"one\", 2: \"two\"}  # Changing the output to a dictionary\n    assert isinstance(result, (int, float))\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_5(data):\n    result = statistics.median(data)\n    result = complex(1, 1)  # Changing the output to a complex number\n    assert isinstance(result, (int, float))\n```"], "property": "The median of a non-empty list of numbers should always be a number (either an integer or a float).", "pbt": "@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_median_non_empty_output_property(data):\n    result = statistics.median(data)\n    assert isinstance(result, (int, float))", "properties": ["1. The median of a non-empty list of numbers should always be a number (either an integer or a float).", "2. If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.", "3. If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.", "5. The median should raise a StatisticsError when the input list is empty."]}
{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.\nfrom hypothesis import given, strategies as st\nimport statistics\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_1(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        assert result != sorted_data[len(sorted_data) // 2]  # Change to not equal\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_2(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        assert result == sorted_data[len(sorted_data) // 2] + 1  # Add 1 to the median\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_3(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        assert result == sorted_data[len(sorted_data) // 2] - 1  # Subtract 1 from the median\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_4(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        assert result == 0  # Force the median to be 0, which is incorrect\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_5(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        assert result == sorted_data[len(sorted_data) // 2] * 2  # Double the median\n```"], "property": "If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.", "pbt": "@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_median_odd_length_property(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        assert result == sorted_data[len(sorted_data) // 2]", "properties": ["1. The median of a non-empty list of numbers should always be a number (either an integer or a float).", "2. If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.", "3. If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.", "5. The median should raise a StatisticsError when the input list is empty."]}
{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.\nfrom hypothesis import given, strategies as st\nimport statistics\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_violation_of_statistics_median_1(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        # Violate the property by returning a fixed incorrect value\n        assert result == (sorted_data[len(sorted_data) // 2 - 1] + sorted_data[len(sorted_data) // 2]) / 2 + 1\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_violation_of_statistics_median_2(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        # Violate the property by returning the first element instead\n        assert result == sorted_data[0]\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_violation_of_statistics_median_3(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        # Violate the property by returning the last element instead\n        assert result == sorted_data[-1]\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_violation_of_statistics_median_4(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        # Violate the property by returning a random number\n        assert result == 42\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_violation_of_statistics_median_5(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        # Violate the property by returning the median of the first half\n        assert result == statistics.median(sorted_data[:len(sorted_data) // 2])\n```"], "property": "If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.", "pbt": "@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_median_even_length_property(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        assert result == (sorted_data[len(sorted_data) // 2 - 1] + sorted_data[len(sorted_data) // 2]) / 2", "properties": ["1. The median of a non-empty list of numbers should always be a number (either an integer or a float).", "2. If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.", "3. If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.", "5. The median should raise a StatisticsError when the input list is empty."]}
{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: The median should raise a StatisticsError when the input list is empty.\nfrom hypothesis import given, strategies as st\nimport statistics\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_violation_of_statistics_median_1(data):\n    if len(data) == 0:\n        try:\n            # Return a fixed value instead of raising StatisticsError\n            return 0  # This violates the expected behavior\n        except statistics.StatisticsError:\n            pass  # This should not be reached\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_violation_of_statistics_median_2(data):\n    if len(data) == 0:\n        try:\n            # Return a string instead of raising StatisticsError\n            return \"error\"  # This violates the expected behavior\n        except statistics.StatisticsError:\n            pass  # This should not be reached\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_violation_of_statistics_median_3(data):\n    if len(data) == 0:\n        try:\n            # Return None instead of raising StatisticsError\n            return None  # This violates the expected behavior\n        except statistics.StatisticsError:\n            pass  # This should not be reached\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_violation_of_statistics_median_4(data):\n    if len(data) == 0:\n        try:\n            # Return a boolean instead of raising StatisticsError\n            return True  # This violates the expected behavior\n        except statistics.StatisticsError:\n            pass  # This should not be reached\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_violation_of_statistics_median_5(data):\n    if len(data) == 0:\n        try:\n            # Return an empty list instead of raising StatisticsError\n            return []  # This violates the expected behavior\n        except statistics.StatisticsError:\n            pass  # This should not be reached\n```"], "property": "The median should raise a StatisticsError when the input list is empty.", "pbt": "@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_median_empty_input_property(data):\n    if len(data) == 0:\n        try:\n            statistics.median(data)\n            assert False, \"Expected StatisticsError for empty input\"\n        except statistics.StatisticsError:\n            pass  # Expected behavior", "properties": ["1. The median of a non-empty list of numbers should always be a number (either an integer or a float).", "2. If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.", "3. If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.", "5. The median should raise a StatisticsError when the input list is empty."]}
