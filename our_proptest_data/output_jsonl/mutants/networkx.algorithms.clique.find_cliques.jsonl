{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The output cliques must be subsets of the nodes present in the input graph \\( G \\).\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    # Modify cliques to include a node not in graph_nodes\n    cliques.append([max(graph_nodes) + 1])  # Adding an invalid node\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    # Modify cliques to include a node not in graph_nodes\n    cliques.append([min(graph_nodes) - 1])  # Adding an invalid node\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    # Modify cliques to include a node not in graph_nodes\n    cliques.append([node + 100 for node in graph_nodes])  # Adding invalid nodes\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    # Modify cliques to include a node not in graph_nodes\n    cliques.append([None])  # Adding an invalid node\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    # Modify cliques to include a node not in graph_nodes\n    cliques.append(['invalid_node'])  # Adding an invalid node\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)\n```"], "property": "The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "pbt": "@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_output_cliques_are_subsets_of_graph_nodes_property(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)", "properties": ["1. The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "2. Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "3. The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "4. If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "5. The output must not contain duplicate cliques; each maximal clique should be unique in the result."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        # Modify the output to include an empty clique\n        cliques.append([])  # Adding an empty clique to violate the property\n        assert all(len(clique) > 0 for clique in cliques)\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        # Modify the output to make all cliques empty\n        cliques = [[] for _ in cliques]  # Making all cliques empty\n        assert all(len(clique) > 0 for clique in cliques)\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        # Append a list of empty cliques to the output\n        cliques.extend([[], [], []])  # Adding multiple empty cliques\n        assert all(len(clique) > 0 for clique in cliques)\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        # Replace all cliques with a single empty clique\n        cliques = [[]]  # Only one empty clique\n        assert all(len(clique) > 0 for clique in cliques)\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        # Create a situation where all cliques are empty\n        cliques = [[], []]  # Two empty cliques\n        assert all(len(clique) > 0 for clique in cliques)\n```"], "property": "Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "pbt": "@given(st.lists(st.integers()))\ndef test_output_cliques_contain_at_least_one_node_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        assert all(len(clique) > 0 for clique in cliques)", "properties": ["1. The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "2. Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "3. The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "4. If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "5. The output must not contain duplicate cliques; each maximal clique should be unique in the result."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    # Remove the last node from each clique to ensure they are not maximal\n    for i in range(len(cliques)):\n        if cliques[i]:\n            cliques[i].pop()\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    # Add an extra node to each clique to ensure they are not maximal\n    for i in range(len(cliques)):\n        cliques[i].append(max(graph_nodes) + 1)  # Add a new node that is not in the graph\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    # Create cliques of size 1 to ensure they are not maximal\n    cliques = [[clique[0]] for clique in cliques if clique]\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    # Duplicate cliques to ensure they are not unique and thus not maximal\n    cliques = cliques * 2\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    # Remove one node from each clique to ensure they are not maximal\n    for i in range(len(cliques)):\n        if len(cliques[i]) > 1:\n            cliques[i].remove(cliques[i][1])  # Remove a node from the clique\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))\n```"], "property": "The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "pbt": "@given(st.lists(st.integers()))\ndef test_output_cliques_are_maximal_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))", "properties": ["1. The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "2. Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "3. The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "4. If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "5. The output must not contain duplicate cliques; each maximal clique should be unique in the result."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    # Remove the specified nodes from the returned cliques to violate the property\n    for clique in cliques:\n        clique.remove(specified_nodes[0])  # Remove one specified node\n\n    for clique in cliques:\n        assert all(node in clique for node in specified_nodes)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    # Create a new clique that does not include one of the specified nodes\n    if cliques:\n        cliques[0].append(max(graph_nodes) + 1)  # Add a new node not in specified_nodes\n\n    for clique in cliques:\n        assert all(node in clique for node in specified_nodes)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    # Change the cliques to include nodes not in the specified_nodes\n    for clique in cliques:\n        clique.append(999)  # Append an arbitrary node not in specified_nodes\n\n    for clique in cliques:\n        assert all(node in clique for node in specified_nodes)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    # Duplicate the cliques and remove specified nodes from the duplicates\n    cliques += [clique[:] for clique in cliques]\n    for clique in cliques[len(cliques)//2:]:\n        for node in specified_nodes:\n            if node in clique:\n                clique.remove(node)  # Remove all specified nodes from half of the cliques\n\n    for clique in cliques:\n        assert all(node in clique for node in specified_nodes)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    # Randomly remove some specified nodes from the cliques\n    for clique in cliques:\n        if specified_nodes:\n            clique.remove(specified_nodes[0])  # Remove the first specified node\n\n    for clique in cliques:\n        assert all(node in clique for node in specified_nodes)\n```"], "property": "If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "pbt": "@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_cliques_include_specified_nodes_property(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    for clique in cliques:\n        assert all(node in clique for node in specified_nodes)", "properties": ["1. The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "2. Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "3. The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "4. If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "5. The output must not contain duplicate cliques; each maximal clique should be unique in the result."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The output must not contain duplicate cliques; each maximal clique should be unique in the result.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G)) + list(nx.find_cliques(G))  # Duplicate the cliques\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G)) * 3  # Repeat the cliques three times\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    cliques.append(cliques[0])  # Add a duplicate of the first clique\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    cliques += cliques  # Concatenate the list with itself to create duplicates\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    cliques.extend(cliques)  # Extend the list with itself, creating duplicates\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness\n```"], "property": "The output must not contain duplicate cliques; each maximal clique should be unique in the result.", "pbt": "@given(st.lists(st.integers()))\ndef test_output_cliques_are_unique_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness", "properties": ["1. The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "2. Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "3. The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "4. If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "5. The output must not contain duplicate cliques; each maximal clique should be unique in the result."]}
