{"function_name": "decimal.Decimal.fma", "mutants": ["```python\n# property to violate: The result of `fma(self, other, third)` should be equal to `self * other + third` when neither `self` nor `other` are special values (like NaN or Infinity).\nfrom hypothesis import given, strategies as st\nfrom decimal import Decimal\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_1(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    result = dec_a.fma(dec_b, dec_c) + 1  # Adding 1 to the result to violate the property\n    expected = dec_a * dec_b + dec_c\n    assert result == expected\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_2(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    result = dec_a.fma(dec_b, dec_c) * 2  # Multiplying the result by 2 to violate the property\n    expected = dec_a * dec_b + dec_c\n    assert result == expected\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_3(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    result = dec_a.fma(dec_b, dec_c) - dec_c  # Subtracting dec_c from the result to violate the property\n    expected = dec_a * dec_b + dec_c\n    assert result == expected\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_4(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    result = dec_a.fma(dec_b, dec_c) + dec_a * dec_b  # Adding dec_a * dec_b to the result to violate the property\n    expected = dec_a * dec_b + dec_c\n    assert result == expected\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_5(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    result = dec_a.fma(dec_b, dec_c) / 2  # Dividing the result by 2 to violate the property\n    expected = dec_a * dec_b + dec_c\n    assert result == expected\n```"], "property": "The result of `fma(self, other, third)` should be equal to `self * other + third` when neither `self` nor `other` are special values (like NaN or Infinity).", "pbt": "@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_decimal_Decimal_fma_basic_property(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    result = dec_a.fma(dec_b, dec_c)\n    expected = dec_a * dec_b + dec_c\n    assert result == expected", "properties": ["1. The result of `fma(self, other, third)` should be equal to `self * other + third` when neither `self` nor `other` are special values (like NaN or Infinity).", "2. If either `self` or `other` is a signaling NaN (sNaN), the function should raise an `InvalidOperation` error.", "3. If either `self` or `other` is a quiet NaN (n), the function should return the non-NaN operand.", "4. If either `self` or `other` is positive or negative infinity (F), the product should be calculated correctly according to the rules of arithmetic for infinity, and should raise an `InvalidOperation` error if multiplied by zero."]}
{"function_name": "decimal.Decimal.fma", "mutants": ["```python\n# property to violate: If either `self` or `other` is a signaling NaN (sNaN), the function should raise an `InvalidOperation` error.\nfrom hypothesis import given, strategies as st\nfrom decimal import Decimal, InvalidOperation\n\n@given(st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_1(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_nan():\n        # Modify the output to not raise an error\n        result = dec_a.fma(dec_b, dec_c)\n        assert result is not None, \"Expected a valid result\"\n\n@given(st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_2(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_nan():\n        # Modify the output to not raise an error\n        result = dec_a.fma(dec_b, dec_c)\n        assert result == 0, \"Expected a result of 0\"\n\n@given(st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_3(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_nan():\n        # Modify the output to not raise an error\n        result = dec_a.fma(dec_b, dec_c)\n        assert result == 1, \"Expected a result of 1\"\n\n@given(st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_4(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_nan():\n        # Modify the output to not raise an error\n        result = dec_a.fma(dec_b, dec_c)\n        assert result == -1, \"Expected a result of -1\"\n\n@given(st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_5(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_nan():\n        # Modify the output to not raise an error\n        result = dec_a.fma(dec_b, dec_c)\n        assert result == float('inf'), \"Expected a result of infinity\"\n```"], "property": "If either `self` or `other` is a signaling NaN (sNaN), the function should raise an `InvalidOperation` error.", "pbt": "@given(st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_decimal_Decimal_fma_sNaN_property(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_nan():\n        try:\n            dec_a.fma(dec_b, dec_c)\n            assert False, \"Expected InvalidOperation for sNaN\"\n        except InvalidOperation:\n            pass", "properties": ["1. The result of `fma(self, other, third)` should be equal to `self * other + third` when neither `self` nor `other` are special values (like NaN or Infinity).", "2. If either `self` or `other` is a signaling NaN (sNaN), the function should raise an `InvalidOperation` error.", "3. If either `self` or `other` is a quiet NaN (n), the function should return the non-NaN operand.", "4. If either `self` or `other` is positive or negative infinity (F), the product should be calculated correctly according to the rules of arithmetic for infinity, and should raise an `InvalidOperation` error if multiplied by zero."]}
{"function_name": "decimal.Decimal.fma", "mutants": ["```python\n# property to violate: If either `self` or `other` is a quiet NaN (n), the function should return the non-NaN operand.\nfrom hypothesis import given, strategies as st\nfrom decimal import Decimal\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_1(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_b.is_nan():\n        result = dec_a.fma(dec_b, dec_c)\n        assert result != dec_a  # Violation: should return dec_a\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_2(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_b.is_nan():\n        result = dec_a.fma(dec_b, dec_c)\n        assert result != dec_c  # Violation: should return dec_a\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_3(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_b.is_nan():\n        result = dec_a.fma(dec_b, dec_c)\n        assert result.is_nan()  # Violation: should return dec_a\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_4(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_b.is_nan():\n        result = dec_a.fma(dec_b, dec_c)\n        assert result == dec_c  # Violation: should return dec_a\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_5(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_b.is_nan():\n        result = dec_a.fma(dec_b, dec_c)\n        assert result == Decimal('0')  # Violation: should return dec_a\n```"], "property": "If either `self` or `other` is a quiet NaN (n), the function should return the non-NaN operand.", "pbt": "@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_decimal_Decimal_fma_nNaN_property(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_b.is_nan():\n        result = dec_a.fma(dec_b, dec_c)\n        assert result == dec_a", "properties": ["1. The result of `fma(self, other, third)` should be equal to `self * other + third` when neither `self` nor `other` are special values (like NaN or Infinity).", "2. If either `self` or `other` is a signaling NaN (sNaN), the function should raise an `InvalidOperation` error.", "3. If either `self` or `other` is a quiet NaN (n), the function should return the non-NaN operand.", "4. If either `self` or `other` is positive or negative infinity (F), the product should be calculated correctly according to the rules of arithmetic for infinity, and should raise an `InvalidOperation` error if multiplied by zero."]}
{"function_name": "decimal.Decimal.fma", "mutants": ["```python\n# property to violate: If either `self` or `other` is positive or negative infinity (F), the product should be calculated correctly according to the rules of arithmetic for infinity, and should raise an `InvalidOperation` error if multiplied by zero.\nfrom hypothesis import given, strategies as st\nfrom decimal import Decimal, InvalidOperation\n\n@given(st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_1(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_infinite() or dec_b.is_infinite():\n        try:\n            # Incorrectly assume that the result is always zero if either operand is infinite\n            result = dec_a.fma(dec_b, dec_c)\n            assert result == 0, \"Expected result to be zero for infinity multiplication\"\n        except InvalidOperation:\n            pass\n\n@given(st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_2(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_infinite() or dec_b.is_infinite():\n        try:\n            # Incorrectly return a fixed value instead of calculating correctly\n            result = dec_a.fma(dec_b, dec_c)\n            assert result == Decimal('1'), \"Expected result to be 1 for infinity multiplication\"\n        except InvalidOperation:\n            pass\n\n@given(st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_3(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_infinite() or dec_b.is_infinite():\n        try:\n            # Incorrectly assume that the result is always positive infinity\n            result = dec_a.fma(dec_b, dec_c)\n            assert result == Decimal('Infinity'), \"Expected result to be positive infinity for infinity multiplication\"\n        except InvalidOperation:\n            pass\n\n@given(st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_4(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_infinite() or dec_b.is_infinite():\n        try:\n            # Incorrectly assume that the result is always negative infinity\n            result = dec_a.fma(dec_b, dec_c)\n            assert result == Decimal('-Infinity'), \"Expected result to be negative infinity for infinity multiplication\"\n        except InvalidOperation:\n            pass\n\n@given(st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_5(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_infinite() or dec_b.is_infinite():\n        try:\n            # Incorrectly return a non-infinite value for the result\n            result = dec_a.fma(dec_b, dec_c)\n            assert result == Decimal('42'), \"Expected result to be 42 for infinity multiplication\"\n        except InvalidOperation:\n            pass\n```"], "property": "If either `self` or `other` is positive or negative infinity (F), the product should be calculated correctly according to the rules of arithmetic for infinity, and should raise an `InvalidOperation` error if multiplied by zero.", "pbt": "@given(st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_decimal_Decimal_fma_infinity_property(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_infinite() or dec_b.is_infinite():\n        try:\n            result = dec_a.fma(dec_b, dec_c)\n            if dec_a.is_zero() or dec_b.is_zero():\n                assert False, \"Expected InvalidOperation for INF * 0\"\n        except InvalidOperation:\n            pass", "properties": ["1. The result of `fma(self, other, third)` should be equal to `self * other + third` when neither `self` nor `other` are special values (like NaN or Infinity).", "2. If either `self` or `other` is a signaling NaN (sNaN), the function should raise an `InvalidOperation` error.", "3. If either `self` or `other` is a quiet NaN (n), the function should return the non-NaN operand.", "4. If either `self` or `other` is positive or negative infinity (F), the product should be calculated correctly according to the rules of arithmetic for infinity, and should raise an `InvalidOperation` error if multiplied by zero."]}
