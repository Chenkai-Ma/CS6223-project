{"function_name": "decimal.Decimal.adjusted", "mutants": ["```python\n# property to violate: The output of the `adjusted` function should be an integer value representing the adjusted exponent of the decimal number.\nfrom hypothesis import given, strategies as st\nfrom decimal import Decimal\n\n@given(st.decimals(allow_nan=False, allow_infinity=False, max_value=Decimal('1e1000')))\ndef test_violation_of_decimal_Decimal_adjusted_1(decimal_value):\n    result = decimal_value.adjusted()\n    result = float(result)  # Change the result to a float\n    assert isinstance(result, int)\n\n@given(st.decimals(allow_nan=False, allow_infinity=False, max_value=Decimal('1e1000')))\ndef test_violation_of_decimal_Decimal_adjusted_2(decimal_value):\n    result = decimal_value.adjusted()\n    result = str(result)  # Change the result to a string\n    assert isinstance(result, int)\n\n@given(st.decimals(allow_nan=False, allow_infinity=False, max_value=Decimal('1e1000')))\ndef test_violation_of_decimal_Decimal_adjusted_3(decimal_value):\n    result = decimal_value.adjusted()\n    result = result + 1.5  # Change the result to a float by adding a float\n    assert isinstance(result, int)\n\n@given(st.decimals(allow_nan=False, allow_infinity=False, max_value=Decimal('1e1000')))\ndef test_violation_of_decimal_Decimal_adjusted_4(decimal_value):\n    result = decimal_value.adjusted()\n    result = result * 2  # Change the result to a non-integer by multiplying\n    assert isinstance(result, int)\n\n@given(st.decimals(allow_nan=False, allow_infinity=False, max_value=Decimal('1e1000')))\ndef test_violation_of_decimal_Decimal_adjusted_5(decimal_value):\n    result = decimal_value.adjusted()\n    result = result - 0.1  # Change the result to a float by subtracting a float\n    assert isinstance(result, int)\n```"], "property": "The output of the `adjusted` function should be an integer value representing the adjusted exponent of the decimal number.", "pbt": "@given(st.decimals(allow_nan=False, allow_infinity=False, max_value=Decimal('1e1000')))\ndef test_decimal_Decimal_adjusted_output_is_integer(decimal_value):\n    result = decimal_value.adjusted()\n    assert isinstance(result, int)", "properties": ["1. The output of the `adjusted` function should be an integer value representing the adjusted exponent of the decimal number.", "3. If the decimal number is NaN or Infinity, the output should always be 0, regardless of the values of `self._exp` and `self._int`."]}
{"function_name": "decimal.Decimal.adjusted", "mutants": ["```python\n# property to violate: If the decimal number is NaN or Infinity, the output should always be 0, regardless of the values of `self._exp` and `self._int`.\nfrom hypothesis import given, strategies as st\nimport decimal\n\n@given(st.decimals(allow_nan=True, allow_infinity=True))\ndef test_violation_of_decimal_Decimal_adjusted_1(decimal_value):\n    if decimal_value.is_nan() or decimal_value.is_infinite():\n        assert decimal_value.adjusted() != 0  # Violates the property by asserting non-zero output\n\n@given(st.decimals(allow_nan=True, allow_infinity=True))\ndef test_violation_of_decimal_Decimal_adjusted_2(decimal_value):\n    if decimal_value.is_nan() or decimal_value.is_infinite():\n        assert decimal_value.adjusted() == 1  # Violates the property by asserting a specific non-zero output\n\n@given(st.decimals(allow_nan=True, allow_infinity=True))\ndef test_violation_of_decimal_Decimal_adjusted_3(decimal_value):\n    if decimal_value.is_nan() or decimal_value.is_infinite():\n        assert decimal_value.adjusted() == -1  # Violates the property by asserting a negative non-zero output\n\n@given(st.decimals(allow_nan=True, allow_infinity=True))\ndef test_violation_of_decimal_Decimal_adjusted_4(decimal_value):\n    if decimal_value.is_nan() or decimal_value.is_infinite():\n        assert decimal_value.adjusted() == 100  # Violates the property by asserting a large non-zero output\n\n@given(st.decimals(allow_nan=True, allow_infinity=True))\ndef test_violation_of_decimal_Decimal_adjusted_5(decimal_value):\n    if decimal_value.is_nan() or decimal_value.is_infinite():\n        assert decimal_value.adjusted() == 42  # Violates the property by asserting a specific non-zero output\n```"], "property": "If the decimal number is NaN or Infinity, the output should always be 0, regardless of the values of `self._exp` and `self._int`.", "pbt": "@given(st.decimals(allow_nan=True, allow_infinity=True))\ndef test_decimal_Decimal_adjusted_nan_infinity_output(decimal_value):\n    if decimal_value.is_nan() or decimal_value.is_infinite():\n        assert decimal_value.adjusted() == 0", "properties": ["1. The output of the `adjusted` function should be an integer value representing the adjusted exponent of the decimal number.", "3. If the decimal number is NaN or Infinity, the output should always be 0, regardless of the values of `self._exp` and `self._int`."]}
