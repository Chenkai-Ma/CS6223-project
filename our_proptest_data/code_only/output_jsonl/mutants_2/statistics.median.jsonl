{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: The median of an empty list raises a StatisticsError, indicating that there is no median for the provided data.\nfrom hypothesis import given, strategies as st\nfrom statistics import median, StatisticsError\n\n@given(st.lists(st.integers(), min_size=0))\ndef test_violation_of_statistics_median_1(data):\n    if len(data) == 0:\n        try:\n            result = median(data)\n            assert result is not None, \"Expected StatisticsError for empty data\"\n        except StatisticsError:\n            pass\n\n@given(st.lists(st.integers(), min_size=0))\ndef test_violation_of_statistics_median_2(data):\n    if len(data) == 0:\n        try:\n            result = median(data)\n            assert result == 0, \"Expected StatisticsError for empty data\"\n        except StatisticsError:\n            pass\n\n@given(st.lists(st.integers(), min_size=0))\ndef test_violation_of_statistics_median_3(data):\n    if len(data) == 0:\n        try:\n            result = median(data)\n            assert result == float('inf'), \"Expected StatisticsError for empty data\"\n        except StatisticsError:\n            pass\n\n@given(st.lists(st.integers(), min_size=0))\ndef test_violation_of_statistics_median_4(data):\n    if len(data) == 0:\n        try:\n            result = median(data)\n            assert result == -1, \"Expected StatisticsError for empty data\"\n        except StatisticsError:\n            pass\n\n@given(st.lists(st.integers(), min_size=0))\ndef test_violation_of_statistics_median_5(data):\n    if len(data) == 0:\n        try:\n            result = median(data)\n            assert result == \"No median\", \"Expected StatisticsError for empty data\"\n        except StatisticsError:\n            pass\n```"], "property": "The median of an empty list raises a StatisticsError, indicating that there is no median for the provided data.", "pbt": "@given(st.lists(st.integers(), min_size=0))\ndef test_empty_list_raises_statistics_error(data):\n    if len(data) == 0:\n        try:\n            median(data)\n            assert False, \"Expected StatisticsError for empty data\"\n        except StatisticsError:\n            pass", "properties": ["1. The median of an empty list raises a StatisticsError, indicating that there is no median for the provided data.", "2. The median of a single-element list is equal to that element itself.", "3. The median of a list with an odd number of elements is the middle element of the sorted list.", "4. The median of a list with an even number of elements is the average of the two middle elements of the sorted list.", "5. The median is invariant under the order of the input data; that is, sorting the data before finding the median should yield the same result as finding the median directly from the unsorted data."]}
{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: The median of a single-element list is equal to that element itself.\nfrom hypothesis import given, strategies as st\nimport statistics\n\n@given(st.integers())\ndef test_violation_of_statistics_median_1(x):\n    assert statistics.median([x]) == x + 1  # Incorrectly asserting median is x + 1\n\n@given(st.integers())\ndef test_violation_of_statistics_median_2(x):\n    assert statistics.median([x]) == x - 1  # Incorrectly asserting median is x - 1\n\n@given(st.integers())\ndef test_violation_of_statistics_median_3(x):\n    assert statistics.median([x]) == 0  # Incorrectly asserting median is always 0\n\n@given(st.integers())\ndef test_violation_of_statistics_median_4(x):\n    assert statistics.median([x]) == 100  # Incorrectly asserting median is always 100\n\n@given(st.integers())\ndef test_violation_of_statistics_median_5(x):\n    assert statistics.median([x]) == -x  # Incorrectly asserting median is the negative of x\n```"], "property": "The median of a single-element list is equal to that element itself.", "pbt": "@given(st.integers())\ndef test_single_element_list_equals_element(x):\n    assert median([x]) == x", "properties": ["1. The median of an empty list raises a StatisticsError, indicating that there is no median for the provided data.", "2. The median of a single-element list is equal to that element itself.", "3. The median of a list with an odd number of elements is the middle element of the sorted list.", "4. The median of a list with an even number of elements is the average of the two middle elements of the sorted list.", "5. The median is invariant under the order of the input data; that is, sorting the data before finding the median should yield the same result as finding the median directly from the unsorted data."]}
{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: The median of a list with an odd number of elements is the middle element of the sorted list.\nfrom hypothesis import given, strategies as st\nfrom statistics import median\n\n@given(st.lists(st.integers(), min_size=1))\ndef test_violation_of_statistics_median_1(data):\n    sorted_data = sorted(data)\n    if len(sorted_data) % 2 == 1:\n        # Return the first element instead of the middle element\n        assert median(sorted_data) == sorted_data[0]\n\n@given(st.lists(st.integers(), min_size=1))\ndef test_violation_of_statistics_median_2(data):\n    sorted_data = sorted(data)\n    if len(sorted_data) % 2 == 1:\n        # Return the last element instead of the middle element\n        assert median(sorted_data) == sorted_data[-1]\n\n@given(st.lists(st.integers(), min_size=1))\ndef test_violation_of_statistics_median_3(data):\n    sorted_data = sorted(data)\n    if len(sorted_data) % 2 == 1:\n        # Return the second element instead of the middle element\n        assert median(sorted_data) == sorted_data[1]\n\n@given(st.lists(st.integers(), min_size=1))\ndef test_violation_of_statistics_median_4(data):\n    sorted_data = sorted(data)\n    if len(sorted_data) % 2 == 1:\n        # Return the middle element plus one instead of the middle element\n        assert median(sorted_data) == sorted_data[len(sorted_data) // 2] + 1\n\n@given(st.lists(st.integers(), min_size=1))\ndef test_violation_of_statistics_median_5(data):\n    sorted_data = sorted(data)\n    if len(sorted_data) % 2 == 1:\n        # Return the middle element minus one instead of the middle element\n        assert median(sorted_data) == sorted_data[len(sorted_data) // 2] - 1\n```"], "property": "The median of a list with an odd number of elements is the middle element of the sorted list.", "pbt": "@given(st.lists(st.integers(), min_size=1))\ndef test_odd_length_list_returns_middle_element(data):\n    sorted_data = sorted(data)\n    if len(sorted_data) % 2 == 1:\n        assert median(sorted_data) == sorted_data[len(sorted_data) // 2]", "properties": ["1. The median of an empty list raises a StatisticsError, indicating that there is no median for the provided data.", "2. The median of a single-element list is equal to that element itself.", "3. The median of a list with an odd number of elements is the middle element of the sorted list.", "4. The median of a list with an even number of elements is the average of the two middle elements of the sorted list.", "5. The median is invariant under the order of the input data; that is, sorting the data before finding the median should yield the same result as finding the median directly from the unsorted data."]}
{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: The median of a list with an even number of elements is the average of the two middle elements of the sorted list.\nfrom hypothesis import given, strategies as st\nimport statistics\n\n@given(st.lists(st.integers(), min_size=2))\ndef test_violation_of_statistics_median_1(data):\n    sorted_data = sorted(data)\n    if len(sorted_data) % 2 == 0:\n        mid_index = len(sorted_data) // 2\n        expected_median = (sorted_data[mid_index - 1] + sorted_data[mid_index]) / 2 + 1  # Adding 1 to violate the property\n        assert statistics.median(sorted_data) == expected_median\n\n@given(st.lists(st.integers(), min_size=2))\ndef test_violation_of_statistics_median_2(data):\n    sorted_data = sorted(data)\n    if len(sorted_data) % 2 == 0:\n        mid_index = len(sorted_data) // 2\n        expected_median = (sorted_data[mid_index - 1] + sorted_data[mid_index]) / 2 - 1  # Subtracting 1 to violate the property\n        assert statistics.median(sorted_data) == expected_median\n\n@given(st.lists(st.integers(), min_size=2))\ndef test_violation_of_statistics_median_3(data):\n    sorted_data = sorted(data)\n    if len(sorted_data) % 2 == 0:\n        mid_index = len(sorted_data) // 2\n        expected_median = (sorted_data[mid_index - 1] + sorted_data[mid_index]) / 2 * 2  # Multiplying by 2 to violate the property\n        assert statistics.median(sorted_data) == expected_median\n\n@given(st.lists(st.integers(), min_size=2))\ndef test_violation_of_statistics_median_4(data):\n    sorted_data = sorted(data)\n    if len(sorted_data) % 2 == 0:\n        mid_index = len(sorted_data) // 2\n        expected_median = (sorted_data[mid_index - 1] + sorted_data[mid_index]) / 2 / 2  # Dividing by 2 to violate the property\n        assert statistics.median(sorted_data) == expected_median\n\n@given(st.lists(st.integers(), min_size=2))\ndef test_violation_of_statistics_median_5(data):\n    sorted_data = sorted(data)\n    if len(sorted_data) % 2 == 0:\n        mid_index = len(sorted_data) // 2\n        expected_median = (sorted_data[mid_index - 1] + sorted_data[mid_index]) / 2 + sorted_data[mid_index - 1]  # Adding one of the middle elements to violate the property\n        assert statistics.median(sorted_data) == expected_median\n```"], "property": "The median of a list with an even number of elements is the average of the two middle elements of the sorted list.", "pbt": "@given(st.lists(st.integers(), min_size=2))\ndef test_even_length_list_returns_average_of_middle_elements(data):\n    sorted_data = sorted(data)\n    if len(sorted_data) % 2 == 0:\n        mid_index = len(sorted_data) // 2\n        expected_median = (sorted_data[mid_index - 1] + sorted_data[mid_index]) / 2\n        assert median(sorted_data) == expected_median", "properties": ["1. The median of an empty list raises a StatisticsError, indicating that there is no median for the provided data.", "2. The median of a single-element list is equal to that element itself.", "3. The median of a list with an odd number of elements is the middle element of the sorted list.", "4. The median of a list with an even number of elements is the average of the two middle elements of the sorted list.", "5. The median is invariant under the order of the input data; that is, sorting the data before finding the median should yield the same result as finding the median directly from the unsorted data."]}
{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: The median is invariant under the order of the input data; that is, sorting the data before finding the median should yield the same result as finding the median directly from the unsorted data.\nfrom hypothesis import given, strategies as st\nimport statistics\n\n@given(st.lists(st.integers(), min_size=1))\ndef test_violation_of_statistics_median_1(data):\n    sorted_data = sorted(data)\n    # Intentionally return an incorrect median value by adding 1 to the median of the unsorted data\n    assert statistics.median(data) + 1 == statistics.median(sorted_data)\n\n@given(st.lists(st.integers(), min_size=1))\ndef test_violation_of_statistics_median_2(data):\n    sorted_data = sorted(data)\n    # Intentionally return an incorrect median value by subtracting 1 from the median of the unsorted data\n    assert statistics.median(data) - 1 == statistics.median(sorted_data)\n\n@given(st.lists(st.integers(), min_size=1))\ndef test_violation_of_statistics_median_3(data):\n    sorted_data = sorted(data)\n    # Intentionally return a completely different value (e.g., 0) instead of the median\n    assert 0 == statistics.median(sorted_data)\n\n@given(st.lists(st.integers(), min_size=1))\ndef test_violation_of_statistics_median_4(data):\n    sorted_data = sorted(data)\n    # Intentionally return a value that is always greater than the median of the sorted data\n    assert statistics.median(data) + 10 == statistics.median(sorted_data)\n\n@given(st.lists(st.integers(), min_size=1))\ndef test_violation_of_statistics_median_5(data):\n    sorted_data = sorted(data)\n    # Intentionally return a value that is always less than the median of the sorted data\n    assert statistics.median(data) - 10 == statistics.median(sorted_data)\n```"], "property": "The median is invariant under the order of the input data; that is, sorting the data before finding the median should yield the same result as finding the median directly from the unsorted data.", "pbt": "@given(st.lists(st.integers(), min_size=1))\ndef test_median_invariant_under_order(data):\n    sorted_data = sorted(data)\n    assert median(data) == median(sorted_data)", "properties": ["1. The median of an empty list raises a StatisticsError, indicating that there is no median for the provided data.", "2. The median of a single-element list is equal to that element itself.", "3. The median of a list with an odd number of elements is the middle element of the sorted list.", "4. The median of a list with an even number of elements is the average of the two middle elements of the sorted list.", "5. The median is invariant under the order of the input data; that is, sorting the data before finding the median should yield the same result as finding the median directly from the unsorted data."]}
