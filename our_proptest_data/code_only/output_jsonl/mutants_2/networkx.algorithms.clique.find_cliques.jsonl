{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The output cliques must be subsets of the input graph's nodes, ensuring that all nodes in each returned clique are present in the original graph.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.clique import find_cliques\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    cliques.append([max(graph.nodes) + 1])  # Adding a node not in the graph\n    for clique in cliques:\n        assert set(clique).issubset(graph.nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    cliques[0] = [0, 1, 2]  # Assuming nodes 0, 1, 2 are not in the graph\n    for clique in cliques:\n        assert set(clique).issubset(graph.nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    cliques[0] = [node + 1000 for node in cliques[0]]  # Shifting all nodes by 1000\n    for clique in cliques:\n        assert set(clique).issubset(graph.nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    cliques[0] = [-1]  # Adding a negative node not in the graph\n    for clique in cliques:\n        assert set(clique).issubset(graph.nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    cliques[0] = [None]  # Adding a None value which is not a valid node\n    for clique in cliques:\n        assert set(clique).issubset(graph.nodes)\n```"], "property": "The output cliques must be subsets of the input graph's nodes, ensuring that all nodes in each returned clique are present in the original graph.", "pbt": "@given(st.data())\ndef test_output_nodes_are_subsets_property(data):\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    for clique in cliques:\n        assert set(clique).issubset(graph.nodes)", "properties": ["1. The output cliques must be subsets of the input graph's nodes, ensuring that all nodes in each returned clique are present in the original graph.", "2. Each returned clique must be a complete subgraph, meaning that every pair of nodes within the clique must be directly connected by an edge in the graph.", "3. The function should yield all maximal cliques, meaning no additional nodes can be added to any returned clique without breaking its completeness.", "4. If the input graph is empty, the function should yield no cliques, returning an empty output.", "5. If specific nodes are provided as input, the function should only yield cliques that include those nodes, and it should raise an error if the provided nodes do not form a clique."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: Each returned clique must be a complete subgraph, meaning that every pair of nodes within the clique must be directly connected by an edge in the graph.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.clique import find_cliques\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(data):\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    # Introduce a non-edge between the first two nodes of the first clique\n    if cliques:\n        clique = cliques[0]\n        if len(clique) > 1:\n            graph.remove_edge(clique[0], clique[1])\n    for clique in cliques:\n        for i in range(len(clique)):\n            for j in range(i + 1, len(clique)):\n                assert graph.has_edge(clique[i], clique[j])\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(data):\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    # Remove an edge between the last two nodes of the first clique\n    if cliques:\n        clique = cliques[0]\n        if len(clique) > 1:\n            graph.remove_edge(clique[-1], clique[-2])\n    for clique in cliques:\n        for i in range(len(clique)):\n            for j in range(i + 1, len(clique)):\n                assert graph.has_edge(clique[i], clique[j])\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(data):\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    # Remove an edge between two arbitrary nodes in the first clique\n    if cliques:\n        clique = cliques[0]\n        if len(clique) > 2:\n            graph.remove_edge(clique[0], clique[2])\n    for clique in cliques:\n        for i in range(len(clique)):\n            for j in range(i + 1, len(clique)):\n                assert graph.has_edge(clique[i], clique[j])\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(data):\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    # Remove an edge between the first two nodes of the last clique\n    if cliques:\n        clique = cliques[-1]\n        if len(clique) > 1:\n            graph.remove_edge(clique[0], clique[1])\n    for clique in cliques:\n        for i in range(len(clique)):\n            for j in range(i + 1, len(clique)):\n                assert graph.has_edge(clique[i], clique[j])\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(data):\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    # Remove an edge between two random nodes in the first clique\n    if cliques:\n        clique = cliques[0]\n        if len(clique) > 2:\n            graph.remove_edge(clique[1], clique[2])\n    for clique in cliques:\n        for i in range(len(clique)):\n            for j in range(i + 1, len(clique)):\n                assert graph.has_edge(clique[i], clique[j])\n```"], "property": "Each returned clique must be a complete subgraph, meaning that every pair of nodes within the clique must be directly connected by an edge in the graph.", "pbt": "@given(st.data())\ndef test_cliques_are_complete_subgraphs_property(data):\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    for clique in cliques:\n        for i in range(len(clique)):\n            for j in range(i + 1, len(clique)):\n                assert graph.has_edge(clique[i], clique[j])", "properties": ["1. The output cliques must be subsets of the input graph's nodes, ensuring that all nodes in each returned clique are present in the original graph.", "2. Each returned clique must be a complete subgraph, meaning that every pair of nodes within the clique must be directly connected by an edge in the graph.", "3. The function should yield all maximal cliques, meaning no additional nodes can be added to any returned clique without breaking its completeness.", "4. If the input graph is empty, the function should yield no cliques, returning an empty output.", "5. If specific nodes are provided as input, the function should only yield cliques that include those nodes, and it should raise an error if the provided nodes do not form a clique."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The function should yield all maximal cliques, meaning no additional nodes can be added to any returned clique without breaking its completeness.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.clique import find_cliques\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    # Deliberately adding an extra node to the cliques\n    cliques.append([cliques[0][0], graph.nodes[0]])  # Add a node that is connected to the first clique\n    for clique in cliques:\n        # Check that no nodes can be added to the clique without breaking its completeness\n        for node in graph.nodes:\n            if node not in clique and graph.has_edges_from((node, n) for n in clique):\n                assert False  # A node can be added to the clique\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    # Remove a node from the first clique to allow for expansion\n    if cliques:\n        cliques[0].remove(cliques[0][0])  # Remove a node from the first clique\n    for clique in cliques:\n        # Check that no nodes can be added to the clique without breaking its completeness\n        for node in graph.nodes:\n            if node not in clique and graph.has_edges_from((node, n) for n in clique):\n                assert False  # A node can be added to the clique\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    # Intentionally duplicate a clique to create a violation\n    if cliques:\n        cliques.append(cliques[0])  # Duplicate the first clique\n    for clique in cliques:\n        # Check that no nodes can be added to the clique without breaking its completeness\n        for node in graph.nodes:\n            if node not in clique and graph.has_edges_from((node, n) for n in clique):\n                assert False  # A node can be added to the clique\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    # Add a non-adjacent node to the first clique to violate maximality\n    if cliques:\n        cliques[0].append(graph.nodes[-1])  # Add a node that is not connected to the first clique\n    for clique in cliques:\n        # Check that no nodes can be added to the clique without breaking its completeness\n        for node in graph.nodes:\n            if node not in clique and graph.has_edges_from((node, n) for n in clique):\n                assert False  # A node can be added to the clique\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    # Create a new clique that is not maximal by including a node that is not connected\n    cliques.append([cliques[0][0], graph.nodes[0], graph.nodes[1]])  # Add unconnected nodes\n    for clique in cliques:\n        # Check that no nodes can be added to the clique without breaking its completeness\n        for node in graph.nodes:\n            if node not in clique and graph.has_edges_from((node, n) for n in clique):\n                assert False  # A node can be added to the clique\n```"], "property": "The function should yield all maximal cliques, meaning no additional nodes can be added to any returned clique without breaking its completeness.", "pbt": "@given(st.data())\ndef test_cliques_are_maximal_property(data):\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    for clique in cliques:\n        # Check that no nodes can be added to the clique without breaking its completeness\n        for node in graph.nodes:\n            if node not in clique and graph.has_edges_from((node, n) for n in clique):\n                assert False  # A node can be added to the clique", "properties": ["1. The output cliques must be subsets of the input graph's nodes, ensuring that all nodes in each returned clique are present in the original graph.", "2. Each returned clique must be a complete subgraph, meaning that every pair of nodes within the clique must be directly connected by an edge in the graph.", "3. The function should yield all maximal cliques, meaning no additional nodes can be added to any returned clique without breaking its completeness.", "4. If the input graph is empty, the function should yield no cliques, returning an empty output.", "5. If specific nodes are provided as input, the function should only yield cliques that include those nodes, and it should raise an error if the provided nodes do not form a clique."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: If the input graph is empty, the function should yield no cliques, returning an empty output.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.clique import find_cliques\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(data):\n    graph = nx.Graph()\n    cliques = list(find_cliques(graph)) + [[0]]  # Adding a dummy clique\n    assert cliques == []\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(data):\n    graph = nx.Graph()\n    cliques = list(find_cliques(graph)) + [[], []]  # Adding empty lists as cliques\n    assert cliques == []\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(data):\n    graph = nx.Graph()\n    cliques = list(find_cliques(graph)) + [[1, 2]]  # Adding a non-existent clique\n    assert cliques == []\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(data):\n    graph = nx.Graph()\n    cliques = list(find_cliques(graph)) + [[3]]  # Adding a single node as a clique\n    assert cliques == []\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(data):\n    graph = nx.Graph()\n    cliques = list(find_cliques(graph)) + [[4, 5, 6]]  # Adding a non-existent larger clique\n    assert cliques == []\n```"], "property": "If the input graph is empty, the function should yield no cliques, returning an empty output.", "pbt": "@given(st.data())\ndef test_empty_graph_yields_no_cliques_property(data):\n    graph = nx.Graph()\n    cliques = list(find_cliques(graph))\n    assert cliques == []", "properties": ["1. The output cliques must be subsets of the input graph's nodes, ensuring that all nodes in each returned clique are present in the original graph.", "2. Each returned clique must be a complete subgraph, meaning that every pair of nodes within the clique must be directly connected by an edge in the graph.", "3. The function should yield all maximal cliques, meaning no additional nodes can be added to any returned clique without breaking its completeness.", "4. If the input graph is empty, the function should yield no cliques, returning an empty output.", "5. If specific nodes are provided as input, the function should only yield cliques that include those nodes, and it should raise an error if the provided nodes do not form a clique."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: If specific nodes are provided as input, the function should only yield cliques that include those nodes, and it should raise an error if the provided nodes do not form a clique.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.clique import find_cliques\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(data):\n    nodes = data.draw(st.sets(st.integers(), min_size=2, max_size=10))\n    graph = nx.complete_graph(nodes)  # Create a complete graph\n    cliques = list(find_cliques(graph, nodes=list(nodes)))\n    cliques.append([max(nodes) + 1])  # Add a non-clique to the result\n    assert len(cliques) > 0  # There must be at least one clique, the nodes themselves\n    for clique in cliques:\n        assert set(clique) == set(nodes)  # Must yield the specified clique\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(data):\n    nodes = data.draw(st.sets(st.integers(), min_size=2, max_size=10))\n    graph = nx.complete_graph(nodes)  # Create a complete graph\n    cliques = list(find_cliques(graph, nodes=list(nodes)))\n    cliques[0] = list(nodes) + [max(nodes) + 1]  # Modify the first clique to include an extra node\n    assert len(cliques) > 0  # There must be at least one clique, the nodes themselves\n    for clique in cliques:\n        assert set(clique) == set(nodes)  # Must yield the specified clique\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(data):\n    nodes = data.draw(st.sets(st.integers(), min_size=2, max_size=10))\n    graph = nx.complete_graph(nodes)  # Create a complete graph\n    cliques = list(find_cliques(graph, nodes=list(nodes)))\n    cliques[0] = [nodes.pop()]  # Replace the first clique with a single node not in the original set\n    assert len(cliques) > 0  # There must be at least one clique, the nodes themselves\n    for clique in cliques:\n        assert set(clique) == set(nodes)  # Must yield the specified clique\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(data):\n    nodes = data.draw(st.sets(st.integers(), min_size=2, max_size=10))\n    graph = nx.complete_graph(nodes)  # Create a complete graph\n    cliques = list(find_cliques(graph, nodes=list(nodes)))\n    cliques.append([nodes[0], nodes[1] + 1])  # Add a non-clique with a modified node\n    assert len(cliques) > 0  # There must be at least one clique, the nodes themselves\n    for clique in cliques:\n        assert set(clique) == set(nodes)  # Must yield the specified clique\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(data):\n    nodes = data.draw(st.sets(st.integers(), min_size=2, max_size=10))\n    graph = nx.complete_graph(nodes)  # Create a complete graph\n    cliques = list(find_cliques(graph, nodes=list(nodes)))\n    cliques[0] = [nodes[0]]  # Change the first clique to only include one node\n    assert len(cliques) > 0  # There must be at least one clique, the nodes themselves\n    for clique in cliques:\n        assert set(clique) == set(nodes)  # Must yield the specified clique\n```"], "property": "If specific nodes are provided as input, the function should only yield cliques that include those nodes, and it should raise an error if the provided nodes do not form a clique.", "pbt": "@given(st.data())\ndef test_specific_nodes_must_form_clique_property(data):\n    nodes = data.draw(st.sets(st.integers(), min_size=2, max_size=10))\n    graph = nx.complete_graph(nodes)  # Create a complete graph\n    cliques = list(find_cliques(graph, nodes=list(nodes)))\n    assert len(cliques) > 0  # There must be at least one clique, the nodes themselves\n    for clique in cliques:\n        assert set(clique) == set(nodes)  # Must yield the specified clique", "properties": ["1. The output cliques must be subsets of the input graph's nodes, ensuring that all nodes in each returned clique are present in the original graph.", "2. Each returned clique must be a complete subgraph, meaning that every pair of nodes within the clique must be directly connected by an edge in the graph.", "3. The function should yield all maximal cliques, meaning no additional nodes can be added to any returned clique without breaking its completeness.", "4. If the input graph is empty, the function should yield no cliques, returning an empty output.", "5. If specific nodes are provided as input, the function should only yield cliques that include those nodes, and it should raise an error if the provided nodes do not form a clique."]}
