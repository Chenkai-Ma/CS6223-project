{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: The output should be a non-negative integer, representing the size of the largest clique in the graph.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.approximation import large_clique_size\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1():\n    G = data.draw(st.lists(st.tuples(st.integers(), st.integers()), min_size=0).map(nx.Graph))\n    result = large_clique_size(G)\n    result = -1  # Modify output to violate the property\n    assert result >= 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2():\n    G = data.draw(st.lists(st.tuples(st.integers(), st.integers()), min_size=0).map(nx.Graph))\n    result = large_clique_size(G)\n    result = -5  # Modify output to violate the property\n    assert result >= 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3():\n    G = data.draw(st.lists(st.tuples(st.integers(), st.integers()), min_size=0).map(nx.Graph))\n    result = large_clique_size(G)\n    result = -100  # Modify output to violate the property\n    assert result >= 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4():\n    G = data.draw(st.lists(st.tuples(st.integers(), st.integers()), min_size=0).map(nx.Graph))\n    result = large_clique_size(G)\n    result = float('-inf')  # Modify output to violate the property\n    assert result >= 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5():\n    G = data.draw(st.lists(st.tuples(st.integers(), st.integers()), min_size=0).map(nx.Graph))\n    result = large_clique_size(G)\n    result = \"not an integer\"  # Modify output to violate the property\n    assert result >= 0\n```"], "property": "The output should be a non-negative integer, representing the size of the largest clique in the graph.", "pbt": "@given(st.data())\ndef test_output_is_non_negative_property(data):\n    G = data.draw(st.lists(st.tuples(st.integers(), st.integers()), min_size=0).map(nx.Graph))\n    result = large_clique_size(G)\n    assert result >= 0", "properties": ["1. The output should be a non-negative integer, representing the size of the largest clique in the graph.", "3. If the graph is empty (contains no nodes), the output should be zero, indicating that there are no cliques.", "4. The output should be consistent with the maximum degree of any node in the graph; it cannot be larger than the maximum degree plus one, as cliques are formed by connected nodes."]}
{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: If the graph is empty (contains no nodes), the output should be zero, indicating that there are no cliques.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.approximation import large_clique_size\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1():\n    G = nx.Graph()  # An empty graph\n    result = large_clique_size(G) + 1  # Modify output to violate the property\n    assert result == 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2():\n    G = nx.Graph()  # An empty graph\n    result = large_clique_size(G) + 10  # Modify output to violate the property\n    assert result == 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3():\n    G = nx.Graph()  # An empty graph\n    result = large_clique_size(G) * 2  # Modify output to violate the property\n    assert result == 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4():\n    G = nx.Graph()  # An empty graph\n    result = large_clique_size(G) - 5  # Modify output to violate the property\n    assert result == 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5():\n    G = nx.Graph()  # An empty graph\n    result = large_clique_size(G) + 1000  # Modify output to violate the property\n    assert result == 0\n```"], "property": "If the graph is empty (contains no nodes), the output should be zero, indicating that there are no cliques.", "pbt": "@given(st.data())\ndef test_output_zero_for_empty_graph_property(data):\n    G = nx.Graph()  # An empty graph\n    result = large_clique_size(G)\n    assert result == 0", "properties": ["1. The output should be a non-negative integer, representing the size of the largest clique in the graph.", "3. If the graph is empty (contains no nodes), the output should be zero, indicating that there are no cliques.", "4. The output should be consistent with the maximum degree of any node in the graph; it cannot be larger than the maximum degree plus one, as cliques are formed by connected nodes."]}
{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: The output should be consistent with the maximum degree of any node in the graph; it cannot be larger than the maximum degree plus one, as cliques are formed by connected nodes.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.approximation import large_clique_size\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1():\n    G = data.draw(st.lists(st.tuples(st.integers(), st.integers()), min_size=1).map(nx.Graph))\n    result = large_clique_size(G)\n    max_degree = max(dict(G.degree()).values())\n    result = max_degree + 2  # Violate the property by making result larger than max_degree + 1\n    assert result <= max_degree + 1\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2():\n    G = data.draw(st.lists(st.tuples(st.integers(), st.integers()), min_size=1).map(nx.Graph))\n    result = large_clique_size(G)\n    max_degree = max(dict(G.degree()).values())\n    result = max_degree + 3  # Violate the property by making result larger than max_degree + 1\n    assert result <= max_degree + 1\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3():\n    G = data.draw(st.lists(st.tuples(st.integers(), st.integers()), min_size=1).map(nx.Graph))\n    result = large_clique_size(G)\n    max_degree = max(dict(G.degree()).values())\n    result = max_degree + 10  # Violate the property by making result larger than max_degree + 1\n    assert result <= max_degree + 1\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4():\n    G = data.draw(st.lists(st.tuples(st.integers(), st.integers()), min_size=1).map(nx.Graph))\n    result = large_clique_size(G)\n    max_degree = max(dict(G.degree()).values())\n    result = max_degree + 5  # Violate the property by making result larger than max_degree + 1\n    assert result <= max_degree + 1\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5():\n    G = data.draw(st.lists(st.tuples(st.integers(), st.integers()), min_size=1).map(nx.Graph))\n    result = large_clique_size(G)\n    max_degree = max(dict(G.degree()).values())\n    result = max_degree + 20  # Violate the property by making result larger than max_degree + 1\n    assert result <= max_degree + 1\n```"], "property": "The output should be consistent with the maximum degree of any node in the graph; it cannot be larger than the maximum degree plus one, as cliques are formed by connected nodes.", "pbt": "@given(st.data())\ndef test_output_within_max_degree_plus_one_property(data):\n    G = data.draw(st.lists(st.tuples(st.integers(), st.integers()), min_size=1).map(nx.Graph))\n    result = large_clique_size(G)\n    max_degree = max(dict(G.degree()).values())\n    assert result <= max_degree + 1", "properties": ["1. The output should be a non-negative integer, representing the size of the largest clique in the graph.", "3. If the graph is empty (contains no nodes), the output should be zero, indicating that there are no cliques.", "4. The output should be consistent with the maximum degree of any node in the graph; it cannot be larger than the maximum degree plus one, as cliques are formed by connected nodes."]}
