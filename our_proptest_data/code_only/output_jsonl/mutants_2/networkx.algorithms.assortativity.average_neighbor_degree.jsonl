{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The average neighbor degree for any node should be non-negative, as it represents an average of degrees of neighboring nodes.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    # Manipulate degrees to ensure at least one average is negative\n    degrees[list(degrees.keys())[0]] = -1\n    for avg in degrees.values():\n        assert avg >= 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    # Force all degrees to be negative\n    for key in degrees.keys():\n        degrees[key] = -5\n    for avg in degrees.values():\n        assert avg >= 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    # Introduce a negative average neighbor degree\n    degrees[next(iter(degrees))] = -10\n    for avg in degrees.values():\n        assert avg >= 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    # Set the last degree to a negative value\n    keys = list(degrees.keys())\n    degrees[keys[-1]] = -3\n    for avg in degrees.values():\n        assert avg >= 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    # Set multiple averages to negative values\n    for key in list(degrees.keys())[:2]:\n        degrees[key] = -2\n    for avg in degrees.values():\n        assert avg >= 0\n```"], "property": "The average neighbor degree for any node should be non-negative, as it represents an average of degrees of neighboring nodes.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_non_negative_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    for avg in degrees.values():\n        assert avg >= 0", "properties": ["1. The average neighbor degree for any node should be non-negative, as it represents an average of degrees of neighboring nodes.", "2. If a node has a degree of zero, its average neighbor degree should be exactly zero, since it has no neighbors.", "3. The average neighbor degree for a node should be equal to the total degree of its neighbors divided by the node's degree, ensuring that the calculation correctly reflects the average.", "4. In an undirected graph, the average neighbor degree should be symmetric; that is, the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "5. The average neighbor degree should be invariant under the addition of nodes with no edges, meaning that adding isolated nodes to the graph should not affect the average neighbor degrees of existing nodes."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: If a node has a degree of zero, its average neighbor degree should be exactly zero, since it has no neighbors.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    G.add_node(0)  # Add a node with zero degree\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    # Intentionally setting the degree of node 0 to a non-zero value\n    degrees[0] = 1.0  \n    assert degrees.get(0, 0) == 0.0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    G.add_node(0)  # Add a node with zero degree\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    # Intentionally setting the degree of node 0 to a negative value\n    degrees[0] = -1.0  \n    assert degrees.get(0, 0) == 0.0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    G.add_node(0)  # Add a node with zero degree\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    # Intentionally setting the degree of node 0 to a large positive value\n    degrees[0] = 100.0  \n    assert degrees.get(0, 0) == 0.0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    G.add_node(0)  # Add a node with zero degree\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    # Intentionally setting the degree of node 0 to a floating-point number\n    degrees[0] = 3.14  \n    assert degrees.get(0, 0) == 0.0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    G.add_node(0)  # Add a node with zero degree\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    # Intentionally setting the degree of node 0 to a string value\n    degrees[0] = \"not_a_number\"  \n    assert degrees.get(0, 0) == 0.0\n```"], "property": "If a node has a degree of zero, its average neighbor degree should be exactly zero, since it has no neighbors.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_zero_degree_node_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    G.add_node(0)  # Add a node with zero degree\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    assert degrees.get(0, 0) == 0.0", "properties": ["1. The average neighbor degree for any node should be non-negative, as it represents an average of degrees of neighboring nodes.", "2. If a node has a degree of zero, its average neighbor degree should be exactly zero, since it has no neighbors.", "3. The average neighbor degree for a node should be equal to the total degree of its neighbors divided by the node's degree, ensuring that the calculation correctly reflects the average.", "4. In an undirected graph, the average neighbor degree should be symmetric; that is, the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "5. The average neighbor degree should be invariant under the addition of nodes with no edges, meaning that adding isolated nodes to the graph should not affect the average neighbor degrees of existing nodes."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The average neighbor degree for a node should be equal to the total degree of its neighbors divided by the node's degree, ensuring that the calculation correctly reflects the average.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    for node in G.nodes:\n        avg = nx.algorithms.assortativity.average_neighbor_degree(G)[node]\n        neighbors = list(G.neighbors(node))\n        if len(neighbors) > 0:\n            total_degree = sum(G.degree[nbr] for nbr in neighbors)\n            assert avg != total_degree / G.degree[node]  # Violation: output not equal\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    for node in G.nodes:\n        avg = nx.algorithms.assortativity.average_neighbor_degree(G)[node]\n        neighbors = list(G.neighbors(node))\n        if len(neighbors) > 0:\n            total_degree = sum(G.degree[nbr] for nbr in neighbors)\n            assert avg == (total_degree / G.degree[node]) + 1  # Violation: output greater than expected\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    for node in G.nodes:\n        avg = nx.algorithms.assortativity.average_neighbor_degree(G)[node]\n        neighbors = list(G.neighbors(node))\n        if len(neighbors) > 0:\n            total_degree = sum(G.degree[nbr] for nbr in neighbors)\n            assert avg == total_degree / (G.degree[node] + 1)  # Violation: denominator altered\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    for node in G.nodes:\n        avg = nx.algorithms.assortativity.average_neighbor_degree(G)[node]\n        neighbors = list(G.neighbors(node))\n        if len(neighbors) > 0:\n            total_degree = sum(G.degree[nbr] for nbr in neighbors)\n            assert avg == total_degree / (G.degree[node] * 2)  # Violation: denominator doubled\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    for node in G.nodes:\n        avg = nx.algorithms.assortativity.average_neighbor_degree(G)[node]\n        neighbors = list(G.neighbors(node))\n        if len(neighbors) > 0:\n            total_degree = sum(G.degree[nbr] for nbr in neighbors)\n            assert avg == total_degree / (G.degree[node] ** 2)  # Violation: denominator squared\n```"], "property": "The average neighbor degree for a node should be equal to the total degree of its neighbors divided by the node's degree, ensuring that the calculation correctly reflects the average.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_correctness_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    for node in G.nodes:\n        avg = nx.algorithms.assortativity.average_neighbor_degree(G)[node]\n        neighbors = list(G.neighbors(node))\n        if len(neighbors) > 0:\n            total_degree = sum(G.degree[nbr] for nbr in neighbors)\n            assert avg == total_degree / G.degree[node]", "properties": ["1. The average neighbor degree for any node should be non-negative, as it represents an average of degrees of neighboring nodes.", "2. If a node has a degree of zero, its average neighbor degree should be exactly zero, since it has no neighbors.", "3. The average neighbor degree for a node should be equal to the total degree of its neighbors divided by the node's degree, ensuring that the calculation correctly reflects the average.", "4. In an undirected graph, the average neighbor degree should be symmetric; that is, the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "5. The average neighbor degree should be invariant under the addition of nodes with no edges, meaning that adding isolated nodes to the graph should not affect the average neighbor degrees of existing nodes."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: In an undirected graph, the average neighbor degree should be symmetric; that is, the average neighbor degree of node A should equal that of node B if A and B are neighbors.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2)))\n    for nodeA in G.nodes:\n        for nodeB in G.neighbors(nodeA):\n            avgA = nx.algorithms.assortativity.average_neighbor_degree(G)[nodeA]\n            avgB = avgA + 1  # Modify avgB to be different from avgA\n            assert avgA == avgB\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2)))\n    for nodeA in G.nodes:\n        for nodeB in G.neighbors(nodeA):\n            avgA = nx.algorithms.assortativity.average_neighbor_degree(G)[nodeA]\n            avgB = avgA - 1  # Modify avgB to be different from avgA\n            assert avgA == avgB\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2)))\n    for nodeA in G.nodes:\n        for nodeB in G.neighbors(nodeA):\n            avgA = nx.algorithms.assortativity.average_neighbor_degree(G)[nodeA]\n            avgB = (avgA + 2) % 10  # Change avgB to a value that does not equal avgA\n            assert avgA == avgB\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2)))\n    for nodeA in G.nodes:\n        for nodeB in G.neighbors(nodeA):\n            avgA = nx.algorithms.assortativity.average_neighbor_degree(G)[nodeA]\n            avgB = 0 if avgA != 0 else 1  # Ensure avgB is always different from avgA\n            assert avgA == avgB\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2)))\n    for nodeA in G.nodes:\n        for nodeB in G.neighbors(nodeA):\n            avgA = nx.algorithms.assortativity.average_neighbor_degree(G)[nodeA]\n            avgB = 1000  # Set avgB to a large constant that is unlikely to equal avgA\n            assert avgA == avgB\n```"], "property": "In an undirected graph, the average neighbor degree should be symmetric; that is, the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_symmetry_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2)))\n    for nodeA in G.nodes:\n        for nodeB in G.neighbors(nodeA):\n            avgA = nx.algorithms.assortativity.average_neighbor_degree(G)[nodeA]\n            avgB = nx.algorithms.assortativity.average_neighbor_degree(G)[nodeB]\n            assert avgA == avgB", "properties": ["1. The average neighbor degree for any node should be non-negative, as it represents an average of degrees of neighboring nodes.", "2. If a node has a degree of zero, its average neighbor degree should be exactly zero, since it has no neighbors.", "3. The average neighbor degree for a node should be equal to the total degree of its neighbors divided by the node's degree, ensuring that the calculation correctly reflects the average.", "4. In an undirected graph, the average neighbor degree should be symmetric; that is, the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "5. The average neighbor degree should be invariant under the addition of nodes with no edges, meaning that adding isolated nodes to the graph should not affect the average neighbor degrees of existing nodes."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The average neighbor degree should be invariant under the addition of nodes with no edges, meaning that adding isolated nodes to the graph should not affect the average neighbor degrees of existing nodes.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    original_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    G.add_node(1000)  # Add an isolated node\n    updated_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    for node in original_degrees.keys():\n        assert updated_degrees[node] != original_degrees[node]  # Violation: should not be equal\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    original_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    G.add_node(1000)  # Add an isolated node\n    updated_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    for node in original_degrees.keys():\n        assert updated_degrees[node] > original_degrees[node]  # Violation: should not be greater\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    original_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    G.add_node(1000)  # Add an isolated node\n    updated_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    for node in original_degrees.keys():\n        assert updated_degrees[node] < original_degrees[node]  # Violation: should not be less\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    original_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    G.add_node(1000)  # Add an isolated node\n    updated_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    for node in original_degrees.keys():\n        assert updated_degrees[node] != original_degrees[node] + 1  # Violation: should not be equal to original + 1\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    original_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    G.add_node(1000)  # Add an isolated node\n    updated_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    for node in original_degrees.keys():\n        assert updated_degrees[node] == 0  # Violation: should not be zero\n```"], "property": "The average neighbor degree should be invariant under the addition of nodes with no edges, meaning that adding isolated nodes to the graph should not affect the average neighbor degrees of existing nodes.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_invariance_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    original_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    G.add_node(1000)  # Add an isolated node\n    updated_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    for node in original_degrees.keys():\n        assert updated_degrees[node] == original_degrees[node]", "properties": ["1. The average neighbor degree for any node should be non-negative, as it represents an average of degrees of neighboring nodes.", "2. If a node has a degree of zero, its average neighbor degree should be exactly zero, since it has no neighbors.", "3. The average neighbor degree for a node should be equal to the total degree of its neighbors divided by the node's degree, ensuring that the calculation correctly reflects the average.", "4. In an undirected graph, the average neighbor degree should be symmetric; that is, the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "5. The average neighbor degree should be invariant under the addition of nodes with no edges, meaning that adding isolated nodes to the graph should not affect the average neighbor degrees of existing nodes."]}
