{"function_name": "decimal.Decimal.fma", "mutants": ["```python\n# property to violate: The result of `fma(self, other, third)` should be equal to `self * other + third` when neither `self` nor `other` are special values (like NaN or Infinity).\nfrom hypothesis import given, strategies as st\nfrom decimal import Decimal\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_1(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    result = dec_a.fma(dec_b, dec_c)\n    expected = dec_a * dec_b + dec_c + 1  # Adding 1 to violate the property\n    assert result == expected\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_2(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    result = dec_a.fma(dec_b, dec_c)\n    expected = dec_a * dec_b + dec_c - 1  # Subtracting 1 to violate the property\n    assert result == expected\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_3(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    result = dec_a.fma(dec_b, dec_c)\n    expected = (dec_a * dec_b + dec_c) * 2  # Multiplying the expected result by 2 to violate the property\n    assert result == expected\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_4(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    result = dec_a.fma(dec_b, dec_c)\n    expected = dec_a * dec_b + dec_c + dec_a  # Adding dec_a to violate the property\n    assert result == expected\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_5(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    result = dec_a.fma(dec_b, dec_c)\n    expected = dec_a * dec_b + dec_c - dec_b  # Subtracting dec_b to violate the property\n    assert result == expected\n```"], "property": "The result of `fma(self, other, third)` should be equal to `self * other + third` when neither `self` nor `other` are special values (like NaN or Infinity).", "pbt": "@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_decimal_Decimal_fma_basic_property(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    result = dec_a.fma(dec_b, dec_c)\n    expected = dec_a * dec_b + dec_c\n    assert result == expected", "properties": ["1. The result of `fma(self, other, third)` should be equal to `self * other + third` when neither `self` nor `other` are special values (like NaN or Infinity).", "2. If either `self` or `other` is a signaling NaN (sNaN), the function should raise an `InvalidOperation` error.", "3. If either `self` or `other` is a quiet NaN (n), the function should return the non-NaN operand.", "4. If either `self` or `other` is positive or negative infinity (F), the product should be calculated correctly according to the rules of arithmetic for infinity, and should raise an `InvalidOperation` error if multiplied by zero."]}
{"function_name": "decimal.Decimal.fma", "mutants": ["```python\n# property to violate: If either `self` or `other` is a signaling NaN (sNaN), the function should raise an `InvalidOperation` error.\nfrom hypothesis import given, strategies as st\nfrom decimal import Decimal, InvalidOperation\n\n@given(st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_1(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_nan():\n        # Incorrectly asserting that no exception is raised\n        dec_a.fma(dec_b, dec_c)\n        assert True, \"Expected InvalidOperation for sNaN\"\n\n@given(st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_2(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_nan():\n        # Returning a valid result instead of raising an exception\n        result = dec_a.fma(dec_b, dec_c)\n        assert result is not None, \"Expected InvalidOperation for sNaN\"\n\n@given(st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_3(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_nan():\n        # Ignoring the exception and proceeding with the computation\n        result = dec_a.fma(dec_b, dec_c)\n        assert result == Decimal('0'), \"Expected InvalidOperation for sNaN\"\n\n@given(st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_4(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_nan():\n        # Incorrectly assuming the result will always be a valid Decimal\n        result = dec_a.fma(dec_b, dec_c)\n        assert result == Decimal('1'), \"Expected InvalidOperation for sNaN\"\n\n@given(st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_5(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_nan():\n        # Assuming the operation will always yield a positive result\n        result = dec_a.fma(dec_b, dec_c)\n        assert result > 0, \"Expected InvalidOperation for sNaN\"\n```"], "property": "If either `self` or `other` is a signaling NaN (sNaN), the function should raise an `InvalidOperation` error.", "pbt": "@given(st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_decimal_Decimal_fma_sNaN_property(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_nan():\n        try:\n            dec_a.fma(dec_b, dec_c)\n            assert False, \"Expected InvalidOperation for sNaN\"\n        except InvalidOperation:\n            pass", "properties": ["1. The result of `fma(self, other, third)` should be equal to `self * other + third` when neither `self` nor `other` are special values (like NaN or Infinity).", "2. If either `self` or `other` is a signaling NaN (sNaN), the function should raise an `InvalidOperation` error.", "3. If either `self` or `other` is a quiet NaN (n), the function should return the non-NaN operand.", "4. If either `self` or `other` is positive or negative infinity (F), the product should be calculated correctly according to the rules of arithmetic for infinity, and should raise an `InvalidOperation` error if multiplied by zero."]}
{"function_name": "decimal.Decimal.fma", "mutants": ["```python\n# property to violate: If either `self` or `other` is a quiet NaN (n), the function should return the non-NaN operand.\nfrom hypothesis import given, strategies as st\nfrom decimal import Decimal\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_1(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_b.is_nan():\n        result = dec_a.fma(dec_b, dec_c)\n        assert result == dec_c  # Violating the property by returning dec_c instead of dec_a\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_2(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_b.is_nan():\n        result = dec_a.fma(dec_b, dec_c)\n        assert result == Decimal('0')  # Violating the property by returning a constant value\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_3(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_b.is_nan():\n        result = dec_a.fma(dec_b, dec_c)\n        assert result == dec_b  # Violating the property by returning dec_b instead of dec_a\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_4(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_b.is_nan():\n        result = dec_a.fma(dec_b, dec_c)\n        assert result == Decimal('NaN')  # Violating the property by returning NaN\n\n@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_5(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_b.is_nan():\n        result = dec_a.fma(dec_b, dec_c)\n        assert result == dec_a + dec_c  # Violating the property by performing an operation instead of returning dec_a\n```"], "property": "If either `self` or `other` is a quiet NaN (n), the function should return the non-NaN operand.", "pbt": "@given(st.floats(allow_nan=False, allow_infinity=False), \n       st.floats(allow_nan=True, allow_infinity=False), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_decimal_Decimal_fma_nNaN_property(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_b.is_nan():\n        result = dec_a.fma(dec_b, dec_c)\n        assert result == dec_a", "properties": ["1. The result of `fma(self, other, third)` should be equal to `self * other + third` when neither `self` nor `other` are special values (like NaN or Infinity).", "2. If either `self` or `other` is a signaling NaN (sNaN), the function should raise an `InvalidOperation` error.", "3. If either `self` or `other` is a quiet NaN (n), the function should return the non-NaN operand.", "4. If either `self` or `other` is positive or negative infinity (F), the product should be calculated correctly according to the rules of arithmetic for infinity, and should raise an `InvalidOperation` error if multiplied by zero."]}
{"function_name": "decimal.Decimal.fma", "mutants": ["```python\n# property to violate: If either `self` or `other` is positive or negative infinity (F), the product should be calculated correctly according to the rules of arithmetic for infinity, and should raise an `InvalidOperation` error if multiplied by zero.\nfrom hypothesis import given, strategies as st\nfrom decimal import Decimal, InvalidOperation\n\n@given(st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_1(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_infinite() or dec_b.is_infinite():\n        try:\n            result = dec_a.fma(dec_b, dec_c)\n            # Violation: Incorrect result when either is infinity\n            assert result != dec_a * dec_b + dec_c, \"Expected incorrect result for infinity multiplication\"\n        except InvalidOperation:\n            pass\n\n@given(st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_2(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_infinite() or dec_b.is_infinite():\n        try:\n            result = dec_a.fma(dec_b, dec_c)\n            # Violation: Should raise InvalidOperation but it doesn't\n            if not (dec_a.is_zero() or dec_b.is_zero()):\n                assert False, \"Expected InvalidOperation for non-zero INF * non-zero\"\n        except InvalidOperation:\n            pass\n\n@given(st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_3(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_infinite() or dec_b.is_infinite():\n        try:\n            result = dec_a.fma(dec_b, dec_c)\n            # Violation: Result should not be equal to the expected output\n            assert result == Decimal('0'), \"Expected result to be zero for infinity multiplication\"\n        except InvalidOperation:\n            pass\n\n@given(st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_4(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_infinite() or dec_b.is_infinite():\n        try:\n            result = dec_a.fma(dec_b, dec_c)\n            # Violation: Result should be a negative value if both are positive infinity\n            assert result < 0, \"Expected result to be negative for positive infinity multiplication\"\n        except InvalidOperation:\n            pass\n\n@given(st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_fma_5(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_infinite() or dec_b.is_infinite():\n        try:\n            result = dec_a.fma(dec_b, dec_c)\n            # Violation: Result should not be equal to the expected arithmetic result\n            assert result == Decimal('NaN'), \"Expected result to be NaN for infinity operation\"\n        except InvalidOperation:\n            pass\n```"], "property": "If either `self` or `other` is positive or negative infinity (F), the product should be calculated correctly according to the rules of arithmetic for infinity, and should raise an `InvalidOperation` error if multiplied by zero.", "pbt": "@given(st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=True), \n       st.floats(allow_nan=False, allow_infinity=False))\ndef test_decimal_Decimal_fma_infinity_property(a, b, c):\n    dec_a = Decimal(a)\n    dec_b = Decimal(b)\n    dec_c = Decimal(c)\n    if dec_a.is_infinite() or dec_b.is_infinite():\n        try:\n            result = dec_a.fma(dec_b, dec_c)\n            if dec_a.is_zero() or dec_b.is_zero():\n                assert False, \"Expected InvalidOperation for INF * 0\"\n        except InvalidOperation:\n            pass", "properties": ["1. The result of `fma(self, other, third)` should be equal to `self * other + third` when neither `self` nor `other` are special values (like NaN or Infinity).", "2. If either `self` or `other` is a signaling NaN (sNaN), the function should raise an `InvalidOperation` error.", "3. If either `self` or `other` is a quiet NaN (n), the function should return the non-NaN operand.", "4. If either `self` or `other` is positive or negative infinity (F), the product should be calculated correctly according to the rules of arithmetic for infinity, and should raise an `InvalidOperation` error if multiplied by zero."]}
