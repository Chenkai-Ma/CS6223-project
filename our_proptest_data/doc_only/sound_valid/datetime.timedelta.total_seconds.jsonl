{"function_name": "datetime.timedelta.total_seconds", "properties": ["1. The total number of seconds returned by `total_seconds()` should always be a non-negative float, as it represents a duration.", "2. The total number of seconds should be equal to the sum of the individual components of the `timedelta` object, converted into seconds.", "3. The total number of seconds should remain consistent regardless of the input representation (e.g., using days, weeks, hours, etc.) as long as the total duration is the same.", "4. For very large time intervals (greater than 270 years), the total number of seconds may lose microsecond accuracy, meaning the output may not accurately reflect the true duration.", "5. The total number of seconds should be zero if the `timedelta` object represents a duration of zero (i.e., all components are zero)."], "pbt": ["@given(st.timedeltas(min_value=timedelta(0), max_value=timedelta(days=365*270)))\ndef test_total_seconds_non_negative_property(td):\n    assert td.total_seconds() >= 0", "@given(st.timedeltas())\ndef test_total_seconds_sum_of_components_property(td):\n    total_seconds = (td.days * 86400) + (td.seconds) + (td.microseconds / 1_000_000)\n    assert td.total_seconds() == total_seconds", "@given(st.timedeltas())\ndef test_total_seconds_consistency_property(td):\n    alternative_td = timedelta(days=td.days, seconds=td.seconds, microseconds=td.microseconds)\n    assert td.total_seconds() == alternative_td.total_seconds()", "@given(st.timedeltas(min_value=timedelta(days=365*270)))\ndef test_total_seconds_accuracy_loss_property(td):\n    if td.total_seconds() > 86400 * 365 * 270:  # More than 270 years\n        result = td.total_seconds()\n        assert isinstance(result, float)  # It may lose precision, but should be a float", "@given(st.timedeltas())\ndef test_total_seconds_zero_duration_property(td):\n    if td == timedelta(0):\n        assert td.total_seconds() == 0.0"], "api_doc": "timedelta.total_seconds()\nReturn the total number of seconds contained in the duration. Equivalent to td / timedelta(seconds=1). For interval units other than seconds, use the division form directly (e.g. td / timedelta(microseconds=1)).\n\nNote that for very large time intervals (greater than 270 years on most platforms) this method will lose microsecond accuracy.\n\nAdded in version 3.2.\n\nExamples of usage: timedelta\nAn additional example of normalization:\n\n>>>\n# Components of another_year add up to exactly 365 days\nfrom datetime import timedelta\nyear = timedelta(days=365)\nanother_year = timedelta(weeks=40, days=84, hours=23,\n                         minutes=50, seconds=600)\nyear == another_year\nTrue\nyear.total_seconds()\n31536000.0"}
