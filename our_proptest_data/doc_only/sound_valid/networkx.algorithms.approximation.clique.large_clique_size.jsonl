{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "properties": ["1. The output size of the large clique must be a non-negative integer, as it represents the number of nodes in the clique.", "2. The output size of the large clique must not exceed the total number of nodes in the input graph \\( G \\).", "3. If the input graph \\( G \\) is empty (i.e., has no nodes), the output should be zero, indicating that there are no cliques.", "4. The output size of the large clique must be less than or equal to the maximum degree of the graph plus one, as this is a theoretical upper bound on the size of a clique.", "5. If the input graph \\( G \\) is disconnected (i.e., contains multiple components), the output size should reflect the largest clique found in any of the connected components of the graph."], "pbt": ["@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_large_clique_size_non_negative_integer(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size >= 0", "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_large_clique_size_not_exceeding_node_count(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size <= len(graph_nodes)", "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0))\ndef test_large_clique_size_empty_graph(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size == 0", "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_large_clique_size_bounded_by_max_degree(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    G.add_edges_from([(i, j) for i in range(len(graph_nodes)) for j in range(i + 1, len(graph_nodes))])\n    max_degree = max(dict(G.degree()).values())\n    clique_size = large_clique_size(G)\n    assert clique_size <= max_degree + 1", "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_large_clique_size_disconnected_graph(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create disconnected components\n    for i in range(0, len(graph_nodes), 2):\n        if i + 1 < len(graph_nodes):\n            G.add_edge(graph_nodes[i], graph_nodes[i + 1])\n    clique_size = large_clique_size(G)\n    assert clique_size <= max(2, len(graph_nodes) // 2)"], "api_doc": "large_clique_size\nlarge_clique_size(G)[source]\nFind the size of a large clique in a graph.\n\nA clique is a subset of nodes in which each pair of nodes is adjacent. This function is a heuristic for finding the size of a large clique in the graph.\n\nParameters\n:\nG\nNetworkX graph\nReturns\n:\nk: integer\nThe size of a large clique in the graph.\n\nRaises\n:\nNetworkXNotImplemented\nIf the graph is directed or is a multigraph.\n\nSee also\n\nnetworkx.algorithms.approximation.clique.max_clique()\nA function that returns an approximate maximum clique with a guarantee on the approximation ratio.\n\nnetworkx.algorithms.clique\nFunctions for finding the exact maximum clique in a graph.\n\nNotes\n\nThis implementation is from [1]. Its worst case time complexity is \n, where n is the number of nodes in the graph and d is the maximum degree.\n\nThis function is a heuristic, which means it may work well in practice, but there is no rigorous mathematical guarantee on the ratio between the returned number and the actual largest clique size in the graph.\n\nReferences\n\n[1]\nPattabiraman, Bharath, et al. \u201cFast Algorithms for the Maximum Clique Problem on Massive Graphs with Applications to Overlapping Community Detection.\u201d Internet Mathematics 11.4-5 (2015): 421\u2013448. <https://doi.org/10.1080/15427951.2014.986778>\n\nExamples\n\nG = nx.path_graph(10)\nnx.approximation.large_clique_size(G)\n2"}
