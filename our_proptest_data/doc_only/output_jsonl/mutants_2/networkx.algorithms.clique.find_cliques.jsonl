{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The output cliques must be subsets of the nodes present in the input graph \\( G \\).\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Introduce a node that is not in the graph nodes\n    cliques = [[max(graph_nodes) + 1]]  # This clique contains a node not in the graph\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create a clique that includes a negative integer not in the graph\n    cliques = [[-1]]  # This clique contains a node not in the graph\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create a clique with a string, which is not an integer node\n    cliques = [[\"not_a_node\"]]  # This clique contains a non-integer node\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create a clique that has a float number, which is not an integer node\n    cliques = [[3.14]]  # This clique contains a float node\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create a clique with a very large integer not in the graph\n    cliques = [[999999]]  # This clique contains a node not in the graph\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)\n```"], "property": "The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "pbt": "@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_output_cliques_are_subsets_of_graph_nodes_property(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)", "properties": ["1. The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "2. Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "3. The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "4. If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "5. The output must not contain duplicate cliques; each maximal clique should be unique in the result."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        cliques.append([])  # Add an empty clique to violate the property\n        assert all(len(clique) > 0 for clique in cliques)\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        cliques[0] = []  # Modify the first clique to be empty\n        assert all(len(clique) > 0 for clique in cliques)\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        cliques = [clique for clique in cliques if len(clique) > 0] + [[]]  # Add an empty clique\n        assert all(len(clique) > 0 for clique in cliques)\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        cliques[-1] = []  # Change the last clique to be empty\n        assert all(len(clique) > 0 for clique in cliques)\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        cliques = [[]] + cliques  # Prepend an empty clique to the list\n        assert all(len(clique) > 0 for clique in cliques)\n```"], "property": "Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "pbt": "@given(st.lists(st.integers()))\ndef test_output_cliques_contain_at_least_one_node_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        assert all(len(clique) > 0 for clique in cliques)", "properties": ["1. The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "2. Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "3. The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "4. If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "5. The output must not contain duplicate cliques; each maximal clique should be unique in the result."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    # Intentionally remove a node from a clique to violate maximality\n    if cliques:\n        cliques[0].pop()  # Remove an arbitrary node from the first clique\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    # Add a node to a clique to violate maximality\n    if cliques:\n        cliques[0].append(max(graph_nodes) + 1)  # Add a new node that is not in the graph\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    # Duplicate a clique to create a non-maximal scenario\n    if len(cliques) > 1:\n        cliques.append(cliques[0][:])  # Append a copy of the first clique\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    # Remove all nodes from a clique to create an empty clique\n    if cliques:\n        cliques[0] = []  # Empty the first clique\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    # Replace a clique with a non-complete set of nodes\n    if cliques:\n        cliques[0] = [graph_nodes[0], graph_nodes[1]]  # Only two nodes, not maximal\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))\n```"], "property": "The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "pbt": "@given(st.lists(st.integers()))\ndef test_output_cliques_are_maximal_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))", "properties": ["1. The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "2. Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "3. The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "4. If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "5. The output must not contain duplicate cliques; each maximal clique should be unique in the result."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    # Remove one specified node from the cliques output to violate the property\n    for clique in cliques:\n        if specified_nodes:\n            clique.remove(specified_nodes[0])\n    for clique in cliques:\n        assert all(node in clique for node in specified_nodes)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    # Introduce a new node that is not in specified_nodes into the cliques\n    for clique in cliques:\n        if graph_nodes:\n            clique.append(graph_nodes[0])\n    for clique in cliques:\n        assert all(node in clique for node in specified_nodes)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    # Replace all cliques with an empty list to violate the property\n    cliques = []\n    for clique in cliques:\n        assert all(node in clique for node in specified_nodes)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    # Add a node not in specified_nodes to every clique\n    for clique in cliques:\n        clique.append(max(graph_nodes) + 1)  # Adding a new node not in specified_nodes\n    for clique in cliques:\n        assert all(node in clique for node in specified_nodes)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    # Remove all specified nodes from the cliques\n    for clique in cliques:\n        for node in specified_nodes:\n            if node in clique:\n                clique.remove(node)\n    for clique in cliques:\n        assert all(node in clique for node in specified_nodes)\n```"], "property": "If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "pbt": "@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_cliques_include_specified_nodes_property(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    for clique in cliques:\n        assert all(node in clique for node in specified_nodes)", "properties": ["1. The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "2. Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "3. The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "4. If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "5. The output must not contain duplicate cliques; each maximal clique should be unique in the result."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The output must not contain duplicate cliques; each maximal clique should be unique in the result.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    cliques.append(cliques[0])  # Adding a duplicate of the first clique\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    cliques += cliques  # Duplicating the entire list of cliques\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    cliques.append(cliques[1])  # Adding a duplicate of the second clique\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    cliques = cliques * 3  # Tripling the list of cliques\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    cliques.append(cliques[-1])  # Adding a duplicate of the last clique\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness\n```"], "property": "The output must not contain duplicate cliques; each maximal clique should be unique in the result.", "pbt": "@given(st.lists(st.integers()))\ndef test_output_cliques_are_unique_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness", "properties": ["1. The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "2. Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "3. The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "4. If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "5. The output must not contain duplicate cliques; each maximal clique should be unique in the result."]}
