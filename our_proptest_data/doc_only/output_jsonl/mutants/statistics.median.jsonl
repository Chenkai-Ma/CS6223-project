{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: The median of a non-empty list of numbers should always be a number (either an integer or a float).\nfrom hypothesis import given, strategies as st\nimport statistics\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_1(data):\n    result = \"not a number\"  # Violating the property by returning a string\n    assert isinstance(result, (int, float))\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_2(data):\n    result = None  # Violating the property by returning None\n    assert isinstance(result, (int, float))\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_3(data):\n    result = []  # Violating the property by returning an empty list\n    assert isinstance(result, (int, float))\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_4(data):\n    result = {}  # Violating the property by returning an empty dictionary\n    assert isinstance(result, (int, float))\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_5(data):\n    result = object()  # Violating the property by returning an object\n    assert isinstance(result, (int, float))\n```"], "property": "The median of a non-empty list of numbers should always be a number (either an integer or a float).", "pbt": "@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_median_non_empty_output_property(data):\n    result = statistics.median(data)\n    assert isinstance(result, (int, float))", "properties": ["1. The median of a non-empty list of numbers should always be a number (either an integer or a float).", "2. If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.", "3. If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.", "5. The median should raise a StatisticsError when the input list is empty."]}
{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.\nfrom hypothesis import given, strategies as st\nimport statistics\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_1(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data) + 1  # Adding 1 to the result to violate the property\n        assert result == sorted_data[len(sorted_data) // 2]\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_2(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data) - 1  # Subtracting 1 from the result to violate the property\n        assert result == sorted_data[len(sorted_data) // 2]\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_3(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = sorted_data[len(sorted_data) // 2] + 10  # Adding 10 to the middle element to violate the property\n        assert result == sorted_data[len(sorted_data) // 2]\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_4(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = sorted_data[len(sorted_data) // 2] * 2  # Doubling the middle element to violate the property\n        assert result == sorted_data[len(sorted_data) // 2]\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_5(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data) + 0.5  # Adding 0.5 to the result to violate the property\n        assert result == sorted_data[len(sorted_data) // 2]\n```"], "property": "If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.", "pbt": "@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_median_odd_length_property(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        assert result == sorted_data[len(sorted_data) // 2]", "properties": ["1. The median of a non-empty list of numbers should always be a number (either an integer or a float).", "2. If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.", "3. If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.", "5. The median should raise a StatisticsError when the input list is empty."]}
{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.\nfrom hypothesis import given, strategies as st\nimport statistics\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_violation_of_statistics_median_1(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        # Incorrectly return the first middle element instead of the average\n        assert result == sorted_data[len(sorted_data) // 2 - 1]\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_violation_of_statistics_median_2(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        # Incorrectly return the second middle element instead of the average\n        assert result == sorted_data[len(sorted_data) // 2]\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_violation_of_statistics_median_3(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        # Incorrectly return the average of the first and last element instead of the middle elements\n        assert result == (sorted_data[0] + sorted_data[-1]) / 2\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_violation_of_statistics_median_4(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        # Incorrectly return a constant value instead of the average of the middle elements\n        assert result == 0\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_violation_of_statistics_median_5(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        # Incorrectly return the sum of the two middle elements instead of the average\n        assert result == sorted_data[len(sorted_data) // 2 - 1] + sorted_data[len(sorted_data) // 2]\n```"], "property": "If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.", "pbt": "@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_median_even_length_property(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        assert result == (sorted_data[len(sorted_data) // 2 - 1] + sorted_data[len(sorted_data) // 2]) / 2", "properties": ["1. The median of a non-empty list of numbers should always be a number (either an integer or a float).", "2. If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.", "3. If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.", "5. The median should raise a StatisticsError when the input list is empty."]}
{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: The median should raise a StatisticsError when the input list is empty.\nfrom hypothesis import given, strategies as st\nimport statistics\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_violation_of_statistics_median_1(data):\n    if len(data) == 0:\n        # Incorrectly returning a value instead of raising an error\n        return 0  # This should not happen, we expect an error\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_violation_of_statistics_median_2(data):\n    if len(data) == 0:\n        # Incorrectly returning None instead of raising an error\n        return None  # This should not happen, we expect an error\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_violation_of_statistics_median_3(data):\n    if len(data) == 0:\n        # Incorrectly returning a string instead of raising an error\n        return \"No data\"  # This should not happen, we expect an error\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_violation_of_statistics_median_4(data):\n    if len(data) == 0:\n        # Incorrectly returning an empty list instead of raising an error\n        return []  # This should not happen, we expect an error\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_violation_of_statistics_median_5(data):\n    if len(data) == 0:\n        # Incorrectly raising a different exception instead of StatisticsError\n        raise ValueError(\"This is not the expected error\")  # This should not happen, we expect an error\n```"], "property": "The median should raise a StatisticsError when the input list is empty.", "pbt": "@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_median_empty_input_property(data):\n    if len(data) == 0:\n        try:\n            statistics.median(data)\n            assert False, \"Expected StatisticsError for empty input\"\n        except statistics.StatisticsError:\n            pass  # Expected behavior", "properties": ["1. The median of a non-empty list of numbers should always be a number (either an integer or a float).", "2. If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.", "3. If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.", "5. The median should raise a StatisticsError when the input list is empty."]}
