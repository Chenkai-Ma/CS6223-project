{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The output cliques must be subsets of the nodes present in the input graph \\( G \\).\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    # Modify the output to include a node not in graph_nodes\n    cliques.append([max(graph_nodes) + 1])  # Adding an invalid node\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    # Modify the output to include a node not in graph_nodes\n    cliques.append([min(graph_nodes) - 1])  # Adding an invalid node\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    # Modify the output to include a node not in graph_nodes\n    cliques.append([42])  # Adding an arbitrary invalid node\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    # Modify the output to include a node not in graph_nodes\n    cliques.append([None])  # Adding a None value as an invalid node\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    # Modify the output to include a node not in graph_nodes\n    cliques.append([-1])  # Adding a negative node as an invalid node\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)\n```"], "property": "The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "pbt": "@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_output_cliques_are_subsets_of_graph_nodes_property(graph_nodes, clique_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    for clique in cliques:\n        assert all(node in graph_nodes for node in clique)", "properties": ["1. The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "2. Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "3. The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "4. If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "5. The output must not contain duplicate cliques; each maximal clique should be unique in the result."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        # Intentionally modify cliques to include an empty list\n        cliques.append([])\n        assert all(len(clique) > 0 for clique in cliques)\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        # Intentionally modify cliques to have a None element\n        cliques.append(None)\n        assert all(len(clique) > 0 for clique in cliques)\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        # Intentionally modify cliques to include a list with only None\n        cliques.append([None])\n        assert all(len(clique) > 0 for clique in cliques)\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        # Intentionally modify cliques to include a list with negative integers\n        cliques.append([-1, -2, -3])\n        assert all(len(clique) > 0 for clique in cliques)\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        # Intentionally modify cliques to include an empty string\n        cliques.append(\"\")\n        assert all(len(clique) > 0 for clique in cliques)\n```"], "property": "Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "pbt": "@given(st.lists(st.integers()))\ndef test_output_cliques_contain_at_least_one_node_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    if cliques:  # Check only if there are cliques found\n        assert all(len(clique) > 0 for clique in cliques)", "properties": ["1. The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "2. Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "3. The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "4. If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "5. The output must not contain duplicate cliques; each maximal clique should be unique in the result."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    # Modify the cliques to add an arbitrary node to violate maximality\n    if cliques:\n        cliques[0].append(max(graph_nodes) + 1)  # Add a new node that is not part of the clique\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    # Modify the cliques to make them incomplete\n    if cliques:\n        cliques[0] = cliques[0][:len(cliques[0]) - 1]  # Remove one node from the first clique\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    # Modify the cliques to add an existing node that is not part of the clique\n    if cliques:\n        cliques[0].append(cliques[0][0])  # Duplicate a node in the first clique\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    # Modify the cliques to create overlaps that shouldn't exist\n    if cliques:\n        cliques[0] = cliques[1]  # Make the first clique identical to the second\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    # Modify the cliques to ensure they are not maximal by removing a node\n    if cliques:\n        cliques[0].remove(cliques[0][-1])  # Remove the last node from the first clique\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))\n```"], "property": "The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "pbt": "@given(st.lists(st.integers()))\ndef test_output_cliques_are_maximal_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(graph_nodes)):\n        for j in range(i + 1, len(graph_nodes)):\n            G.add_edge(graph_nodes[i], graph_nodes[j])  # Make it a complete graph\n    cliques = list(nx.find_cliques(G))\n    for clique in cliques:\n        for node in graph_nodes:\n            if node not in clique:\n                assert not any(node in c for c in nx.find_cliques(G) if set(clique).issubset(c))", "properties": ["1. The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "2. Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "3. The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "4. If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "5. The output must not contain duplicate cliques; each maximal clique should be unique in the result."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    # Modify the output to ensure at least one clique does not contain all specified nodes\n    if cliques:\n        cliques[0] = [node for node in cliques[0] if node not in specified_nodes]  # Remove specified nodes\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    # Ensure cliques contain a node not in specified_nodes\n    if cliques:\n        cliques[0].append(max(graph_nodes) + 1)  # Add a node that is not in specified_nodes\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    # Replace all cliques with an empty list\n    cliques = [[]]  # Ensure no clique contains specified nodes\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    # Modify the cliques to include only one specified node\n    if cliques:\n        cliques[0] = [specified_nodes[0]]  # Ensure it doesn't contain all specified nodes\n\n@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    # Ensure that the cliques returned do not include any specified nodes\n    if cliques:\n        cliques[0] = [node for node in graph_nodes if node not in specified_nodes]  # Remove all specified nodes\n```"], "property": "If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "pbt": "@given(st.lists(st.integers()), st.lists(st.integers(), max_size=10))\ndef test_cliques_include_specified_nodes_property(graph_nodes, specified_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    for i in range(len(specified_nodes)):\n        for j in range(i + 1, len(specified_nodes)):\n            G.add_edge(specified_nodes[i], specified_nodes[j])  # Make it a complete subgraph\n    cliques = list(nx.find_cliques(G, nodes=specified_nodes))\n    for clique in cliques:\n        assert all(node in clique for node in specified_nodes)", "properties": ["1. The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "2. Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "3. The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "4. If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "5. The output must not contain duplicate cliques; each maximal clique should be unique in the result."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The output must not contain duplicate cliques; each maximal clique should be unique in the result.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G)) + cliques  # Duplicate the cliques\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G)) * 2  # Repeat the cliques\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G)) + [[0, 1, 2]]  # Add a known duplicate clique\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G)) + [cliques[0]]  # Append the first clique again\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness\n\n@given(st.lists(st.integers()))\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G)) + cliques[:1] * 3  # Add multiple copies of the first clique\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness\n```"], "property": "The output must not contain duplicate cliques; each maximal clique should be unique in the result.", "pbt": "@given(st.lists(st.integers()))\ndef test_output_cliques_are_unique_property(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    cliques = list(nx.find_cliques(G))\n    assert len(cliques) == len(set(map(tuple, cliques)))  # Convert to tuples to compare uniqueness", "properties": ["1. The output cliques must be subsets of the nodes present in the input graph \\( G \\).", "2. Each clique in the output must contain at least one node if the input graph \\( G \\) is non-empty.", "3. The output cliques must be maximal, meaning that no additional nodes from the graph \\( G \\) can be added to any clique without losing the property of being a complete subgraph.", "4. If a list of nodes is provided as input, every clique returned in the output must include all of those nodes.", "5. The output must not contain duplicate cliques; each maximal clique should be unique in the result."]}
