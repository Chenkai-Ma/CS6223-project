{"function_name": "decimal.Decimal.fma", "mutants": ["```python\n# property to violate: The output should be equal to the sum of the product of the first two arguments and the third argument, i.e., `self * other + third`.\nfrom hypothesis import given, strategies as st\nfrom decimal import Decimal\n\n@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_1(first, second, third):\n    result = Decimal(first).fma(second, third) + 1  # Adding 1 to violate the property\n    expected = Decimal(first) * Decimal(second) + Decimal(third)\n    assert result == expected\n\n@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_2(first, second, third):\n    result = Decimal(first).fma(second, third) * 2  # Multiplying by 2 to violate the property\n    expected = Decimal(first) * Decimal(second) + Decimal(third)\n    assert result == expected\n\n@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_3(first, second, third):\n    result = Decimal(first).fma(second, third) - 100  # Subtracting 100 to violate the property\n    expected = Decimal(first) * Decimal(second) + Decimal(third)\n    assert result == expected\n\n@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_4(first, second, third):\n    result = Decimal(first).fma(second, third) + Decimal('0.5')  # Adding 0.5 to violate the property\n    expected = Decimal(first) * Decimal(second) + Decimal(third)\n    assert result == expected\n\n@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_5(first, second, third):\n    result = Decimal(first).fma(second, third) - Decimal('1e50')  # Subtracting a large number to violate the property\n    expected = Decimal(first) * Decimal(second) + Decimal(third)\n    assert result == expected\n```"], "property": "The output should be equal to the sum of the product of the first two arguments and the third argument, i.e., `self * other + third`.", "pbt": "@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_output_equals_product_plus_third_property(first, second, third):\n    result = Decimal(first).fma(second, third)\n    expected = Decimal(first) * Decimal(second) + Decimal(third)\n    assert result == expected", "properties": ["1. The output should be equal to the sum of the product of the first two arguments and the third argument, i.e., `self * other + third`.", "2. The output should be a `Decimal` type, ensuring the result maintains the precision characteristics of the `Decimal` class.", "4. The output should be consistent with the commutative property of addition, meaning `fma(other, third)` should yield the same result as `fma(third, other)` when the roles of the second and third arguments are swapped.", "5. The output should not be affected by the rounding mode of the context, as the operation is designed to perform the multiplication without rounding the intermediate product."]}
{"function_name": "decimal.Decimal.fma", "mutants": ["```python\n# property to violate: The output should be a `Decimal` type, ensuring the result maintains the precision characteristics of the `Decimal` class.\nfrom hypothesis import given, strategies as st\nimport decimal\n\n@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_1(first, second):\n    result = str(Decimal(first).fma(second, Decimal(0)))  # Change output to string\n    assert isinstance(result, Decimal)\n\n@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_2(first, second):\n    result = float(Decimal(first).fma(second, Decimal(0)))  # Change output to float\n    assert isinstance(result, Decimal)\n\n@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_3(first, second):\n    result = int(Decimal(first).fma(second, Decimal(0)))  # Change output to int\n    assert isinstance(result, Decimal)\n\n@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_4(first, second):\n    result = Decimal(first).fma(second, Decimal(0)).to_eng_string()  # Change output to engineering string\n    assert isinstance(result, Decimal)\n\n@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_5(first, second):\n    result = Decimal(first).fma(second, Decimal(0)).quantize(Decimal('1.0'))  # Change output to a rounded Decimal\n    assert isinstance(result, Decimal)\n```"], "property": "The output should be a `Decimal` type, ensuring the result maintains the precision characteristics of the `Decimal` class.", "pbt": "@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_output_is_decimal_type_property(first, second):\n    result = Decimal(first).fma(second, Decimal(0))\n    assert isinstance(result, Decimal)", "properties": ["1. The output should be equal to the sum of the product of the first two arguments and the third argument, i.e., `self * other + third`.", "2. The output should be a `Decimal` type, ensuring the result maintains the precision characteristics of the `Decimal` class.", "4. The output should be consistent with the commutative property of addition, meaning `fma(other, third)` should yield the same result as `fma(third, other)` when the roles of the second and third arguments are swapped.", "5. The output should not be affected by the rounding mode of the context, as the operation is designed to perform the multiplication without rounding the intermediate product."]}
{"function_name": "decimal.Decimal.fma", "mutants": ["```python\n# property to violate: The output should be consistent with the commutative property of addition, meaning `fma(other, third)` should yield the same result as `fma(third, other)` when the roles of the second and third arguments are swapped.\nfrom hypothesis import given, strategies as st\nfrom decimal import Decimal\n\n@given(st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_1(first):\n    result = Decimal(first).fma(Decimal(3), Decimal(0))\n    expected = Decimal(first) * Decimal(3) + Decimal(1)  # Violate by adding 1\n    assert result == expected\n\n@given(st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_2(first):\n    result = Decimal(first).fma(Decimal(3), Decimal(0))\n    expected = Decimal(first) * Decimal(3) - Decimal(1)  # Violate by subtracting 1\n    assert result == expected\n\n@given(st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_3(first):\n    result = Decimal(first).fma(Decimal(3), Decimal(0))\n    expected = Decimal(first) * Decimal(3) * Decimal(2)  # Violate by multiplying by 2\n    assert result == expected\n\n@given(st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_4(first):\n    result = Decimal(first).fma(Decimal(3), Decimal(0))\n    expected = Decimal(first) * Decimal(3) + Decimal(3)  # Violate by adding 3\n    assert result == expected\n\n@given(st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_5(first):\n    result = Decimal(first).fma(Decimal(3), Decimal(0))\n    expected = Decimal(first) * Decimal(3) / Decimal(2)  # Violate by dividing by 2\n    assert result == expected\n```"], "property": "The output should be consistent with the commutative property of addition, meaning `fma(other, third)` should yield the same result as `fma(third, other)` when the roles of the second and third arguments are swapped.", "pbt": "@given(st.decimals(min_value=-1e100, max_value=1e100))\ndef test_output_with_zero_third_property(first):\n    result = Decimal(first).fma(Decimal(3), Decimal(0))\n    expected = Decimal(first) * Decimal(3)\n    assert result == expected", "properties": ["1. The output should be equal to the sum of the product of the first two arguments and the third argument, i.e., `self * other + third`.", "2. The output should be a `Decimal` type, ensuring the result maintains the precision characteristics of the `Decimal` class.", "4. The output should be consistent with the commutative property of addition, meaning `fma(other, third)` should yield the same result as `fma(third, other)` when the roles of the second and third arguments are swapped.", "5. The output should not be affected by the rounding mode of the context, as the operation is designed to perform the multiplication without rounding the intermediate product."]}
{"function_name": "decimal.Decimal.fma", "mutants": ["```python\n# property to violate: The output should not be affected by the rounding mode of the context, as the operation is designed to perform the multiplication without rounding the intermediate product.\nfrom hypothesis import given, strategies as st\nfrom decimal import Decimal\n\n@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_1(first, third):\n    result1 = Decimal(first).fma(third, Decimal(0))\n    result2 = Decimal(third).fma(first, Decimal(0))\n    assert result1 != result2  # Violation: results should be unequal\n\n@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_2(first, third):\n    result1 = Decimal(first).fma(third, Decimal(0))\n    result2 = Decimal(third).fma(first, Decimal(0))\n    assert result1 == result2 + Decimal(1)  # Violation: result1 is off by 1\n\n@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_3(first, third):\n    result1 = Decimal(first).fma(third, Decimal(0))\n    result2 = Decimal(third).fma(first, Decimal(0))\n    assert result1 == result2 * Decimal(2)  # Violation: result1 is double result2\n\n@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_4(first, third):\n    result1 = Decimal(first).fma(third, Decimal(0))\n    result2 = Decimal(third).fma(first, Decimal(0))\n    assert result1 == result2 - Decimal(5)  # Violation: result1 is less than result2 by 5\n\n@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_violation_of_decimal_Decimal_fma_5(first, third):\n    result1 = Decimal(first).fma(third, Decimal(0))\n    result2 = Decimal(third).fma(first, Decimal(0))\n    assert result1 == result2 + Decimal('0.1')  # Violation: result1 is greater than result2 by 0.1\n```"], "property": "The output should not be affected by the rounding mode of the context, as the operation is designed to perform the multiplication without rounding the intermediate product.", "pbt": "@given(st.decimals(min_value=-1e100, max_value=1e100), \n       st.decimals(min_value=-1e100, max_value=1e100))\ndef test_commutative_property_of_addition(first, third):\n    result1 = Decimal(first).fma(third, Decimal(0))\n    result2 = Decimal(third).fma(first, Decimal(0))\n    assert result1 == result2", "properties": ["1. The output should be equal to the sum of the product of the first two arguments and the third argument, i.e., `self * other + third`.", "2. The output should be a `Decimal` type, ensuring the result maintains the precision characteristics of the `Decimal` class.", "4. The output should be consistent with the commutative property of addition, meaning `fma(other, third)` should yield the same result as `fma(third, other)` when the roles of the second and third arguments are swapped.", "5. The output should not be affected by the rounding mode of the context, as the operation is designed to perform the multiplication without rounding the intermediate product."]}
