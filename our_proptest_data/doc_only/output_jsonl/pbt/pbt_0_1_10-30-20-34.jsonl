{"function_name": "numpy.resize", "pbt": ["```python\nfrom hypothesis import given, strategies as st\nimport numpy as np\n\n@given(st.lists(st.lists(st.integers())), st.tuples(st.integers(min_value=1), st.integers(min_value=1)))\ndef test_output_array_size_property(data, new_shape):\n    a = np.array(data)\n    reshaped_array = np.resize(a, new_shape)\n    assert reshaped_array.size == new_shape[0] * new_shape[1]\n# End program\n\n@given(st.lists(st.lists(st.integers())), st.tuples(st.integers(min_value=1), st.integers(min_value=1)))\ndef test_output_array_repeats_property(data, new_shape):\n    a = np.array(data)\n    reshaped_array = np.resize(a, new_shape)\n    if reshaped_array.size > a.size:\n        repeated_elements = (a.flatten() * (reshaped_array.size // a.size + 1))[:reshaped_array.size]\n        assert np.array_equal(reshaped_array.flatten(), repeated_elements)\n# End program\n\n@given(st.lists(st.lists(st.integers())))\ndef test_output_array_dtype_property(data):\n    a = np.array(data)\n    reshaped_array = np.resize(a, (2, 3))  # Example shape\n    assert reshaped_array.dtype == a.dtype\n# End program\n\n@given(st.lists(st.lists(st.integers())), st.tuples(st.integers(min_value=1), st.integers(min_value=1)))\ndef test_output_array_c_order_property(data, new_shape):\n    a = np.array(data)\n    reshaped_array = np.resize(a, new_shape)\n    original_flat = a.flatten()\n    assert np.array_equal(reshaped_array.flatten(), np.tile(original_flat, (reshaped_array.size // original_flat.size + 1))[:reshaped_array.size])\n# End program\n\n@given(st.lists(st.lists(st.integers())), st.tuples(st.integers(min_value=1), st.integers(min_value=1)))\ndef test_output_array_truncation_property(data, new_shape):\n    a = np.array(data)\n    reshaped_array = np.resize(a, new_shape)\n    original_flat = a.flatten()\n    if reshaped_array.size < a.size:\n        assert np.array_equal(reshaped_array.flatten(), original_flat[:reshaped_array.size])\n# End program\n```", "```python\nfrom hypothesis import given, strategies as st\nimport numpy as np\n\n@given(a=st.lists(st.integers()), new_shape=st.tuples(st.integers(min_value=1), st.integers(min_value=1)))\ndef test_total_elements_property(a, new_shape):\n    array_a = np.array(a)\n    resized_array = np.resize(array_a, new_shape)\n    assert resized_array.size == np.prod(new_shape)\n# End program\n\n@given(a=st.lists(st.integers()), new_shape=st.tuples(st.integers(min_value=1), st.integers(min_value=1)))\ndef test_repeated_elements_property(a, new_shape):\n    array_a = np.array(a)\n    resized_array = np.resize(array_a, new_shape)\n    if resized_array.size > array_a.size:\n        repeated_elements = (a * (resized_array.size // array_a.size + 1))[:resized_array.size]\n        assert np.array_equal(resized_array.flatten(), repeated_elements)\n# End program\n\n@given(a=st.lists(st.integers()), new_shape=st.tuples(st.integers(min_value=1), st.integers(min_value=1)))\ndef test_data_type_property(a, new_shape):\n    array_a = np.array(a)\n    resized_array = np.resize(array_a, new_shape)\n    assert resized_array.dtype == array_a.dtype\n# End program\n\n@given(a=st.lists(st.integers()), new_shape=st.tuples(st.integers(min_value=1), st.integers(min_value=1)))\ndef test_c_order_property(a, new_shape):\n    array_a = np.array(a)\n    resized_array = np.resize(array_a, new_shape)\n    flat_a = array_a.flatten()\n    size = min(len(flat_a), resized_array.size)\n    assert np.array_equal(resized_array.flatten()[:size], flat_a[:size])\n# End program\n\n@given(a=st.lists(st.integers()), new_shape=st.tuples(st.integers(min_value=1), st.integers(min_value=1)))\ndef test_truncated_elements_property(a, new_shape):\n    array_a = np.array(a)\n    resized_array = np.resize(array_a, new_shape)\n    if resized_array.size < array_a.size:\n        assert np.array_equal(resized_array, array_a.flatten()[:resized_array.size])\n# End program\n```", "```python\nfrom hypothesis import given, strategies as st\nimport numpy as np\n\n@given(st.lists(st.integers(), min_size=1, max_size=100), \n       st.tuples(st.integers(min_value=1), st.integers(min_value=1)))\ndef test_total_number_of_elements_property(arr, new_shape):\n    a = np.array(arr).reshape(-1)  # Convert to 1D array\n    resized_array = np.resize(a, new_shape)\n    assert resized_array.size == np.prod(new_shape)\n\n@given(st.lists(st.integers(), min_size=1, max_size=100), \n       st.tuples(st.integers(min_value=1, max_value=10), st.integers(min_value=1, max_value=10)))\ndef test_repeated_elements_property(arr, new_shape):\n    a = np.array(arr).reshape(-1)  # Convert to 1D array\n    resized_array = np.resize(a, new_shape)\n    if resized_array.size > a.size:\n        assert (resized_array.flatten() == \n                np.tile(a.flatten(), (resized_array.size // a.size + 1))[:resized_array.size]).all()\n\n@given(st.lists(st.integers(), min_size=1, max_size=100), \n       st.tuples(st.integers(min_value=1), st.integers(min_value=1)))\ndef test_data_type_property(arr, new_shape):\n    a = np.array(arr).reshape(-1)  # Convert to 1D array\n    resized_array = np.resize(a, new_shape)\n    assert resized_array.dtype == a.dtype\n\n@given(st.lists(st.integers(), min_size=1, max_size=100), \n       st.tuples(st.integers(min_value=1, max_value=10), st.integers(min_value=1, max_value=10)))\ndef test_c_order_property(arr, new_shape):\n    a = np.array(arr).reshape(-1)  # Convert to 1D array\n    resized_array = np.resize(a, new_shape)\n    expected_array = np.empty(new_shape, dtype=a.dtype)\n    for i in range(np.prod(new_shape)):\n        expected_array.flat[i] = a.flat[i % a.size]\n    assert np.array_equal(resized_array, expected_array)\n\n@given(st.lists(st.integers(), min_size=1, max_size=100), \n       st.tuples(st.integers(min_value=1), st.integers(min_value=1)))\ndef test_truncated_elements_property(arr, new_shape):\n    a = np.array(arr).reshape(-1)  # Convert to 1D array\n    resized_array = np.resize(a, new_shape)\n    if resized_array.size < a.size:\n        assert np.array_equal(resized_array, a.flat[:resized_array.size])\n# End program\n```", "```python\nfrom hypothesis import given, strategies as st\nimport numpy as np\n\n@given(st.lists(st.integers(), min_size=1, max_size=100), st.tuples(st.integers(min_value=1, max_value=10), st.integers(min_value=1, max_value=10)))\ndef test_total_elements_property(data, new_shape):\n    a = np.array(data).reshape(-1)\n    resized_array = np.resize(a, new_shape)\n    assert resized_array.size == np.prod(new_shape)\n\n@given(st.lists(st.integers(), min_size=1, max_size=100), st.tuples(st.integers(min_value=1), st.integers(min_value=1, max_value=100)))\ndef test_repeated_copies_property(data, new_shape):\n    a = np.array(data).reshape(-1)\n    resized_array = np.resize(a, new_shape)\n    if resized_array.size > a.size:\n        assert all(resized_array[i] == a[i % a.size] for i in range(resized_array.size))\n\n@given(st.lists(st.integers(), min_size=1, max_size=100))\ndef test_data_type_property(data):\n    a = np.array(data)\n    resized_array = np.resize(a, (2, 3))\n    assert resized_array.dtype == a.dtype\n\n@given(st.lists(st.integers(), min_size=1, max_size=100))\ndef test_c_order_filling_property(data):\n    a = np.array(data).reshape(-1)\n    resized_array = np.resize(a, (2, 3))\n    expected_filling = np.array(data).flatten()\n    assert (resized_array.flatten() == np.resize(expected_filling, resized_array.size)).all()\n\n@given(st.lists(st.integers(), min_size=1, max_size=100), st.tuples(st.integers(min_value=1), st.integers(min_value=1, max_value=100)))\ndef test_truncation_property(data, new_shape):\n    a = np.array(data).reshape(-1)\n    resized_array = np.resize(a, new_shape)\n    if resized_array.size < a.size:\n        assert (resized_array.flatten() == a.flatten()[:resized_array.size]).all()\n# End program\n```", "```python\nfrom hypothesis import given, strategies as st\nimport numpy as np\n\n@given(st.lists(st.lists(st.integers())), st.tuples(st.integers(min_value=1), st.integers(min_value=1)))\ndef test_total_elements_property(data, new_shape):\n    a = np.array(data)\n    resized_array = np.resize(a, new_shape)\n    assert resized_array.size == np.prod(new_shape)\n\n@given(st.lists(st.lists(st.integers())), st.tuples(st.integers(min_value=1), st.integers(min_value=1)))\ndef test_repeated_elements_property(data, new_shape):\n    a = np.array(data)\n    resized_array = np.resize(a, new_shape)\n    if resized_array.size > a.size:\n        expected_array = np.resize(a, resized_array.shape)\n        assert np.array_equal(resized_array, expected_array)\n\n@given(st.lists(st.lists(st.integers())), st.tuples(st.integers(min_value=1), st.integers(min_value=1)))\ndef test_data_type_property(data, new_shape):\n    a = np.array(data)\n    resized_array = np.resize(a, new_shape)\n    assert resized_array.dtype == a.dtype\n\n@given(st.lists(st.lists(st.integers())), st.tuples(st.integers(min_value=1), st.integers(min_value=1)))\ndef test_c_order_property(data, new_shape):\n    a = np.array(data)\n    resized_array = np.resize(a, new_shape)\n    flat_a = a.flatten(order='C')\n    expected_flat = np.resize(flat_a, resized_array.size)\n    assert np.array_equal(resized_array.flatten(order='C'), expected_flat)\n\n@given(st.lists(st.lists(st.integers())), st.tuples(st.integers(max_value=1), st.integers(min_value=1)))\ndef test_truncated_elements_property(data, new_shape):\n    a = np.array(data)\n    if np.prod(new_shape) < a.size:\n        resized_array = np.resize(a, new_shape)\n        assert resized_array.size == np.prod(new_shape)\n        assert np.array_equal(resized_array.flatten()[:resized_array.size], a.flatten()[:resized_array.size])\n\n# End program\n```"], "properties": ["1. The total number of elements in the output array must equal the product of the dimensions specified in `new_shape`, regardless of the input array's size.\n\n2. If the `new_shape` specifies a size larger than the original array, the output array should contain repeated copies of the original array's elements, filling the additional space as necessary.\n\n3. The output array must maintain the same data type as the input array.\n\n4. The output array should be filled with elements in C-order, meaning that the elements are filled row-wise from the original array.\n\n5. If the `new_shape` specifies a size smaller than the original array, the output array should contain only the first elements of the original array, truncated to fit the new size."], "api_doc": "numpy.resize\nnumpy.resize(a, new_shape)[source]\nReturn a new array with the specified shape.\n\nIf the new array is larger than the original array, then the new array is filled with repeated copies of a. Note that this behavior is different from a.resize(new_shape) which fills with zeros instead of repeated copies of a.\n\nParameters\n:\na\narray_like\nArray to be resized.\n\nnew_shape\nint or tuple of int\nShape of resized array.\n\nReturns\n:\nreshaped_array\nndarray\nThe new array is formed from the data in the old array, repeated if necessary to fill out the required number of elements. The data are repeated iterating over the array in C-order.\n\nSee also\n\nnumpy.reshape\nReshape an array without changing the total size.\n\nnumpy.pad\nEnlarge and pad an array.\n\nnumpy.repeat\nRepeat elements of an array.\n\nndarray.resize\nresize an array in-place.\n\nNotes\n\nWhen the total size of the array does not change reshape should be used. In most other cases either indexing (to reduce the size) or padding (to increase the size) may be a more appropriate solution.\n\nWarning: This functionality does not consider axes separately, i.e. it does not apply interpolation/extrapolation. It fills the return array with the required number of elements, iterating over a in C-order, disregarding axes (and cycling back from the start if the new shape is larger). This functionality is therefore not suitable to resize images, or data where each axis represents a separate and distinct entity.\n\nExamples\n\nimport numpy as np\na = np.array([[0,1],[2,3]])\nnp.resize(a,(2,3))\narray([[0, 1, 2],\n       [3, 0, 1]])\nnp.resize(a,(1,4))\narray([[0, 1, 2, 3]])\nnp.resize(a,(2,4))\narray([[0, 1, 2, 3],\n       [0, 1, 2, 3]])", "api_code": "@array_function_dispatch(_resize_dispatcher)\ndef resize(a, new_shape):\n    if isinstance(new_shape, (int, nt.integer)):\n        new_shape = (new_shape,)\n\n    a = ravel(a)\n\n    new_size = 1\n    for dim_length in new_shape:\n        new_size *= dim_length\n        if dim_length < 0:\n            raise ValueError(\n                'all elements of `new_shape` must be non-negative'\n            )\n\n    if a.size == 0 or new_size == 0:\n        # First case must zero fill. The second would have repeats == 0.\n        return np.zeros_like(a, shape=new_shape)\n\n    repeats = -(-new_size // a.size)  # ceil division\n    a = concatenate((a,) * repeats)[:new_size]\n\n    return reshape(a, new_shape)"}
