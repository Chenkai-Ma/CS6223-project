classcryptography.fernet.Fernet(key)[source]
This class provides both encryption and decryption facilities.

from cryptography.fernet import Fernet
key = Fernet.generate_key()
f = Fernet(key)
token = f.encrypt(b"my deep dark secret")
token
b'...'
f.decrypt(token)
b'my deep dark secret'
Parameters
:
key (bytes or str) – A URL-safe base64-encoded 32-byte key. This must be kept secret. Anyone with this key is able to create and read messages.

classmethodgenerate_key()[source]
Generates a fresh fernet key. Keep this some place safe! If you lose it you’ll no longer be able to decrypt messages; if anyone else gains access to it, they’ll be able to decrypt all of your messages, and they’ll also be able forge arbitrary messages that will be authenticated and decrypted.

encrypt(data)[source]
Encrypts data passed. The result of this encryption is known as a “Fernet token” and has strong privacy and authenticity guarantees.

Parameters
:
data (bytes) – The message you would like to encrypt.

Returns bytes
:
A secure message that cannot be read or altered without the key. It is URL-safe base64-encoded. This is referred to as a “Fernet token”.

Raises
:
TypeError – This exception is raised if data is not bytes.

Note

The encrypted message contains the current time when it was generated in plaintext, the time a message was created will therefore be visible to a possible attacker.

encrypt_at_time(data, current_time)[source]
New in version 3.0.

Encrypts data passed using explicitly passed current time. See encrypt() for the documentation of the data parameter, the return type and the exceptions raised.

The motivation behind this method is for the client code to be able to test token expiration. Since this method can be used in an insecure manner one should make sure the correct time (int(time.time())) is passed as current_time outside testing.

Parameters
:
current_time (int) – The current time.

Note

Similarly to encrypt() the encrypted message contains the timestamp in plaintext, in this case the timestamp is the value of the current_time parameter.

decrypt(token, ttl=None)[source]
Decrypts a Fernet token. If successfully decrypted you will receive the original plaintext as the result, otherwise an exception will be raised. It is safe to use this data immediately as Fernet verifies that the data has not been tampered with prior to returning it.

Parameters
:
token (bytes or str) – The Fernet token. This is the result of calling encrypt().

ttl (int) – Optionally, the number of seconds old a message may be for it to be valid. If the message is older than ttl seconds (from the time it was originally created) an exception will be raised. If ttl is not provided (or is None), the age of the message is not considered.

Returns bytes
:
The original plaintext.

Raises
:
cryptography.fernet.InvalidToken – If the token is in any way invalid, this exception is raised. A token may be invalid for a number of reasons: it is older than the ttl, it is malformed, or it does not have a valid signature.

TypeError – This exception is raised if token is not bytes or str.

decrypt_at_time(token, ttl, current_time)[source]
New in version 3.0.

Decrypts a token using explicitly passed current time. See decrypt() for the documentation of the token and ttl parameters (ttl is required here), the return type and the exceptions raised.

The motivation behind this method is for the client code to be able to test token expiration. Since this method can be used in an insecure manner one should make sure the correct time (int(time.time())) is passed as current_time outside testing.

Parameters
:
current_time (int) – The current time.
