from hypothesis import given, strategies as st
from cryptography.fernet import Fernet, InvalidToken

# Summary: This strategy aims to generate a wide variety of inputs for Fernet.decrypt, including:
# - Valid Fernet tokens: Generated by encrypting random data with a randomly generated key.
# - Invalid tokens: Created by manipulating valid tokens (e.g., altering bytes, changing length).
# - Edge cases: Empty tokens, tokens with extreme lengths, non-bytes input.
@given(st.data())
def test_cryptography_fernet_fernet_decrypt(data):
    # Generate a random Fernet key
    key = Fernet.generate_key()
    f = Fernet(key)

    # Generate valid and invalid tokens
    valid_token = f.encrypt(data.draw(st.binary()))

    # Manipulate the valid token to create invalid ones
    invalid_tokens = [
        b"",  # Empty token
        valid_token[:-1],  # Truncated token
        valid_token + b"a",  # Token with extra byte
        data.draw(st.binary(min_size=len(valid_token) + 1)),  # Token with different length
        data.draw(st.text().encode()),  # Token with non-base64 characters
    ]

    # Test decryption with valid token
    decrypted = f.decrypt(valid_token)
    assert decrypted == f.encrypt(decrypted)  # Check that decrypting the decrypted data gives back the original

    # Test decryption with invalid tokens and edge cases
    for token in invalid_tokens + [None, 123, "not bytes"]:
        with pytest.raises(InvalidToken):
            f.decrypt(token)
# End program