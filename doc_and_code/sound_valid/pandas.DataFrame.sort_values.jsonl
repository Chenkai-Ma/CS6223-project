{"function_name": "pandas.DataFrame.sort_values", "properties": [], "pbt": [], "api_doc": "pandas.DataFrame.sort_values\nDataFrame.sort_values(by, *, axis=0, ascending=True, inplace=False, kind='quicksort', na_position='last', ignore_index=False, key=None)[source]\nSort by the values along either axis.\n\nParameters\n:\nby\nstr or list of str\nName or list of names to sort by.\n\nif axis is 0 or \u2018index\u2019 then by may contain index levels and/or column labels.\n\nif axis is 1 or \u2018columns\u2019 then by may contain column levels and/or index labels.\n\naxis\n\u201c{0 or \u2018index\u2019, 1 or \u2018columns\u2019}\u201d, default 0\nAxis to be sorted.\n\nascending\nbool or list of bool, default True\nSort ascending vs. descending. Specify list for multiple sort orders. If this is a list of bools, must match the length of the by.\n\ninplace\nbool, default False\nIf True, perform operation in-place.\n\nkind\n{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, default \u2018quicksort\u2019\nChoice of sorting algorithm. See also numpy.sort() for more information. mergesort and stable are the only stable algorithms. For DataFrames, this option is only applied when sorting on a single column or label.\n\nna_position\n{\u2018first\u2019, \u2018last\u2019}, default \u2018last\u2019\nPuts NaNs at the beginning if first; last puts NaNs at the end.\n\nignore_index\nbool, default False\nIf True, the resulting axis will be labeled 0, 1, \u2026, n - 1.\n\nkey\ncallable, optional\nApply the key function to the values before sorting. This is similar to the key argument in the builtin sorted() function, with the notable difference that this key function should be vectorized. It should expect a Series and return a Series with the same shape as the input. It will be applied to each column in by independently.\n\nReturns\n:\nDataFrame or None\nDataFrame with sorted values or None if inplace=True.\n\nSee also\n\nDataFrame.sort_index\nSort a DataFrame by the index.\n\nSeries.sort_values\nSimilar method for a Series.\n\nExamples\n\ndf = pd.DataFrame({\n    'col1': ['A', 'A', 'B', np.nan, 'D', 'C'],\n    'col2': [2, 1, 9, 8, 7, 4],\n    'col3': [0, 1, 9, 4, 2, 3],\n    'col4': ['a', 'B', 'c', 'D', 'e', 'F']\n})\ndf\n  col1  col2  col3 col4\n0    A     2     0    a\n1    A     1     1    B\n2    B     9     9    c\n3  NaN     8     4    D\n4    D     7     2    e\n5    C     4     3    F\nSort by col1\n\ndf.sort_values(by=['col1'])\n  col1  col2  col3 col4\n0    A     2     0    a\n1    A     1     1    B\n2    B     9     9    c\n5    C     4     3    F\n4    D     7     2    e\n3  NaN     8     4    D\nSort by multiple columns\n\ndf.sort_values(by=['col1', 'col2'])\n  col1  col2  col3 col4\n1    A     1     1    B\n0    A     2     0    a\n2    B     9     9    c\n5    C     4     3    F\n4    D     7     2    e\n3  NaN     8     4    D\nSort Descending\n\ndf.sort_values(by='col1', ascending=False)\n  col1  col2  col3 col4\n4    D     7     2    e\n5    C     4     3    F\n2    B     9     9    c\n0    A     2     0    a\n1    A     1     1    B\n3  NaN     8     4    D\nPutting NAs first\n\ndf.sort_values(by='col1', ascending=False, na_position='first')\n  col1  col2  col3 col4\n3  NaN     8     4    D\n4    D     7     2    e\n5    C     4     3    F\n2    B     9     9    c\n0    A     2     0    a\n1    A     1     1    B\nSorting with a key function\n\ndf.sort_values(by='col4', key=lambda col: col.str.lower())\n   col1  col2  col3 col4\n0    A     2     0    a\n1    A     1     1    B\n2    B     9     9    c\n3  NaN     8     4    D\n4    D     7     2    e\n5    C     4     3    F\nNatural sort with the key argument, using the natsort <https://github.com/SethMMorton/natsort> package.\n\ndf = pd.DataFrame({\n   \"time\": ['0hr', '128hr', '72hr', '48hr', '96hr'],\n   \"value\": [10, 20, 30, 40, 50]\n})\ndf\n    time  value\n0    0hr     10\n1  128hr     20\n2   72hr     30\n3   48hr     40\n4   96hr     50\nfrom natsort import index_natsorted\ndf.sort_values(\n    by=\"time\",\n    key=lambda x: np.argsort(index_natsorted(df[\"time\"]))\n)\n    time  value\n0    0hr     10\n3   48hr     40\n2   72hr     30\n4   96hr     50\n1  128hr     20", "api_code": "def sort_values(\n    self,\n    by: IndexLabel,\n    *,\n    axis: Axis = 0,\n    ascending: bool | list[bool] | tuple[bool, ...] = True,\n    inplace: bool = False,\n    kind: SortKind = \"quicksort\",\n    na_position: str = \"last\",\n    ignore_index: bool = False,\n    key: ValueKeyFunc | None = None,\n) -> DataFrame | None:\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    axis = self._get_axis_number(axis)\n    ascending = validate_ascending(ascending)\n    if not isinstance(by, list):\n        by = [by]\n    # error: Argument 1 to \"len\" has incompatible type \"Union[bool, List[bool]]\";\n    # expected \"Sized\"\n    if is_sequence(ascending) and (\n        len(by) != len(ascending)  # type: ignore[arg-type]\n    ):\n        # error: Argument 1 to \"len\" has incompatible type \"Union[bool,\n        # List[bool]]\"; expected \"Sized\"\n        raise ValueError(\n            f\"Length of ascending ({len(ascending)})\"  # type: ignore[arg-type]\n            f\" != length of by ({len(by)})\"\n        )\n    if len(by) > 1:\n        keys = [self._get_label_or_level_values(x, axis=axis) for x in by]\n\n        # need to rewrap columns in Series to apply key function\n        if key is not None:\n            # error: List comprehension has incompatible type List[Series];\n            # expected List[ndarray]\n            keys = [\n                Series(k, name=name)  # type: ignore[misc]\n                for (k, name) in zip(keys, by)\n            ]\n\n        indexer = lexsort_indexer(\n            keys, orders=ascending, na_position=na_position, key=key\n        )\n    elif len(by):\n        # len(by) == 1\n\n        k = self._get_label_or_level_values(by[0], axis=axis)\n\n        # need to rewrap column in Series to apply key function\n        if key is not None:\n            # error: Incompatible types in assignment (expression has type\n            # \"Series\", variable has type \"ndarray\")\n            k = Series(k, name=by[0])  # type: ignore[assignment]\n\n        if isinstance(ascending, (tuple, list)):\n            ascending = ascending[0]\n\n        indexer = nargsort(\n            k, kind=kind, ascending=ascending, na_position=na_position, key=key\n        )\n    else:\n        if inplace:\n            return self._update_inplace(self)\n        else:\n            return self.copy(deep=None)\n\n    if is_range_indexer(indexer, len(indexer)):\n        result = self.copy(deep=(not inplace and not using_copy_on_write()))\n        if ignore_index:\n            result.index = default_index(len(result))\n\n        if inplace:\n            return self._update_inplace(result)\n        else:\n            return result\n\n    new_data = self._mgr.take(\n        indexer, axis=self._get_block_manager_axis(axis), verify=False\n    )\n\n    if ignore_index:\n        new_data.set_axis(\n            self._get_block_manager_axis(axis), default_index(len(indexer))\n        )\n\n    result = self._constructor_from_mgr(new_data, axes=new_data.axes)\n    if inplace:\n        return self._update_inplace(result)\n    else:\n        return result.__finalize__(self, method=\"sort_values\")"}