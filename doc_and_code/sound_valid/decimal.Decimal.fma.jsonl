{"function_name": "decimal.Decimal.fma", "properties": ["2. If either `self` or `other` is a special value (like NaN or Infinity), the output should conform to the rules of arithmetic for those special values, returning appropriate results or raising errors as defined."], "pbt": ["@given(st.decimals(), st.decimals(), st.decimals())\ndef test_special_values_property(self, other, third):\n    context = getcontext()\n    if self.is_nan() or other.is_nan():\n        try:\n            result = self.fma(other, third)\n            assert result.is_nan()\n        except InvalidOperation:\n            pass  # Expected behavior, skip further checks\n    elif self.is_infinite() or other.is_infinite():\n        result = self.fma(other, third)\n        # Check that the result is either infinity or a valid number\n        assert result.is_infinite() or isinstance(result, Decimal)"], "api_doc": "fma(other, third, context=None)\nFused multiply-add. Return self*other+third with no rounding of the intermediate product self*other.\n\n>>>\nDecimal(2).fma(3, 5)\nDecimal('11')", "api_code": "def fma(self, other, third, context=None):\n    if self._is_special or other._is_special:\n        if context is None:\n            context = getcontext()\n        if self._exp == 'N':\n            return context._raise_error(InvalidOperation, 'sNaN', self)\n        if other._exp == 'N':\n            return context._raise_error(InvalidOperation, 'sNaN', other)\n        if self._exp == 'n':\n            product = self\n        elif other._exp == 'n':\n            product = other\n        elif self._exp == 'F':\n            if not other:\n                return context._raise_error(InvalidOperation,\n                                            'INF * 0 in fma')\n            product = _SignedInfinity[self._sign ^ other._sign]\n        elif other._exp == 'F':\n            if not self:\n                return context._raise_error(InvalidOperation,\n                                            '0 * INF in fma')\n            product = _SignedInfinity[self._sign ^ other._sign]\n    else:\n        product = _dec_from_triple(self._sign ^ other._sign,\n                                    str(int(self._int) * int(other._int)),\n                                    self._exp + other._exp)\n\n    return product.__add__(third, context)"}