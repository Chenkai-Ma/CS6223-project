{"function_name": "datetime.datetime.combine", "properties": ["1. The year, month, and day of the output datetime object must match the year, month, and day of the input date object.", "2. The hour, minute, second, and microsecond of the output datetime object must match the corresponding time components of the input time object.", "3. If the tzinfo argument is provided, the tzinfo attribute of the output datetime object must match the provided tzinfo; otherwise, it must match the tzinfo attribute of the input time object.", "4. If the input date argument is a datetime object, the output datetime object must equal the input datetime object, ignoring its time components and tzinfo attributes.", "5. The output datetime object's fold attribute must match the fold attribute of the input time object."], "pbt": ["# Property 1: The year, month, and day of the output datetime object must match the year, month, and day of the input date object.\n@given(date=st.dates(), time=st.times())\ndef test_datetime_year_month_day_property(date, time):\n    combined = datetime.datetime.combine(date, time)\n    assert combined.year == date.year\n    assert combined.month == date.month\n    assert combined.day == date.day", "# Property 2: The hour, minute, second, and microsecond of the output datetime object must match the corresponding time components of the input time object.\n@given(date=st.dates(), time=st.times())\ndef test_datetime_hour_minute_second_microsecond_property(date, time):\n    combined = datetime.datetime.combine(date, time)\n    assert combined.hour == time.hour\n    assert combined.minute == time.minute\n    assert combined.second == time.second\n    assert combined.microsecond == time.microsecond", "@given(st.dates(), st.times(), st.one_of(st.none(), st.times()), st.booleans())\ndef test_tzinfo_property(date_input, time_input, tzinfo_input, use_tzinfo):\n    result = datetime.combine(date_input, time_input, tzinfo=tzinfo_input if use_tzinfo else None)\n    expected_tzinfo = tzinfo_input if use_tzinfo else time_input.tzinfo\n    assert result.tzinfo == expected_tzinfo", "# Property 4: If the input date argument is a datetime object, the output datetime object must equal the input datetime object, ignoring its time components and tzinfo attributes.\n@given(dt=st.datetimes())\ndef test_datetime_combining_datetime_property(dt):\n    combined = datetime.datetime.combine(dt.date(), dt.time())\n    assert combined.date() == dt.date()\n    assert combined.time() == dt.time()", "# Property 5: The output datetime object's fold attribute must match the fold attribute of the input time object.\n@given(date=st.dates(), time=st.times())\ndef test_datetime_fold_property(date, time):\n    combined = datetime.datetime.combine(date, time)\n    assert combined.fold == time.fold"], "api_doc": "classmethod datetime.combine(date, time, tzinfo=time.tzinfo)\nReturn a new datetime object whose date components are equal to the given date object\u2019s, and whose time components are equal to the given time object\u2019s. If the tzinfo argument is provided, its value is used to set the tzinfo attribute of the result, otherwise the tzinfo attribute of the time argument is used. If the date argument is a datetime object, its time components and tzinfo attributes are ignored.\n\nFor any datetime object d, d == datetime.combine(d.date(), d.time(), d.tzinfo).\n\nChanged in version 3.6: Added the tzinfo argument.", "api_code": "@classmethod\ndef combine(cls, date, time, tzinfo=True):\n    if not isinstance(date, _date_class):\n        raise TypeError(\"date argument must be a date instance\")\n    if not isinstance(time, _time_class):\n        raise TypeError(\"time argument must be a time instance\")\n    if tzinfo is True:\n        tzinfo = time.tzinfo\n    return cls(date.year, date.month, date.day,\n                time.hour, time.minute, time.second, time.microsecond,\n                tzinfo, fold=time.fold)"}