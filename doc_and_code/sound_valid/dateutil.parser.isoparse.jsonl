{"function_name": "dateutil.parser.isoparse", "properties": ["1. The output of the function is always a valid `datetime.datetime` object, representing a point in time that corresponds to the input ISO-8601 string.", "2. If the input string represents a date without a time portion, the time components of the output `datetime` object default to midnight (00:00:00).", "3. If the input string includes a time portion that specifies midnight as \"24:00\", the output `datetime` object should represent the next day at midnight (00:00:00).", "4. The output `datetime` object should correctly reflect any provided time zone offset, converting the time to UTC if necessary.", "5. The function should handle incomplete date formats gracefully, returning the earliest possible valid date for the unspecified components (e.g., for \"2023-01\", the output should default the day to the first of the month)."], "pbt": ["@given(st.text())\ndef test_output_is_valid_datetime_property(dt_str):\n    try:\n        result = isoparse(dt_str)\n        assert isinstance(result, datetime)\n    except ValueError:\n        pass  # It's acceptable for the input to raise a ValueError", "@given(st.text())\ndef test_default_time_to_midnight_property(dt_str):\n    if \"T\" not in dt_str and any(char.isdigit() for char in dt_str):\n        try:\n            result = isoparse(dt_str)\n            assert result.time() == datetime.min.time()  # Should default to midnight\n        except ValueError:\n            pass  # It's acceptable for the input to raise a ValueError", "@given(st.text())\ndef test_midnight_as_24_hours_property(dt_str):\n    if \"24:00\" in dt_str:\n        try:\n            result = isoparse(dt_str)\n            assert result.time() == datetime.min.time()  # Should represent the next day at midnight\n            assert result.date() == (datetime.strptime(dt_str.split(\"T\")[0], \"%Y-%m-%d\") + timedelta(days=1)).date()\n        except ValueError:\n            pass  # It's acceptable for the input to raise a ValueError", "@given(st.text())\ndef test_correct_time_zone_offset_property(dt_str):\n    try:\n        result = isoparse(dt_str)\n        # Verify if the output datetime reflects the time zone offset correctly\n        # This is a simplified check; in a real context, you would assert against known offsets\n        assert result.tzinfo is not None\n    except ValueError:\n        pass  # It's acceptable for the input to raise a ValueError", "@given(st.text())\ndef test_incomplete_dates_default_to_earliest_property(dt_str):\n    if any(char.isdigit() for char in dt_str):\n        try:\n            result = isoparse(dt_str)\n            # Check if the date defaults correctly (e.g., \"2023-01\" should yield 2023-01-01)\n            assert result.day == 1  # Assuming day is defaulted to 1 for incomplete dates\n        except ValueError:\n            pass  # It's acceptable for the input to raise a ValueError"], "api_doc": "parser.isoparse(dt_str)\uf0c1\nParse an ISO-8601 datetime string into a datetime.datetime.\n\nAn ISO-8601 datetime string consists of a date portion, followed optionally by a time portion - the date and time portions are separated by a single character separator, which is T in the official standard. Incomplete date formats (such as YYYY-MM) may not be combined with a time portion.\n\nSupported date formats are:\n\nCommon:\n\nYYYY\n\nYYYY-MM\n\nYYYY-MM-DD or YYYYMMDD\n\nUncommon:\n\nYYYY-Www or YYYYWww - ISO week (day defaults to 0)\n\nYYYY-Www-D or YYYYWwwD - ISO week and day\n\nThe ISO week and day numbering follows the same logic as datetime.date.isocalendar().\n\nSupported time formats are:\n\nhh\n\nhh:mm or hhmm\n\nhh:mm:ss or hhmmss\n\nhh:mm:ss.ssssss (Up to 6 sub-second digits)\n\nMidnight is a special case for hh, as the standard supports both 00:00 and 24:00 as a representation. The decimal separator can be either a dot or a comma.\n\nCaution\n\nSupport for fractional components other than seconds is part of the ISO-8601 standard, but is not currently implemented in this parser.\n\nSupported time zone offset formats are:\n\nZ (UTC)\n\n\u00b1HH:MM\n\n\u00b1HHMM\n\n\u00b1HH\n\nOffsets will be represented as dateutil.tz.tzoffset objects, with the exception of UTC, which will be represented as dateutil.tz.tzutc. Time zone offsets equivalent to UTC (such as +00:00) will also be represented as dateutil.tz.tzutc.\n\nParameters\n:\ndt_str \u2013 A string or stream containing only an ISO-8601 datetime string\n\nReturns\n:\nReturns a datetime.datetime representing the string. Unspecified components default to their lowest value.\n\nWarning\n\nAs of version 2.7.0, the strictness of the parser should not be considered a stable part of the contract. Any valid ISO-8601 string that parses correctly with the default settings will continue to parse correctly in future versions, but invalid strings that currently fail (e.g. 2017-01-01T00:00+00:00:00) are not guaranteed to continue failing in future versions if they encode a valid date.\n\nNew in version 2.7.0.", "api_code": "@_takes_ascii\ndef isoparse(self, dt_str):\n    components, pos = self._parse_isodate(dt_str)\n\n    if len(dt_str) > pos:\n        if self._sep is None or dt_str[pos:pos + 1] == self._sep:\n            components += self._parse_isotime(dt_str[pos + 1:])\n        else:\n            raise ValueError('String contains unknown ISO components')\n\n    if len(components) > 3 and components[3] == 24:\n        components[3] = 0\n        return datetime(*components) + timedelta(days=1)\n\n    return datetime(*components)"}