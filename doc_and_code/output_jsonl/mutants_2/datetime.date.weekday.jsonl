{"function_name": "datetime.date.weekday", "mutants": ["```python\n# property to violate: The output of the `weekday()` function is always an integer between 0 and 6, inclusive.\nfrom hypothesis import given, strategies as st\nimport datetime\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_1(date):\n    result = date.weekday() + 7  # This will always be >= 7\n    assert 0 <= result <= 6\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_2(date):\n    result = date.weekday() - 1  # This will always be <= -1\n    assert 0 <= result <= 6\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_3(date):\n    result = date.weekday() * 2  # This will be >= 0 but can be >= 12 for some dates\n    assert 0 <= result <= 6\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_4(date):\n    result = date.weekday() + 10  # This will always be >= 10\n    assert 0 <= result <= 6\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_5(date):\n    result = (date.weekday() % 7) + 6  # This will always be >= 6\n    assert 0 <= result <= 6\n```"], "property": "The output of the `weekday()` function is always an integer between 0 and 6, inclusive.", "pbt": "@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_output_range_property(date):\n    result = date.weekday()\n    assert 0 <= result <= 6", "properties": ["1. The output of the `weekday()` function is always an integer between 0 and 6, inclusive.", "2. The output for any given date remains consistent across multiple calls to `weekday()` for the same date.", "3. If the input date corresponds to a Monday, the output of `weekday()` should be 0.", "4. If the input date corresponds to a Sunday, the output of `weekday()` should be 6.", "5. The output of `weekday()` should exhibit a cyclic pattern, where consecutive days differ by 1, and the transition from Sunday (6) to Monday (0) wraps around."]}
{"function_name": "datetime.date.weekday", "mutants": ["```python\n# property to violate: The output for any given date remains consistent across multiple calls to `weekday()` for the same date.\nfrom hypothesis import given, strategies as st\nimport datetime\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_1(date):\n    result1 = date.weekday()\n    result2 = (result1 + 1) % 7  # Change the result to violate consistency\n    assert result1 == result2\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_2(date):\n    result1 = date.weekday()\n    result2 = result1 + 2  # Change the result to violate consistency\n    assert result1 == result2\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_3(date):\n    result1 = date.weekday()\n    result2 = result1 - 1 if result1 > 0 else 6  # Change the result to violate consistency\n    assert result1 == result2\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_4(date):\n    result1 = date.weekday()\n    result2 = 3  # Always return a constant value to violate consistency\n    assert result1 == result2\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_5(date):\n    result1 = date.weekday()\n    result2 = (result1 * 2) % 7  # Change the result to violate consistency\n    assert result1 == result2\n```"], "property": "The output for any given date remains consistent across multiple calls to `weekday()` for the same date.", "pbt": "@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_consistency_property(date):\n    result1 = date.weekday()\n    result2 = date.weekday()\n    assert result1 == result2", "properties": ["1. The output of the `weekday()` function is always an integer between 0 and 6, inclusive.", "2. The output for any given date remains consistent across multiple calls to `weekday()` for the same date.", "3. If the input date corresponds to a Monday, the output of `weekday()` should be 0.", "4. If the input date corresponds to a Sunday, the output of `weekday()` should be 6.", "5. The output of `weekday()` should exhibit a cyclic pattern, where consecutive days differ by 1, and the transition from Sunday (6) to Monday (0) wraps around."]}
{"function_name": "datetime.date.weekday", "mutants": ["```python\n# property to violate: If the input date corresponds to a Monday, the output of `weekday()` should be 0.\nfrom hypothesis import given, strategies as st\nimport datetime\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_1(date):\n    if date.weekday() == 0:  # If it's Monday\n        assert date.weekday() == 1  # Incorrectly asserting it should be 1 instead of 0\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_2(date):\n    if date.weekday() == 0:  # If it's Monday\n        assert date.weekday() == 2  # Incorrectly asserting it should be 2 instead of 0\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_3(date):\n    if date.weekday() == 0:  # If it's Monday\n        assert date.weekday() == 3  # Incorrectly asserting it should be 3 instead of 0\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_4(date):\n    if date.weekday() == 0:  # If it's Monday\n        assert date.weekday() == 4  # Incorrectly asserting it should be 4 instead of 0\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_5(date):\n    if date.weekday() == 0:  # If it's Monday\n        assert date.weekday() == 5  # Incorrectly asserting it should be 5 instead of 0\n```"], "property": "If the input date corresponds to a Monday, the output of `weekday()` should be 0.", "pbt": "@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_monday_property(date):\n    if date.weekday() == 0:  # If it's Monday\n        assert date.weekday() == 0", "properties": ["1. The output of the `weekday()` function is always an integer between 0 and 6, inclusive.", "2. The output for any given date remains consistent across multiple calls to `weekday()` for the same date.", "3. If the input date corresponds to a Monday, the output of `weekday()` should be 0.", "4. If the input date corresponds to a Sunday, the output of `weekday()` should be 6.", "5. The output of `weekday()` should exhibit a cyclic pattern, where consecutive days differ by 1, and the transition from Sunday (6) to Monday (0) wraps around."]}
{"function_name": "datetime.date.weekday", "mutants": ["```python\n# property to violate: If the input date corresponds to a Sunday, the output of `weekday()` should be 6.\nfrom hypothesis import given, strategies as st\nimport datetime\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_1(date):\n    if date.weekday() == 6:  # If it's Sunday\n        assert date.weekday() == 5  # Incorrectly asserting it should be 5 instead of 6\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_2(date):\n    if date.weekday() == 6:  # If it's Sunday\n        assert date.weekday() == 7  # Incorrectly asserting it should be 7 instead of 6\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_3(date):\n    if date.weekday() == 6:  # If it's Sunday\n        assert date.weekday() == 0  # Incorrectly asserting it should be 0 instead of 6\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_4(date):\n    if date.weekday() == 6:  # If it's Sunday\n        assert date.weekday() == 1  # Incorrectly asserting it should be 1 instead of 6\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_5(date):\n    if date.weekday() == 6:  # If it's Sunday\n        assert date.weekday() == 2  # Incorrectly asserting it should be 2 instead of 6\n```"], "property": "If the input date corresponds to a Sunday, the output of `weekday()` should be 6.", "pbt": "@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_sunday_property(date):\n    if date.weekday() == 6:  # If it's Sunday\n        assert date.weekday() == 6", "properties": ["1. The output of the `weekday()` function is always an integer between 0 and 6, inclusive.", "2. The output for any given date remains consistent across multiple calls to `weekday()` for the same date.", "3. If the input date corresponds to a Monday, the output of `weekday()` should be 0.", "4. If the input date corresponds to a Sunday, the output of `weekday()` should be 6.", "5. The output of `weekday()` should exhibit a cyclic pattern, where consecutive days differ by 1, and the transition from Sunday (6) to Monday (0) wraps around."]}
{"function_name": "datetime.date.weekday", "mutants": ["```python\n# property to violate: The output of `weekday()` should exhibit a cyclic pattern, where consecutive days differ by 1, and the transition from Sunday (6) to Monday (0) wraps around.\nfrom hypothesis import given, strategies as st\nimport datetime\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_1(date):\n    next_day = date + datetime.timedelta(days=1)\n    assert (date.weekday() + 2) % 7 == next_day.weekday()  # Violates the cyclic pattern\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_2(date):\n    next_day = date + datetime.timedelta(days=1)\n    assert (date.weekday() + 3) % 7 == next_day.weekday()  # Violates the cyclic pattern\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_3(date):\n    next_day = date + datetime.timedelta(days=1)\n    assert (date.weekday() + 4) % 7 == next_day.weekday()  # Violates the cyclic pattern\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_4(date):\n    next_day = date + datetime.timedelta(days=1)\n    assert (date.weekday() * 2) % 7 == next_day.weekday()  # Violates the cyclic pattern\n\n@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_violation_of_datetime_date_weekday_5(date):\n    next_day = date + datetime.timedelta(days=1)\n    assert (date.weekday() - 1) % 7 == next_day.weekday()  # Violates the cyclic pattern\n```"], "property": "The output of `weekday()` should exhibit a cyclic pattern, where consecutive days differ by 1, and the transition from Sunday (6) to Monday (0) wraps around.", "pbt": "@given(st.dates(min_value=datetime.date(1, 1, 1), max_value=datetime.date(9999, 12, 31)))\ndef test_cyclic_pattern_property(date):\n    next_day = date + datetime.timedelta(days=1)\n    assert (date.weekday() + 1) % 7 == next_day.weekday()", "properties": ["1. The output of the `weekday()` function is always an integer between 0 and 6, inclusive.", "2. The output for any given date remains consistent across multiple calls to `weekday()` for the same date.", "3. If the input date corresponds to a Monday, the output of `weekday()` should be 0.", "4. If the input date corresponds to a Sunday, the output of `weekday()` should be 6.", "5. The output of `weekday()` should exhibit a cyclic pattern, where consecutive days differ by 1, and the transition from Sunday (6) to Monday (0) wraps around."]}
