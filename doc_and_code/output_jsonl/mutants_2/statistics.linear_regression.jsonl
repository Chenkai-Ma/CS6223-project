{"function_name": "statistics.linear_regression", "mutants": ["```python\n# property to violate: If both input lists have the same values (e.g., x = [1, 2, 3] and y = [1, 2, 3]), the slope should be equal to 1 and the intercept should be 0 (or undefined when proportional is true).\nfrom hypothesis import given, strategies as st\nimport statistics\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=1000).filter(lambda lst: len(set(lst)) > 1), \n                st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=1000))\ndef test_violation_of_statistics_linear_regression_1(x, y):\n    constant_x = [1] * len(y)\n    constant_y = [2] * len(y)  # Change y to a constant value different from x\n    statistics.linear_regression(constant_x, constant_y)\n    assert False, \"Expected StatisticsError for constant x\"\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=1000).filter(lambda lst: len(set(lst)) > 1), \n                st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=1000))\ndef test_violation_of_statistics_linear_regression_2(x, y):\n    constant_x = [0] * len(y)  # x is constant\n    constant_y = [1] * len(y)  # y is also constant but different from x\n    statistics.linear_regression(constant_x, constant_y)\n    assert False, \"Expected StatisticsError for constant x\"\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=1000).filter(lambda lst: len(set(lst)) > 1), \n                st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=1000))\ndef test_violation_of_statistics_linear_regression_3(x, y):\n    constant_x = [3] * len(y)  # x is constant\n    constant_y = [4] * len(y)  # y is also constant but different from x\n    statistics.linear_regression(constant_x, constant_y)\n    assert False, \"Expected StatisticsError for constant x\"\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=1000).filter(lambda lst: len(set(lst)) > 1), \n                st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=1000))\ndef test_violation_of_statistics_linear_regression_4(x, y):\n    constant_x = [2] * len(y)  # x is constant\n    constant_y = [5] * len(y)  # y is also constant but different from x\n    statistics.linear_regression(constant_x, constant_y)\n    assert False, \"Expected StatisticsError for constant x\"\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=1000).filter(lambda lst: len(set(lst)) > 1), \n                st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=1000))\ndef test_violation_of_statistics_linear_regression_5(x, y):\n    constant_x = [7] * len(y)  # x is constant\n    constant_y = [8] * len(y)  # y is also constant but different from x\n    statistics.linear_regression(constant_x, constant_y)\n    assert False, \"Expected StatisticsError for constant x\"\n```"], "property": "If both input lists have the same values (e.g., x = [1, 2, 3] and y = [1, 2, 3]), the slope should be equal to 1 and the intercept should be 0 (or undefined when proportional is true).", "pbt": "@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=1000).filter(lambda lst: len(set(lst)) > 1), \n                st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=1000))\ndef test_constant_input_property(x, y):\n    constant_x = [5] * len(y)\n    try:\n        statistics.linear_regression(constant_x, y)\n        assert False, \"Expected StatisticsError for constant x\"\n    except StatisticsError:\n        pass", "properties": ["3. If both input lists have the same values (e.g., x = [1, 2, 3] and y = [1, 2, 3]), the slope should be equal to 1 and the intercept should be 0 (or undefined when proportional is true)."]}
