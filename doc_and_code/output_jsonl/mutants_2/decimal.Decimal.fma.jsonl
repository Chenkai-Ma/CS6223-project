{"function_name": "decimal.Decimal.fma", "mutants": ["```python\n# property to violate: If either `self` or `other` is a special value (like NaN or Infinity), the output should conform to the rules of arithmetic for those special values, returning appropriate results or raising errors as defined.\nfrom hypothesis import given, strategies as st\nfrom decimal import Decimal, getcontext, InvalidOperation\n\n@given(st.decimals(), st.decimals(), st.decimals())\ndef test_violation_of_decimal_Decimal_fma_1(self, other, third):\n    context = getcontext()\n    if self.is_nan() or other.is_nan():\n        try:\n            result = self.fma(other, third)\n            assert result.is_infinite()  # Violation: should be NaN\n        except InvalidOperation:\n            pass  # Expected behavior, skip further checks\n    elif self.is_infinite() or other.is_infinite():\n        result = self.fma(other, third)\n        assert result.is_nan()  # Violation: should be infinite or a valid number\n\n@given(st.decimals(), st.decimals(), st.decimals())\ndef test_violation_of_decimal_Decimal_fma_2(self, other, third):\n    context = getcontext()\n    if self.is_nan() or other.is_nan():\n        try:\n            result = self.fma(other, third)\n            assert result == Decimal(0)  # Violation: should be NaN\n        except InvalidOperation:\n            pass  # Expected behavior, skip further checks\n    elif self.is_infinite() or other.is_infinite():\n        result = self.fma(other, third)\n        assert result == Decimal(1)  # Violation: should be infinite or a valid number\n\n@given(st.decimals(), st.decimals(), st.decimals())\ndef test_violation_of_decimal_Decimal_fma_3(self, other, third):\n    context = getcontext()\n    if self.is_nan() or other.is_nan():\n        try:\n            result = self.fma(other, third)\n            assert result.is_finite()  # Violation: should be NaN\n        except InvalidOperation:\n            pass  # Expected behavior, skip further checks\n    elif self.is_infinite() or other.is_infinite():\n        result = self.fma(other, third)\n        assert result.is_nan()  # Violation: should be infinite or a valid number\n\n@given(st.decimals(), st.decimals(), st.decimals())\ndef test_violation_of_decimal_Decimal_fma_4(self, other, third):\n    context = getcontext()\n    if self.is_nan() or other.is_nan():\n        try:\n            result = self.fma(other, third)\n            assert result == Decimal('Infinity')  # Violation: should be NaN\n        except InvalidOperation:\n            pass  # Expected behavior, skip further checks\n    elif self.is_infinite() or other.is_infinite():\n        result = self.fma(other, third)\n        assert result.is_nan()  # Violation: should be infinite or a valid number\n\n@given(st.decimals(), st.decimals(), st.decimals())\ndef test_violation_of_decimal_Decimal_fma_5(self, other, third):\n    context = getcontext()\n    if self.is_nan() or other.is_nan():\n        try:\n            result = self.fma(other, third)\n            assert result == Decimal('0.0')  # Violation: should be NaN\n        except InvalidOperation:\n            pass  # Expected behavior, skip further checks\n    elif self.is_infinite() or other.is_infinite():\n        result = self.fma(other, third)\n        assert result == Decimal('0.0')  # Violation: should be infinite or a valid number\n```"], "property": "If either `self` or `other` is a special value (like NaN or Infinity), the output should conform to the rules of arithmetic for those special values, returning appropriate results or raising errors as defined.", "pbt": "@given(st.decimals(), st.decimals(), st.decimals())\ndef test_special_values_property(self, other, third):\n    context = getcontext()\n    if self.is_nan() or other.is_nan():\n        try:\n            result = self.fma(other, third)\n            assert result.is_nan()\n        except InvalidOperation:\n            pass  # Expected behavior, skip further checks\n    elif self.is_infinite() or other.is_infinite():\n        result = self.fma(other, third)\n        # Check that the result is either infinity or a valid number\n        assert result.is_infinite() or isinstance(result, Decimal)", "properties": ["2. If either `self` or `other` is a special value (like NaN or Infinity), the output should conform to the rules of arithmetic for those special values, returning appropriate results or raising errors as defined."]}
