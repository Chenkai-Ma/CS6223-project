{"function_name": "decimal.Decimal.shift", "mutants": ["```python\n# property to violate: Shifting by zero should return the original operand, confirming that no changes occur when the shift amount is zero.\nfrom hypothesis import given, strategies as st\nimport decimal\n\n@given(st.decimals(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_shift_1(d):\n    result = d.shift(0) + decimal.Decimal(1)  # Modify output by adding 1\n    assert result == d\n\n@given(st.decimals(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_shift_2(d):\n    result = d.shift(0) * decimal.Decimal(2)  # Modify output by multiplying by 2\n    assert result == d\n\n@given(st.decimals(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_shift_3(d):\n    result = d.shift(0) - decimal.Decimal(1)  # Modify output by subtracting 1\n    assert result == d\n\n@given(st.decimals(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_shift_4(d):\n    result = d.shift(0).copy_sign(decimal.Decimal(1))  # Change the sign of the result\n    assert result == d\n\n@given(st.decimals(allow_nan=False, allow_infinity=False))\ndef test_violation_of_decimal_Decimal_shift_5(d):\n    result = d.shift(0) / decimal.Decimal(2)  # Modify output by dividing by 2\n    assert result == d\n```"], "property": "Shifting by zero should return the original operand, confirming that no changes occur when the shift amount is zero.", "pbt": "@given(st.decimals(allow_nan=False, allow_infinity=False))\ndef test_shifting_by_zero_returns_original_operand_property(d):\n    result = d.shift(0)\n    assert result == d", "properties": ["3. Shifting by zero should return the original operand, confirming that no changes occur when the shift amount is zero.", "5. The output's coefficient should not exceed the defined precision in the context, ensuring that the result adheres to the maximum allowable digits as specified by the context's precision."]}
{"function_name": "decimal.Decimal.shift", "mutants": ["```python\n# property to violate: The output's coefficient should not exceed the defined precision in the context, ensuring that the result adheres to the maximum allowable digits as specified by the context's precision.\nfrom hypothesis import given, strategies as st\nimport decimal\nfrom decimal import getcontext\n\n@given(st.decimals(), st.integers(min_value=-getcontext().prec, max_value=getcontext().prec))\ndef test_violation_of_decimal_Decimal_shift_1(value, shift_amount):\n    result = value.shift(shift_amount) * decimal.Decimal('1e10')  # Scale the result to exceed precision\n    assert len(str(result)) <= getcontext().prec\n\n@given(st.decimals(), st.integers(min_value=-getcontext().prec, max_value=getcontext().prec))\ndef test_violation_of_decimal_Decimal_shift_2(value, shift_amount):\n    result = value.shift(shift_amount) + decimal.Decimal('1e5')  # Add a large number to exceed precision\n    assert len(str(result)) <= getcontext().prec\n\n@given(st.decimals(), st.integers(min_value=-getcontext().prec, max_value=getcontext().prec))\ndef test_violation_of_decimal_Decimal_shift_3(value, shift_amount):\n    result = value.shift(shift_amount) / decimal.Decimal('0.1')  # Divide by a small number to increase the coefficient\n    assert len(str(result)) <= getcontext().prec\n\n@given(st.decimals(), st.integers(min_value=-getcontext().prec, max_value=getcontext().prec))\ndef test_violation_of_decimal_Decimal_shift_4(value, shift_amount):\n    result = value.shift(shift_amount) ** 2  # Square the result to potentially exceed precision\n    assert len(str(result)) <= getcontext().prec\n\n@given(st.decimals(), st.integers(min_value=-getcontext().prec, max_value=getcontext().prec))\ndef test_violation_of_decimal_Decimal_shift_5(value, shift_amount):\n    result = value.shift(shift_amount) + decimal.Decimal('99999999999999999999')  # Add a very large number\n    assert len(str(result)) <= getcontext().prec\n```"], "property": "The output's coefficient should not exceed the defined precision in the context, ensuring that the result adheres to the maximum allowable digits as specified by the context's precision.", "pbt": "@given(st.decimals(), st.integers(min_value=-getcontext().prec, max_value=getcontext().prec))\ndef test_shift_precision_property(value, shift_amount):\n    result = value.shift(shift_amount)\n    assert len(str(result)) <= getcontext().prec", "properties": ["3. Shifting by zero should return the original operand, confirming that no changes occur when the shift amount is zero.", "5. The output's coefficient should not exceed the defined precision in the context, ensuring that the result adheres to the maximum allowable digits as specified by the context's precision."]}
