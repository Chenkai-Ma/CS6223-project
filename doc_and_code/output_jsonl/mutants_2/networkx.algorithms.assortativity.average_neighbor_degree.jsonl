{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The output dictionary should contain an entry for every node in the input graph, with each node as a key.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Remove one node from the result to violate the property\n    if G.nodes:\n        result.pop(next(iter(G.nodes)), None)\n    # Check that each node in the graph is a key in the result\n    assert all(node in result for node in G.nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Create a result with fewer keys than nodes\n    result = {node: result[node] for node in list(G.nodes)[:-1]}\n    # Check that each node in the graph is a key in the result\n    assert all(node in result for node in G.nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Add an extra key to the result that does not exist in G\n    result['extra_node'] = 0\n    # Check that each node in the graph is a key in the result\n    assert all(node in result for node in G.nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Create an empty result to violate the property\n    result = {}\n    # Check that each node in the graph is a key in the result\n    assert all(node in result for node in G.nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Remove all entries from the result to violate the property\n    result.clear()\n    # Check that each node in the graph is a key in the result\n    assert all(node in result for node in G.nodes)\n```"], "property": "The output dictionary should contain an entry for every node in the input graph, with each node as a key.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_contains_all_nodes_property(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Check that each node in the graph is a key in the result\n    assert all(node in result for node in G.nodes)", "properties": ["1. The output dictionary should contain an entry for every node in the input graph, with each node as a key.", "2. The average neighbor degree for any node should be a non-negative float value, as it represents an average degree.", "3. If a node has no neighbors (degree zero), its average neighbor degree should be zero.", "4. The average neighbor degree of a node should be equal to the total degree of its neighbors divided by the number of neighbors, adhering to the mathematical definition provided in the documentation.", "5. The average neighbor degree should remain consistent regardless of the order in which nodes are processed, ensuring that the output is stable across multiple invocations with the same graph and parameters."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The average neighbor degree for any node should be a non-negative float value, as it represents an average degree.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Modify the result to include negative values\n    result = {k: -abs(v) for k, v in result.items()}\n    assert all(value >= 0 for value in result.values())\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Introduce a negative value explicitly\n    result[next(iter(result))] = -1.0\n    assert all(value >= 0 for value in result.values())\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Replace all values with a negative float\n    result = {k: -0.5 for k in result.keys()}\n    assert all(value >= 0 for value in result.values())\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Change one of the values to a negative float\n    keys = list(result.keys())\n    result[keys[0]] = -10.0\n    assert all(value >= 0 for value in result.values())\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Set the average neighbor degree of all nodes to a negative value\n    result = {k: -100.0 for k in result.keys()}\n    assert all(value >= 0 for value in result.values())\n```"], "property": "The average neighbor degree for any node should be a non-negative float value, as it represents an average degree.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_non_negative_values_property(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Check that the average neighbor degree values are non-negative\n    assert all(value >= 0 for value in result.values())", "properties": ["1. The output dictionary should contain an entry for every node in the input graph, with each node as a key.", "2. The average neighbor degree for any node should be a non-negative float value, as it represents an average degree.", "3. If a node has no neighbors (degree zero), its average neighbor degree should be zero.", "4. The average neighbor degree of a node should be equal to the total degree of its neighbors divided by the number of neighbors, adhering to the mathematical definition provided in the documentation.", "5. The average neighbor degree should remain consistent regardless of the order in which nodes are processed, ensuring that the output is stable across multiple invocations with the same graph and parameters."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: If a node has no neighbors (degree zero), its average neighbor degree should be zero.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    # Add an isolated node\n    G.add_node('isolated_node')\n    # Forcefully set the average neighbor degree of the isolated node to a non-zero value\n    result = nx.average_neighbor_degree(G)\n    result['isolated_node'] = 5  # Violating the property\n    # Check that the isolated node has an average neighbor degree of zero\n    assert result.get('isolated_node', 0) == 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    # Add an isolated node\n    G.add_node('isolated_node')\n    # Create a result dictionary that incorrectly assigns a non-zero average neighbor degree\n    result = nx.average_neighbor_degree(G)\n    result['isolated_node'] = 10  # Violating the property\n    # Check that the isolated node has an average neighbor degree of zero\n    assert result.get('isolated_node', 0) == 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    # Add an isolated node\n    G.add_node('isolated_node')\n    # Modify the output to ensure the isolated node has a high average neighbor degree\n    result = nx.average_neighbor_degree(G)\n    result['isolated_node'] = 20  # Violating the property\n    # Check that the isolated node has an average neighbor degree of zero\n    assert result.get('isolated_node', 0) == 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    # Add an isolated node\n    G.add_node('isolated_node')\n    # Forcefully set the average neighbor degree to a negative value (which is invalid)\n    result = nx.average_neighbor_degree(G)\n    result['isolated_node'] = -1  # Violating the property\n    # Check that the isolated node has an average neighbor degree of zero\n    assert result.get('isolated_node', 0) == 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    # Add an isolated node\n    G.add_node('isolated_node')\n    # Set an arbitrary non-zero average neighbor degree for the isolated node\n    result = nx.average_neighbor_degree(G)\n    result['isolated_node'] = 100  # Violating the property\n    # Check that the isolated node has an average neighbor degree of zero\n    assert result.get('isolated_node', 0) == 0\n```"], "property": "If a node has no neighbors (degree zero), its average neighbor degree should be zero.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_zero_for_isolated_nodes_property(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    # Add an isolated node\n    G.add_node('isolated_node')\n    result = nx.average_neighbor_degree(G)\n    # Check that the isolated node has an average neighbor degree of zero\n    assert result.get('isolated_node', 0) == 0", "properties": ["1. The output dictionary should contain an entry for every node in the input graph, with each node as a key.", "2. The average neighbor degree for any node should be a non-negative float value, as it represents an average degree.", "3. If a node has no neighbors (degree zero), its average neighbor degree should be zero.", "4. The average neighbor degree of a node should be equal to the total degree of its neighbors divided by the number of neighbors, adhering to the mathematical definition provided in the documentation.", "5. The average neighbor degree should remain consistent regardless of the order in which nodes are processed, ensuring that the output is stable across multiple invocations with the same graph and parameters."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The average neighbor degree of a node should be equal to the total degree of its neighbors divided by the number of neighbors, adhering to the mathematical definition provided in the documentation.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    for node in G.nodes:\n        neighbors = list(G.neighbors(node))\n        if neighbors:\n            expected_avg = sum(G.degree(n) for n in neighbors) / len(neighbors)\n            # Violate the property by adding 1 to the expected average\n            assert result[node] == expected_avg + 1\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    for node in G.nodes:\n        neighbors = list(G.neighbors(node))\n        if neighbors:\n            expected_avg = sum(G.degree(n) for n in neighbors) / len(neighbors)\n            # Violate the property by multiplying the expected average by 2\n            assert result[node] == expected_avg * 2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    for node in G.nodes:\n        neighbors = list(G.neighbors(node))\n        if neighbors:\n            expected_avg = sum(G.degree(n) for n in neighbors) / len(neighbors)\n            # Violate the property by subtracting 5 from the expected average\n            assert result[node] == expected_avg - 5\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    for node in G.nodes:\n        neighbors = list(G.neighbors(node))\n        if neighbors:\n            expected_avg = sum(G.degree(n) for n in neighbors) / len(neighbors)\n            # Violate the property by returning a constant value (e.g., 10)\n            assert result[node] == 10\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    for node in G.nodes:\n        neighbors = list(G.neighbors(node))\n        if neighbors:\n            expected_avg = sum(G.degree(n) for n in neighbors) / len(neighbors)\n            # Violate the property by returning the square of the expected average\n            assert result[node] == expected_avg ** 2\n```"], "property": "The average neighbor degree of a node should be equal to the total degree of its neighbors divided by the number of neighbors, adhering to the mathematical definition provided in the documentation.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_correctness_property(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    for node in G.nodes:\n        neighbors = list(G.neighbors(node))\n        if neighbors:\n            expected_avg = sum(G.degree(n) for n in neighbors) / len(neighbors)\n            assert result[node] == expected_avg", "properties": ["1. The output dictionary should contain an entry for every node in the input graph, with each node as a key.", "2. The average neighbor degree for any node should be a non-negative float value, as it represents an average degree.", "3. If a node has no neighbors (degree zero), its average neighbor degree should be zero.", "4. The average neighbor degree of a node should be equal to the total degree of its neighbors divided by the number of neighbors, adhering to the mathematical definition provided in the documentation.", "5. The average neighbor degree should remain consistent regardless of the order in which nodes are processed, ensuring that the output is stable across multiple invocations with the same graph and parameters."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The average neighbor degree should remain consistent regardless of the order in which nodes are processed, ensuring that the output is stable across multiple invocations with the same graph and parameters.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result1 = nx.average_neighbor_degree(G)\n    result2 = result1 + 1  # Modify the output to create inconsistency\n    # Check that the results are consistent across multiple calls\n    assert result1 == result2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result1 = nx.average_neighbor_degree(G)\n    result2 = result1 * 2  # Modify the output to create inconsistency\n    # Check that the results are consistent across multiple calls\n    assert result1 == result2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result1 = nx.average_neighbor_degree(G)\n    result2 = result1 - 1  # Modify the output to create inconsistency\n    # Check that the results are consistent across multiple calls\n    assert result1 == result2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result1 = nx.average_neighbor_degree(G)\n    result2 = float('nan')  # Modify the output to create inconsistency\n    # Check that the results are consistent across multiple calls\n    assert result1 == result2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result1 = nx.average_neighbor_degree(G)\n    result2 = -result1  # Modify the output to create inconsistency\n    # Check that the results are consistent across multiple calls\n    assert result1 == result2\n```"], "property": "The average neighbor degree should remain consistent regardless of the order in which nodes are processed, ensuring that the output is stable across multiple invocations with the same graph and parameters.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_stability_property(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result1 = nx.average_neighbor_degree(G)\n    result2 = nx.average_neighbor_degree(G)\n    # Check that the results are consistent across multiple calls\n    assert result1 == result2", "properties": ["1. The output dictionary should contain an entry for every node in the input graph, with each node as a key.", "2. The average neighbor degree for any node should be a non-negative float value, as it represents an average degree.", "3. If a node has no neighbors (degree zero), its average neighbor degree should be zero.", "4. The average neighbor degree of a node should be equal to the total degree of its neighbors divided by the number of neighbors, adhering to the mathematical definition provided in the documentation.", "5. The average neighbor degree should remain consistent regardless of the order in which nodes are processed, ensuring that the output is stable across multiple invocations with the same graph and parameters."]}
