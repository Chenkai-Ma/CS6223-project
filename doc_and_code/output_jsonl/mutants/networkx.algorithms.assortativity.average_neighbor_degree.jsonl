{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The output dictionary should contain an entry for every node in the input graph, with each node as a key.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Remove one node from the result to violate the property\n    if G.nodes:\n        result.pop(next(iter(G.nodes)), None)\n    # Check that each node in the graph is a key in the result\n    assert all(node in result for node in G.nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Remove two nodes from the result to violate the property\n    if len(G.nodes) > 1:\n        nodes_to_remove = list(G.nodes)[:2]\n        for node in nodes_to_remove:\n            result.pop(node, None)\n    # Check that each node in the graph is a key in the result\n    assert all(node in result for node in G.nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Clear the result dictionary to violate the property\n    result.clear()\n    # Check that each node in the graph is a key in the result\n    assert all(node in result for node in G.nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Create a result that only contains the first node to violate the property\n    first_node = next(iter(G.nodes), None)\n    result = {first_node: result.get(first_node, 0)} if first_node else {}\n    # Check that each node in the graph is a key in the result\n    assert all(node in result for node in G.nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Add an arbitrary key to the result that is not in the graph to violate the property\n    result['invalid_node'] = 0\n    # Check that each node in the graph is a key in the result\n    assert all(node in result for node in G.nodes)\n```"], "property": "The output dictionary should contain an entry for every node in the input graph, with each node as a key.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_contains_all_nodes_property(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Check that each node in the graph is a key in the result\n    assert all(node in result for node in G.nodes)", "properties": ["1. The output dictionary should contain an entry for every node in the input graph, with each node as a key.", "2. The average neighbor degree for any node should be a non-negative float value, as it represents an average degree.", "3. If a node has no neighbors (degree zero), its average neighbor degree should be zero.", "4. The average neighbor degree of a node should be equal to the total degree of its neighbors divided by the number of neighbors, adhering to the mathematical definition provided in the documentation.", "5. The average neighbor degree should remain consistent regardless of the order in which nodes are processed, ensuring that the output is stable across multiple invocations with the same graph and parameters."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The average neighbor degree for any node should be a non-negative float value, as it represents an average degree.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Modify output to include negative values\n    result = {node: value - 1 for node, value in result.items()}\n    assert all(value >= 0 for value in result.values())\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Modify output to include negative values\n    result = {node: value - 10 for node, value in result.items()}\n    assert all(value >= 0 for value in result.values())\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Modify output to include negative values\n    result = {node: -abs(value) for node, value in result.items()}\n    assert all(value >= 0 for value in result.values())\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Modify output to include negative values\n    result = {node: -1.0 for node in result.keys()}\n    assert all(value >= 0 for value in result.values())\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Modify output to include negative values\n    result = {node: value - (value + 1) for node, value in result.items()}\n    assert all(value >= 0 for value in result.values())\n```"], "property": "The average neighbor degree for any node should be a non-negative float value, as it represents an average degree.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_non_negative_values_property(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    # Check that the average neighbor degree values are non-negative\n    assert all(value >= 0 for value in result.values())", "properties": ["1. The output dictionary should contain an entry for every node in the input graph, with each node as a key.", "2. The average neighbor degree for any node should be a non-negative float value, as it represents an average degree.", "3. If a node has no neighbors (degree zero), its average neighbor degree should be zero.", "4. The average neighbor degree of a node should be equal to the total degree of its neighbors divided by the number of neighbors, adhering to the mathematical definition provided in the documentation.", "5. The average neighbor degree should remain consistent regardless of the order in which nodes are processed, ensuring that the output is stable across multiple invocations with the same graph and parameters."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: If a node has no neighbors (degree zero), its average neighbor degree should be zero.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    # Add an isolated node\n    G.add_node('isolated_node')\n    result = nx.average_neighbor_degree(G)\n    # Force the average neighbor degree of the isolated node to be 1 instead of 0\n    result['isolated_node'] = 1\n    # Check that the isolated node has an average neighbor degree of zero\n    assert result.get('isolated_node', 0) == 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    # Add an isolated node\n    G.add_node('isolated_node')\n    result = nx.average_neighbor_degree(G)\n    # Force the average neighbor degree of the isolated node to be 10 instead of 0\n    result['isolated_node'] = 10\n    # Check that the isolated node has an average neighbor degree of zero\n    assert result.get('isolated_node', 0) == 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    # Add an isolated node\n    G.add_node('isolated_node')\n    result = nx.average_neighbor_degree(G)\n    # Force the average neighbor degree of the isolated node to be -5 instead of 0\n    result['isolated_node'] = -5\n    # Check that the isolated node has an average neighbor degree of zero\n    assert result.get('isolated_node', 0) == 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    # Add an isolated node\n    G.add_node('isolated_node')\n    result = nx.average_neighbor_degree(G)\n    # Force the average neighbor degree of the isolated node to be 100 instead of 0\n    result['isolated_node'] = 100\n    # Check that the isolated node has an average neighbor degree of zero\n    assert result.get('isolated_node', 0) == 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    # Add an isolated node\n    G.add_node('isolated_node')\n    result = nx.average_neighbor_degree(G)\n    # Force the average neighbor degree of the isolated node to be 3.5 instead of 0\n    result['isolated_node'] = 3.5\n    # Check that the isolated node has an average neighbor degree of zero\n    assert result.get('isolated_node', 0) == 0\n```"], "property": "If a node has no neighbors (degree zero), its average neighbor degree should be zero.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_zero_for_isolated_nodes_property(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    # Add an isolated node\n    G.add_node('isolated_node')\n    result = nx.average_neighbor_degree(G)\n    # Check that the isolated node has an average neighbor degree of zero\n    assert result.get('isolated_node', 0) == 0", "properties": ["1. The output dictionary should contain an entry for every node in the input graph, with each node as a key.", "2. The average neighbor degree for any node should be a non-negative float value, as it represents an average degree.", "3. If a node has no neighbors (degree zero), its average neighbor degree should be zero.", "4. The average neighbor degree of a node should be equal to the total degree of its neighbors divided by the number of neighbors, adhering to the mathematical definition provided in the documentation.", "5. The average neighbor degree should remain consistent regardless of the order in which nodes are processed, ensuring that the output is stable across multiple invocations with the same graph and parameters."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The average neighbor degree of a node should be equal to the total degree of its neighbors divided by the number of neighbors, adhering to the mathematical definition provided in the documentation.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    for node in G.nodes:\n        neighbors = list(G.neighbors(node))\n        if neighbors:\n            # Intentionally modifying expected_avg to violate the property\n            expected_avg = (sum(G.degree(n) for n in neighbors) / len(neighbors)) + 1\n            assert result[node] == expected_avg\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    for node in G.nodes:\n        neighbors = list(G.neighbors(node))\n        if neighbors:\n            # Intentionally modifying expected_avg to violate the property\n            expected_avg = (sum(G.degree(n) for n in neighbors) / len(neighbors)) * 2\n            assert result[node] == expected_avg\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    for node in G.nodes:\n        neighbors = list(G.neighbors(node))\n        if neighbors:\n            # Intentionally modifying expected_avg to violate the property\n            expected_avg = sum(G.degree(n) for n in neighbors) / (len(neighbors) + 1)\n            assert result[node] == expected_avg\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    for node in G.nodes:\n        neighbors = list(G.neighbors(node))\n        if neighbors:\n            # Intentionally modifying expected_avg to violate the property\n            expected_avg = (sum(G.degree(n) for n in neighbors) + 5) / len(neighbors)\n            assert result[node] == expected_avg\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    for node in G.nodes:\n        neighbors = list(G.neighbors(node))\n        if neighbors:\n            # Intentionally modifying expected_avg to violate the property\n            expected_avg = (sum(G.degree(n) for n in neighbors) - 3) / len(neighbors)\n            assert result[node] == expected_avg\n```"], "property": "The average neighbor degree of a node should be equal to the total degree of its neighbors divided by the number of neighbors, adhering to the mathematical definition provided in the documentation.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_correctness_property(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result = nx.average_neighbor_degree(G)\n    for node in G.nodes:\n        neighbors = list(G.neighbors(node))\n        if neighbors:\n            expected_avg = sum(G.degree(n) for n in neighbors) / len(neighbors)\n            assert result[node] == expected_avg", "properties": ["1. The output dictionary should contain an entry for every node in the input graph, with each node as a key.", "2. The average neighbor degree for any node should be a non-negative float value, as it represents an average degree.", "3. If a node has no neighbors (degree zero), its average neighbor degree should be zero.", "4. The average neighbor degree of a node should be equal to the total degree of its neighbors divided by the number of neighbors, adhering to the mathematical definition provided in the documentation.", "5. The average neighbor degree should remain consistent regardless of the order in which nodes are processed, ensuring that the output is stable across multiple invocations with the same graph and parameters."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The average neighbor degree should remain consistent regardless of the order in which nodes are processed, ensuring that the output is stable across multiple invocations with the same graph and parameters.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    G = data.draw(st.from_type(nx.Graph))\n    result1 = nx.average_neighbor_degree(G)\n    result2 = nx.average_neighbor_degree(G)\n    # Introduce a random modification to result2 to ensure inconsistency\n    result2[0] += 1  # Modify the first node's average neighbor degree\n    assert result1 == result2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    G = data.draw(st.from_type(nx.Graph))\n    result1 = nx.average_neighbor_degree(G)\n    result2 = nx.average_neighbor_degree(G)\n    # Introduce a random modification to result2 to ensure inconsistency\n    result2[1] -= 1  # Modify the second node's average neighbor degree\n    assert result1 == result2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    G = data.draw(st.from_type(nx.Graph))\n    result1 = nx.average_neighbor_degree(G)\n    result2 = nx.average_neighbor_degree(G)\n    # Introduce a random modification to result2 to ensure inconsistency\n    result2[2] *= 2  # Double the third node's average neighbor degree\n    assert result1 == result2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    G = data.draw(st.from_type(nx.Graph))\n    result1 = nx.average_neighbor_degree(G)\n    result2 = nx.average_neighbor_degree(G)\n    # Introduce a random modification to result2 to ensure inconsistency\n    result2[3] = 0  # Set the fourth node's average neighbor degree to zero\n    assert result1 == result2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    G = data.draw(st.from_type(nx.Graph))\n    result1 = nx.average_neighbor_degree(G)\n    result2 = nx.average_neighbor_degree(G)\n    # Introduce a random modification to result2 to ensure inconsistency\n    result2[4] = result1[4] + 5  # Add 5 to the fifth node's average neighbor degree\n    assert result1 == result2\n```"], "property": "The average neighbor degree should remain consistent regardless of the order in which nodes are processed, ensuring that the output is stable across multiple invocations with the same graph and parameters.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_stability_property(data):\n    # Generate a random graph\n    G = data.draw(st.from_type(nx.Graph))\n    result1 = nx.average_neighbor_degree(G)\n    result2 = nx.average_neighbor_degree(G)\n    # Check that the results are consistent across multiple calls\n    assert result1 == result2", "properties": ["1. The output dictionary should contain an entry for every node in the input graph, with each node as a key.", "2. The average neighbor degree for any node should be a non-negative float value, as it represents an average degree.", "3. If a node has no neighbors (degree zero), its average neighbor degree should be zero.", "4. The average neighbor degree of a node should be equal to the total degree of its neighbors divided by the number of neighbors, adhering to the mathematical definition provided in the documentation.", "5. The average neighbor degree should remain consistent regardless of the order in which nodes are processed, ensuring that the output is stable across multiple invocations with the same graph and parameters."]}
