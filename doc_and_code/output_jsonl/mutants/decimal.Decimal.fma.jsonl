{"function_name": "decimal.Decimal.fma", "mutants": ["```python\n# property to violate: If either `self` or `other` is a special value (like NaN or Infinity), the output should conform to the rules of arithmetic for those special values, returning appropriate results or raising errors as defined.\nfrom hypothesis import given, strategies as st\nfrom decimal import Decimal, InvalidOperation, getcontext\n\n@given(st.decimals(), st.decimals(), st.decimals())\ndef test_violation_of_decimal_Decimal_fma_1(self, other, third):\n    context = getcontext()\n    if self.is_nan() or other.is_nan():\n        result = self.fma(other, third)\n        # Violation: Instead of returning NaN, we return a regular number\n        assert result == Decimal(0)\n\n@given(st.decimals(), st.decimals(), st.decimals())\ndef test_violation_of_decimal_Decimal_fma_2(self, other, third):\n    context = getcontext()\n    if self.is_infinite() or other.is_infinite():\n        result = self.fma(other, third)\n        # Violation: Instead of returning infinity or a valid number, we return NaN\n        assert result.is_nan()\n\n@given(st.decimals(), st.decimals(), st.decimals())\ndef test_violation_of_decimal_Decimal_fma_3(self, other, third):\n    context = getcontext()\n    if self.is_nan() or other.is_nan():\n        result = self.fma(other, third)\n        # Violation: Instead of returning NaN, we return a negative number\n        assert result == Decimal(-1)\n\n@given(st.decimals(), st.decimals(), st.decimals())\ndef test_violation_of_decimal_Decimal_fma_4(self, other, third):\n    context = getcontext()\n    if self.is_infinite() or other.is_infinite():\n        result = self.fma(other, third)\n        # Violation: Instead of returning infinity, we return a finite number\n        assert result == Decimal(1)\n\n@given(st.decimals(), st.decimals(), st.decimals())\ndef test_violation_of_decimal_Decimal_fma_5(self, other, third):\n    context = getcontext()\n    if self.is_nan() or other.is_nan():\n        result = self.fma(other, third)\n        # Violation: Instead of returning NaN, we return a positive number\n        assert result == Decimal(1)\n```"], "property": "If either `self` or `other` is a special value (like NaN or Infinity), the output should conform to the rules of arithmetic for those special values, returning appropriate results or raising errors as defined.", "pbt": "@given(st.decimals(), st.decimals(), st.decimals())\ndef test_special_values_property(self, other, third):\n    context = getcontext()\n    if self.is_nan() or other.is_nan():\n        try:\n            result = self.fma(other, third)\n            assert result.is_nan()\n        except InvalidOperation:\n            pass  # Expected behavior, skip further checks\n    elif self.is_infinite() or other.is_infinite():\n        result = self.fma(other, third)\n        # Check that the result is either infinity or a valid number\n        assert result.is_infinite() or isinstance(result, Decimal)", "properties": ["2. If either `self` or `other` is a special value (like NaN or Infinity), the output should conform to the rules of arithmetic for those special values, returning appropriate results or raising errors as defined."]}
