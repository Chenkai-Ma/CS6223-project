{"function_name": "networkx.algorithms.approximation.clustering_coefficient.average_clustering", "mutants": ["```python\n# property to violate: The output value must be between 0 and 1, inclusive, since the average clustering coefficient represents a fraction of triangles and cannot exceed this range.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms import approximation\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_1():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    result = approximation.average_clustering(G, trials=trials) + 1  # Violates property by ensuring output is > 1\n    assert 0 <= result <= 1\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_2():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    result = approximation.average_clustering(G, trials=trials) * 2  # Violates property by ensuring output is > 1\n    assert 0 <= result <= 1\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_3():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    result = approximation.average_clustering(G, trials=trials) + 5  # Violates property by ensuring output is > 1\n    assert 0 <= result <= 1\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_4():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    result = approximation.average_clustering(G, trials=trials) + 10  # Violates property by ensuring output is > 1\n    assert 0 <= result <= 1\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_5():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    result = approximation.average_clustering(G, trials=trials) * 3  # Violates property by ensuring output is > 1\n    assert 0 <= result <= 1\n```"], "property": "The output value must be between 0 and 1, inclusive, since the average clustering coefficient represents a fraction of triangles and cannot exceed this range.", "pbt": "@given(st.data())\ndef test_output_between_0_and_1_property(data):\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    result = approximation.average_clustering(G, trials=trials)\n    assert 0 <= result <= 1", "properties": ["1. The output value must be between 0 and 1, inclusive, since the average clustering coefficient represents a fraction of triangles and cannot exceed this range.", "3. The output should be consistent across multiple runs with the same input parameters (graph and trials) when a fixed random seed is provided, ensuring reproducibility.", "4. The output should be approximately equal to the average clustering coefficient calculated using a deterministic method for large graphs, as the approximation should converge to the true value with an adequate number of trials.", "5. If the graph is directed, the function should raise a `NetworkXNotImplemented` exception, indicating that the average clustering coefficient cannot be computed for directed graphs."]}
{"function_name": "networkx.algorithms.approximation.clustering_coefficient.average_clustering", "mutants": ["```python\n# property to violate: The output should be consistent across multiple runs with the same input parameters (graph and trials) when a fixed random seed is provided, ensuring reproducibility.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms import approximation\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_1():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    seed = 42\n    result1 = approximation.average_clustering(G, trials=trials, seed=seed)\n    result2 = approximation.average_clustering(G, trials=trials, seed=seed) + 0.1  # Violation: Adding a constant to the second result\n    assert result1 == result2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_2():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    seed = 42\n    result1 = approximation.average_clustering(G, trials=trials, seed=seed)\n    result2 = approximation.average_clustering(G, trials=trials, seed=seed) * 2  # Violation: Multiplying the second result\n    assert result1 == result2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_3():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    seed = 42\n    result1 = approximation.average_clustering(G, trials=trials, seed=seed)\n    result2 = approximation.average_clustering(G, trials=trials, seed=seed) - 0.5  # Violation: Subtracting a constant from the second result\n    assert result1 == result2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_4():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    seed = 42\n    result1 = approximation.average_clustering(G, trials=trials, seed=seed)\n    result2 = approximation.average_clustering(G, trials=trials, seed=seed) + (result1 * 0.1)  # Violation: Adding a fraction of result1 to the second result\n    assert result1 == result2\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_5():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    seed = 42\n    result1 = approximation.average_clustering(G, trials=trials, seed=seed)\n    result2 = 1 - approximation.average_clustering(G, trials=trials, seed=seed)  # Violation: Inverting the second result\n    assert result1 == result2\n```"], "property": "The output should be consistent across multiple runs with the same input parameters (graph and trials) when a fixed random seed is provided, ensuring reproducibility.", "pbt": "@given(st.data())\ndef test_output_consistency_with_fixed_seed_property(data):\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    seed = 42\n    result1 = approximation.average_clustering(G, trials=trials, seed=seed)\n    result2 = approximation.average_clustering(G, trials=trials, seed=seed)\n    assert result1 == result2", "properties": ["1. The output value must be between 0 and 1, inclusive, since the average clustering coefficient represents a fraction of triangles and cannot exceed this range.", "3. The output should be consistent across multiple runs with the same input parameters (graph and trials) when a fixed random seed is provided, ensuring reproducibility.", "4. The output should be approximately equal to the average clustering coefficient calculated using a deterministic method for large graphs, as the approximation should converge to the true value with an adequate number of trials.", "5. If the graph is directed, the function should raise a `NetworkXNotImplemented` exception, indicating that the average clustering coefficient cannot be computed for directed graphs."]}
{"function_name": "networkx.algorithms.approximation.clustering_coefficient.average_clustering", "mutants": ["```python\n# property to violate: The output should be approximately equal to the average clustering coefficient calculated using a deterministic method for large graphs, as the approximation should converge to the true value with an adequate number of trials.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms import approximation\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_1():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1000, max_value=10000))\n    deterministic_result = nx.average_clustering(G)  # Using deterministic calculation\n    result = approximation.average_clustering(G, trials=trials) + 1  # Adding 1 to violate the property\n    assert abs(result - deterministic_result) < 0.1  # Allowing for a small margin of error\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_2():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1000, max_value=10000))\n    deterministic_result = nx.average_clustering(G)  # Using deterministic calculation\n    result = approximation.average_clustering(G, trials=trials) * 2  # Doubling the result to violate the property\n    assert abs(result - deterministic_result) < 0.1  # Allowing for a small margin of error\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_3():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1000, max_value=10000))\n    deterministic_result = nx.average_clustering(G)  # Using deterministic calculation\n    result = approximation.average_clustering(G, trials=trials) - 0.5  # Subtracting 0.5 to violate the property\n    assert abs(result - deterministic_result) < 0.1  # Allowing for a small margin of error\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_4():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1000, max_value=10000))\n    deterministic_result = nx.average_clustering(G)  # Using deterministic calculation\n    result = approximation.average_clustering(G, trials=trials) + deterministic_result + 1  # Adding deterministic result + 1\n    assert abs(result - deterministic_result) < 0.1  # Allowing for a small margin of error\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_5():\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1000, max_value=10000))\n    deterministic_result = nx.average_clustering(G)  # Using deterministic calculation\n    result = approximation.average_clustering(G, trials=trials) * 0.1  # Reducing the result to 10% to violate the property\n    assert abs(result - deterministic_result) < 0.1  # Allowing for a small margin of error\n```"], "property": "The output should be approximately equal to the average clustering coefficient calculated using a deterministic method for large graphs, as the approximation should converge to the true value with an adequate number of trials.", "pbt": "@given(st.data())\ndef test_output_approximation_convergence_property(data):\n    G = nx.erdos_renyi_graph(data.draw(st.integers(min_value=1, max_value=100)), data.draw(st.floats(min_value=0, max_value=1)))\n    trials = data.draw(st.integers(min_value=1000, max_value=10000))\n    deterministic_result = nx.average_clustering(G)  # Using deterministic calculation\n    result = approximation.average_clustering(G, trials=trials)\n    assert abs(result - deterministic_result) < 0.1  # Allowing for a small margin of error", "properties": ["1. The output value must be between 0 and 1, inclusive, since the average clustering coefficient represents a fraction of triangles and cannot exceed this range.", "3. The output should be consistent across multiple runs with the same input parameters (graph and trials) when a fixed random seed is provided, ensuring reproducibility.", "4. The output should be approximately equal to the average clustering coefficient calculated using a deterministic method for large graphs, as the approximation should converge to the true value with an adequate number of trials.", "5. If the graph is directed, the function should raise a `NetworkXNotImplemented` exception, indicating that the average clustering coefficient cannot be computed for directed graphs."]}
{"function_name": "networkx.algorithms.approximation.clustering_coefficient.average_clustering", "mutants": ["```python\n# property to violate: If the graph is directed, the function should raise a `NetworkXNotImplemented` exception, indicating that the average clustering coefficient cannot be computed for directed graphs.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms import approximation\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_1():\n    G = nx.DiGraph()\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    # Modify the output to not raise an exception\n    approximation.average_clustering = lambda G, trials, seed=None: 0.5  # Return a dummy value\n    assert False, \"Expected NetworkXNotImplemented exception for directed graph\"\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_2():\n    G = nx.DiGraph()\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    # Modify the output to not raise an exception\n    approximation.average_clustering = lambda G, trials, seed=None: 1.0  # Return a dummy value\n    assert False, \"Expected NetworkXNotImplemented exception for directed graph\"\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_3():\n    G = nx.DiGraph()\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    # Modify the output to not raise an exception\n    approximation.average_clustering = lambda G, trials, seed=None: -0.1  # Return a negative value\n    assert False, \"Expected NetworkXNotImplemented exception for directed graph\"\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_4():\n    G = nx.DiGraph()\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    # Modify the output to not raise an exception\n    approximation.average_clustering = lambda G, trials, seed=None: 2.0  # Return a value greater than 1\n    assert False, \"Expected NetworkXNotImplemented exception for directed graph\"\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_approximation_clustering_coefficient_average_clustering_5():\n    G = nx.DiGraph()\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    # Modify the output to not raise an exception\n    approximation.average_clustering = lambda G, trials, seed=None: \"not a float\"  # Return a non-float value\n    assert False, \"Expected NetworkXNotImplemented exception for directed graph\"\n```"], "property": "If the graph is directed, the function should raise a `NetworkXNotImplemented` exception, indicating that the average clustering coefficient cannot be computed for directed graphs.", "pbt": "@given(st.data())\ndef test_directed_graph_not_implemented_property(data):\n    G = nx.DiGraph()\n    trials = data.draw(st.integers(min_value=1, max_value=1000))\n    try:\n        approximation.average_clustering(G, trials=trials)\n        assert False, \"Expected NetworkXNotImplemented exception for directed graph\"\n    except nx.NetworkXNotImplemented:\n        pass  # Expected behavior, test passes", "properties": ["1. The output value must be between 0 and 1, inclusive, since the average clustering coefficient represents a fraction of triangles and cannot exceed this range.", "3. The output should be consistent across multiple runs with the same input parameters (graph and trials) when a fixed random seed is provided, ensuring reproducibility.", "4. The output should be approximately equal to the average clustering coefficient calculated using a deterministic method for large graphs, as the approximation should converge to the true value with an adequate number of trials.", "5. If the graph is directed, the function should raise a `NetworkXNotImplemented` exception, indicating that the average clustering coefficient cannot be computed for directed graphs."]}
