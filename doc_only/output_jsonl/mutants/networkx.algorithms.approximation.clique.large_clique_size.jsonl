{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: The output size of the large clique must be a non-negative integer, as it represents the number of nodes in the clique.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.approximation import large_clique_size\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    clique_size = -1  # Violating the property by making it negative\n    assert clique_size >= 0\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    clique_size = -5  # Violating the property by making it a negative integer\n    assert clique_size >= 0\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    clique_size = float('-inf')  # Violating the property by making it negative infinity\n    assert clique_size >= 0\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    clique_size = \"not an integer\"  # Violating the property by making it a string\n    assert clique_size >= 0\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    clique_size = None  # Violating the property by making it None\n    assert clique_size >= 0\n```"], "property": "The output size of the large clique must be a non-negative integer, as it represents the number of nodes in the clique.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_large_clique_size_non_negative_integer(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size >= 0", "properties": ["1. The output size of the large clique must be a non-negative integer, as it represents the number of nodes in the clique.", "2. The output size of the large clique must not exceed the total number of nodes in the input graph \\( G \\).", "3. If the input graph \\( G \\) is empty (i.e., has no nodes), the output should be zero, indicating that there are no cliques.", "4. The output size of the large clique must be less than or equal to the maximum degree of the graph plus one, as this is a theoretical upper bound on the size of a clique.", "5. If the input graph \\( G \\) is disconnected (i.e., contains multiple components), the output size should reflect the largest clique found in any of the connected components of the graph."]}
{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: The output size of the large clique must not exceed the total number of nodes in the input graph \\( G \\).\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.approximation import large_clique_size\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G) + 1  # Violation: output exceeds node count\n    assert clique_size <= len(graph_nodes)\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = len(graph_nodes) + 10  # Violation: output is significantly larger than node count\n    assert clique_size <= len(graph_nodes)\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = len(graph_nodes) + 5  # Violation: output exceeds node count\n    assert clique_size <= len(graph_nodes)\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = (len(graph_nodes) * 2)  # Violation: output is double the node count\n    assert clique_size <= len(graph_nodes)\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = len(graph_nodes) + len(graph_nodes)  # Violation: output equals double the node count\n    assert clique_size <= len(graph_nodes)\n```"], "property": "The output size of the large clique must not exceed the total number of nodes in the input graph \\( G \\).", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_large_clique_size_not_exceeding_node_count(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size <= len(graph_nodes)", "properties": ["1. The output size of the large clique must be a non-negative integer, as it represents the number of nodes in the clique.", "2. The output size of the large clique must not exceed the total number of nodes in the input graph \\( G \\).", "3. If the input graph \\( G \\) is empty (i.e., has no nodes), the output should be zero, indicating that there are no cliques.", "4. The output size of the large clique must be less than or equal to the maximum degree of the graph plus one, as this is a theoretical upper bound on the size of a clique.", "5. If the input graph \\( G \\) is disconnected (i.e., contains multiple components), the output size should reflect the largest clique found in any of the connected components of the graph."]}
{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: If the input graph \\( G \\) is empty (i.e., has no nodes), the output should be zero, indicating that there are no cliques.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.approximation.clique import large_clique_size\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size == 1  # Violation: should be 0 for an empty graph\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size == 10  # Violation: should be 0 for an empty graph\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size == -1  # Violation: should be 0 for an empty graph\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size == 5  # Violation: should be 0 for an empty graph\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size == 100  # Violation: should be 0 for an empty graph\n```"], "property": "If the input graph \\( G \\) is empty (i.e., has no nodes), the output should be zero, indicating that there are no cliques.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0))\ndef test_large_clique_size_empty_graph(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size == 0", "properties": ["1. The output size of the large clique must be a non-negative integer, as it represents the number of nodes in the clique.", "2. The output size of the large clique must not exceed the total number of nodes in the input graph \\( G \\).", "3. If the input graph \\( G \\) is empty (i.e., has no nodes), the output should be zero, indicating that there are no cliques.", "4. The output size of the large clique must be less than or equal to the maximum degree of the graph plus one, as this is a theoretical upper bound on the size of a clique.", "5. If the input graph \\( G \\) is disconnected (i.e., contains multiple components), the output size should reflect the largest clique found in any of the connected components of the graph."]}
{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: The output size of the large clique must be less than or equal to the maximum degree of the graph plus one, as this is a theoretical upper bound on the size of a clique.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.approximation.clique import large_clique_size\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    G.add_edges_from([(i, j) for i in range(len(graph_nodes)) for j in range(i + 1, len(graph_nodes))])\n    max_degree = max(dict(G.degree()).values())\n    clique_size = large_clique_size(G) + 10  # Violating the property by adding 10\n    assert clique_size <= max_degree + 1\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    G.add_edges_from([(i, j) for i in range(len(graph_nodes)) for j in range(i + 1, len(graph_nodes))])\n    max_degree = max(dict(G.degree()).values())\n    clique_size = large_clique_size(G) + max_degree + 1  # Violating the property by exceeding the upper bound\n    assert clique_size <= max_degree + 1\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    G.add_edges_from([(i, j) for i in range(len(graph_nodes)) for j in range(i + 1, len(graph_nodes))])\n    max_degree = max(dict(G.degree()).values())\n    clique_size = large_clique_size(G) * 2  # Violating the property by doubling the output\n    assert clique_size <= max_degree + 1\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    G.add_edges_from([(i, j) for i in range(len(graph_nodes)) for j in range(i + 1, len(graph_nodes))])\n    max_degree = max(dict(G.degree()).values())\n    clique_size = large_clique_size(G) + max_degree + 5  # Violating the property by adding max_degree + 5\n    assert clique_size <= max_degree + 1\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    G.add_edges_from([(i, j) for i in range(len(graph_nodes)) for j in range(i + 1, len(graph_nodes))])\n    max_degree = max(dict(G.degree()).values())\n    clique_size = large_clique_size(G) + 100  # Violating the property by adding 100\n    assert clique_size <= max_degree + 1\n```"], "property": "The output size of the large clique must be less than or equal to the maximum degree of the graph plus one, as this is a theoretical upper bound on the size of a clique.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_large_clique_size_bounded_by_max_degree(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    G.add_edges_from([(i, j) for i in range(len(graph_nodes)) for j in range(i + 1, len(graph_nodes))])\n    max_degree = max(dict(G.degree()).values())\n    clique_size = large_clique_size(G)\n    assert clique_size <= max_degree + 1", "properties": ["1. The output size of the large clique must be a non-negative integer, as it represents the number of nodes in the clique.", "2. The output size of the large clique must not exceed the total number of nodes in the input graph \\( G \\).", "3. If the input graph \\( G \\) is empty (i.e., has no nodes), the output should be zero, indicating that there are no cliques.", "4. The output size of the large clique must be less than or equal to the maximum degree of the graph plus one, as this is a theoretical upper bound on the size of a clique.", "5. If the input graph \\( G \\) is disconnected (i.e., contains multiple components), the output size should reflect the largest clique found in any of the connected components of the graph."]}
{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: If the input graph \\( G \\) is disconnected (i.e., contains multiple components), the output size should reflect the largest clique found in any of the connected components of the graph.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.approximation.clique import large_clique_size\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create disconnected components\n    for i in range(0, len(graph_nodes), 2):\n        if i + 1 < len(graph_nodes):\n            G.add_edge(graph_nodes[i], graph_nodes[i + 1])\n    clique_size = large_clique_size(G)\n    # Violate by returning a constant value\n    assert clique_size == 100  # This violates the property\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create disconnected components\n    for i in range(0, len(graph_nodes), 2):\n        if i + 1 < len(graph_nodes):\n            G.add_edge(graph_nodes[i], graph_nodes[i + 1])\n    clique_size = large_clique_size(G)\n    # Violate by returning a value larger than possible cliques\n    assert clique_size > max(2, len(graph_nodes) // 2) + 1  # This violates the property\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create disconnected components\n    for i in range(0, len(graph_nodes), 2):\n        if i + 1 < len(graph_nodes):\n            G.add_edge(graph_nodes[i], graph_nodes[i + 1])\n    clique_size = large_clique_size(G)\n    # Violate by returning a negative size\n    assert clique_size < 0  # This violates the property\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create disconnected components\n    for i in range(0, len(graph_nodes), 2):\n        if i + 1 < len(graph_nodes):\n            G.add_edge(graph_nodes[i], graph_nodes[i + 1])\n    clique_size = large_clique_size(G)\n    # Violate by returning a size of 0 when there are cliques\n    assert clique_size == 0  # This violates the property\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create disconnected components\n    for i in range(0, len(graph_nodes), 2):\n        if i + 1 < len(graph_nodes):\n            G.add_edge(graph_nodes[i], graph_nodes[i + 1])\n    clique_size = large_clique_size(G)\n    # Violate by returning a size that is inconsistent with the input\n    assert clique_size == len(graph_nodes)  # This violates the property\n```"], "property": "If the input graph \\( G \\) is disconnected (i.e., contains multiple components), the output size should reflect the largest clique found in any of the connected components of the graph.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_large_clique_size_disconnected_graph(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create disconnected components\n    for i in range(0, len(graph_nodes), 2):\n        if i + 1 < len(graph_nodes):\n            G.add_edge(graph_nodes[i], graph_nodes[i + 1])\n    clique_size = large_clique_size(G)\n    assert clique_size <= max(2, len(graph_nodes) // 2)", "properties": ["1. The output size of the large clique must be a non-negative integer, as it represents the number of nodes in the clique.", "2. The output size of the large clique must not exceed the total number of nodes in the input graph \\( G \\).", "3. If the input graph \\( G \\) is empty (i.e., has no nodes), the output should be zero, indicating that there are no cliques.", "4. The output size of the large clique must be less than or equal to the maximum degree of the graph plus one, as this is a theoretical upper bound on the size of a clique.", "5. If the input graph \\( G \\) is disconnected (i.e., contains multiple components), the output size should reflect the largest clique found in any of the connected components of the graph."]}
