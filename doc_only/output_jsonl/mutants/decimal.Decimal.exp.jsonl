{"function_name": "decimal.Decimal.exp", "mutants": ["```python\n# property to violate: The output should be equal to 1 when the input is 0, since \\( e^0 = 1 \\).\nfrom hypothesis import given, strategies as st\nimport decimal\n\n@given(st.just(0))\ndef test_violation_of_decimal_Decimal_exp_1():\n    result = decimal.Decimal(0).exp()\n    assert result == decimal.Decimal(2)  # Violates the property\n\n@given(st.just(0))\ndef test_violation_of_decimal_Decimal_exp_2():\n    result = decimal.Decimal(0).exp()\n    assert result == decimal.Decimal(3)  # Violates the property\n\n@given(st.just(0))\ndef test_violation_of_decimal_Decimal_exp_3():\n    result = decimal.Decimal(0).exp()\n    assert result == decimal.Decimal(0)  # Violates the property\n\n@given(st.just(0))\ndef test_violation_of_decimal_Decimal_exp_4():\n    result = decimal.Decimal(0).exp()\n    assert result == decimal.Decimal(-1)  # Violates the property\n\n@given(st.just(0))\ndef test_violation_of_decimal_Decimal_exp_5():\n    result = decimal.Decimal(0).exp()\n    assert result == decimal.Decimal('1.5')  # Violates the property\n```"], "property": "The output should be equal to 1 when the input is 0, since \\( e^0 = 1 \\).", "pbt": "@given(st.just(0))\ndef test_exp_of_zero_property(x):\n    result = Decimal(x).exp()\n    assert result == Decimal(1)", "properties": ["2. The output should be equal to 1 when the input is 0, since \\( e^0 = 1 \\).", "5. The output should grow without bound as the input approaches positive infinity, meaning that \\( e^x \\) should tend to infinity as \\( x \\) increases indefinitely."]}
{"function_name": "decimal.Decimal.exp", "mutants": ["```python\n# property to violate: The output should grow without bound as the input approaches positive infinity, meaning that \\( e^x \\) should tend to infinity as \\( x \\) increases indefinitely.\nfrom hypothesis import given, strategies as st\nimport decimal\n\n@given(st.decimals(min_value=0, max_value=1e100))  # Limiting to avoid overflow\ndef test_violation_of_decimal_Decimal_exp_1(x):\n    result = decimal.Decimal(x).exp()\n    assert result < 1  # Violating the property by asserting that exp(x) is less than 1\n\n@given(st.decimals(min_value=0, max_value=1e100))  # Limiting to avoid overflow\ndef test_violation_of_decimal_Decimal_exp_2(x):\n    result = decimal.Decimal(x).exp()\n    assert result == 1  # Violating the property by asserting that exp(x) is exactly 1\n\n@given(st.decimals(min_value=0, max_value=1e100))  # Limiting to avoid overflow\ndef test_violation_of_decimal_Decimal_exp_3(x):\n    result = decimal.Decimal(x).exp()\n    assert result <= 0  # Violating the property by asserting that exp(x) is less than or equal to 0\n\n@given(st.decimals(min_value=0, max_value=1e100))  # Limiting to avoid overflow\ndef test_violation_of_decimal_Decimal_exp_4(x):\n    result = decimal.Decimal(x).exp()\n    assert result == decimal.Decimal('2.718281828459045235360287471')  # Violating the property by asserting that exp(x) is a constant value\n\n@given(st.decimals(min_value=0, max_value=1e100))  # Limiting to avoid overflow\ndef test_violation_of_decimal_Decimal_exp_5(x):\n    result = decimal.Decimal(x).exp()\n    assert result < decimal.Decimal('2.718281828459045235360287471')  # Violating the property by asserting that exp(x) is less than a specific value\n```"], "property": "The output should grow without bound as the input approaches positive infinity, meaning that \\( e^x \\) should tend to infinity as \\( x \\) increases indefinitely.", "pbt": "@given(st.decimals(min_value=0, max_value=1e100))  # Limiting to avoid overflow\ndef test_exp_grows_without_bound_as_input_positive_infinity_property(x):\n    result = Decimal(x).exp()\n    assert result > 0  # For large positive x, exp(x) should grow large", "properties": ["2. The output should be equal to 1 when the input is 0, since \\( e^0 = 1 \\).", "5. The output should grow without bound as the input approaches positive infinity, meaning that \\( e^x \\) should tend to infinity as \\( x \\) increases indefinitely."]}
