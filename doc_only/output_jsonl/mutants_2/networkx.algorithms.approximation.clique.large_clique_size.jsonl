{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: The output size of the large clique must be a non-negative integer, as it represents the number of nodes in the clique.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.approximation import large_clique_size\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = -1  # Violating the property by returning a negative integer\n    assert clique_size >= 0\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = -5  # Violating the property by returning a negative integer\n    assert clique_size >= 0\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = -10  # Violating the property by returning a negative integer\n    assert clique_size >= 0\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = -100  # Violating the property by returning a negative integer\n    assert clique_size >= 0\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = float('-inf')  # Violating the property by returning a negative float\n    assert clique_size >= 0\n```"], "property": "The output size of the large clique must be a non-negative integer, as it represents the number of nodes in the clique.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_large_clique_size_non_negative_integer(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size >= 0", "properties": ["1. The output size of the large clique must be a non-negative integer, as it represents the number of nodes in the clique.", "2. The output size of the large clique must not exceed the total number of nodes in the input graph \\( G \\).", "3. If the input graph \\( G \\) is empty (i.e., has no nodes), the output should be zero, indicating that there are no cliques.", "4. The output size of the large clique must be less than or equal to the maximum degree of the graph plus one, as this is a theoretical upper bound on the size of a clique.", "5. If the input graph \\( G \\) is disconnected (i.e., contains multiple components), the output size should reflect the largest clique found in any of the connected components of the graph."]}
{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: The output size of the large clique must not exceed the total number of nodes in the input graph \\( G \\).\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.approximation import large_clique_size\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G) + 1  # Violate by adding 1\n    assert clique_size <= len(graph_nodes)\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = len(graph_nodes) + 5  # Violate by adding 5\n    assert clique_size <= len(graph_nodes)\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = len(graph_nodes) * 2  # Violate by doubling the size\n    assert clique_size <= len(graph_nodes)\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = 101  # Violate by using a fixed number greater than any possible node count\n    assert clique_size <= len(graph_nodes)\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = len(graph_nodes) + len(graph_nodes) // 2  # Violate by adding half of the node count\n    assert clique_size <= len(graph_nodes)\n```"], "property": "The output size of the large clique must not exceed the total number of nodes in the input graph \\( G \\).", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=100))\ndef test_large_clique_size_not_exceeding_node_count(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size <= len(graph_nodes)", "properties": ["1. The output size of the large clique must be a non-negative integer, as it represents the number of nodes in the clique.", "2. The output size of the large clique must not exceed the total number of nodes in the input graph \\( G \\).", "3. If the input graph \\( G \\) is empty (i.e., has no nodes), the output should be zero, indicating that there are no cliques.", "4. The output size of the large clique must be less than or equal to the maximum degree of the graph plus one, as this is a theoretical upper bound on the size of a clique.", "5. If the input graph \\( G \\) is disconnected (i.e., contains multiple components), the output size should reflect the largest clique found in any of the connected components of the graph."]}
{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: If the input graph \\( G \\) is empty (i.e., has no nodes), the output should be zero, indicating that there are no cliques.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.approximation import large_clique_size\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size == 1  # Violation: Should be 0 for an empty graph\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size == 10  # Violation: Should be 0 for an empty graph\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size == -1  # Violation: Should be 0 for an empty graph\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size == 5  # Violation: Should be 0 for an empty graph\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size == 100  # Violation: Should be 0 for an empty graph\n```"], "property": "If the input graph \\( G \\) is empty (i.e., has no nodes), the output should be zero, indicating that there are no cliques.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=0, max_size=0))\ndef test_large_clique_size_empty_graph(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    clique_size = large_clique_size(G)\n    assert clique_size == 0", "properties": ["1. The output size of the large clique must be a non-negative integer, as it represents the number of nodes in the clique.", "2. The output size of the large clique must not exceed the total number of nodes in the input graph \\( G \\).", "3. If the input graph \\( G \\) is empty (i.e., has no nodes), the output should be zero, indicating that there are no cliques.", "4. The output size of the large clique must be less than or equal to the maximum degree of the graph plus one, as this is a theoretical upper bound on the size of a clique.", "5. If the input graph \\( G \\) is disconnected (i.e., contains multiple components), the output size should reflect the largest clique found in any of the connected components of the graph."]}
{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: The output size of the large clique must be less than or equal to the maximum degree of the graph plus one, as this is a theoretical upper bound on the size of a clique.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.approximation import large_clique_size\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    G.add_edges_from([(i, j) for i in range(len(graph_nodes)) for j in range(i + 1, len(graph_nodes))])\n    max_degree = max(dict(G.degree()).values())\n    clique_size = large_clique_size(G) + 2  # Violate property by adding 2\n    assert clique_size <= max_degree + 1\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    G.add_edges_from([(i, j) for i in range(len(graph_nodes)) for j in range(i + 1, len(graph_nodes))])\n    max_degree = max(dict(G.degree()).values())\n    clique_size = large_clique_size(G) + 3  # Violate property by adding 3\n    assert clique_size <= max_degree + 1\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    G.add_edges_from([(i, j) for i in range(len(graph_nodes)) for j in range(i + 1, len(graph_nodes))])\n    max_degree = max(dict(G.degree()).values())\n    clique_size = large_clique_size(G) + max_degree + 1  # Violate property by making it larger than the bound\n    assert clique_size <= max_degree + 1\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    G.add_edges_from([(i, j) for i in range(len(graph_nodes)) for j in range(i + 1, len(graph_nodes))])\n    max_degree = max(dict(G.degree()).values())\n    clique_size = large_clique_size(G) * 2  # Violate property by doubling the size\n    assert clique_size <= max_degree + 1\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    G.add_edges_from([(i, j) for i in range(len(graph_nodes)) for j in range(i + 1, len(graph_nodes))])\n    max_degree = max(dict(G.degree()).values())\n    clique_size = large_clique_size(G) + (max_degree + 5)  # Violate property by adding more than the upper bound\n    assert clique_size <= max_degree + 1\n```"], "property": "The output size of the large clique must be less than or equal to the maximum degree of the graph plus one, as this is a theoretical upper bound on the size of a clique.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_large_clique_size_bounded_by_max_degree(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    G.add_edges_from([(i, j) for i in range(len(graph_nodes)) for j in range(i + 1, len(graph_nodes))])\n    max_degree = max(dict(G.degree()).values())\n    clique_size = large_clique_size(G)\n    assert clique_size <= max_degree + 1", "properties": ["1. The output size of the large clique must be a non-negative integer, as it represents the number of nodes in the clique.", "2. The output size of the large clique must not exceed the total number of nodes in the input graph \\( G \\).", "3. If the input graph \\( G \\) is empty (i.e., has no nodes), the output should be zero, indicating that there are no cliques.", "4. The output size of the large clique must be less than or equal to the maximum degree of the graph plus one, as this is a theoretical upper bound on the size of a clique.", "5. If the input graph \\( G \\) is disconnected (i.e., contains multiple components), the output size should reflect the largest clique found in any of the connected components of the graph."]}
{"function_name": "networkx.algorithms.approximation.clique.large_clique_size", "mutants": ["```python\n# property to violate: If the input graph \\( G \\) is disconnected (i.e., contains multiple components), the output size should reflect the largest clique found in any of the connected components of the graph.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.approximation import large_clique_size\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_1(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create disconnected components\n    for i in range(0, len(graph_nodes), 2):\n        if i + 1 < len(graph_nodes):\n            G.add_edge(graph_nodes[i], graph_nodes[i + 1])\n    clique_size = large_clique_size(G)\n    # Violating the property by returning a fixed large number\n    assert clique_size <= max(2, len(graph_nodes) // 2)  # This assertion is kept, but the output is manipulated.\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_2(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create disconnected components\n    for i in range(0, len(graph_nodes), 2):\n        if i + 1 < len(graph_nodes):\n            G.add_edge(graph_nodes[i], graph_nodes[i + 1])\n    clique_size = large_clique_size(G)\n    # Violating the property by returning a value larger than the maximum possible clique size\n    assert clique_size <= max(2, len(graph_nodes) // 2)  # This assertion is kept, but the output is manipulated.\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_3(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create disconnected components\n    for i in range(0, len(graph_nodes), 2):\n        if i + 1 < len(graph_nodes):\n            G.add_edge(graph_nodes[i], graph_nodes[i + 1])\n    clique_size = large_clique_size(G)\n    # Violating the property by returning a negative number\n    clique_size = -1  # This manipulation violates the property\n    assert clique_size <= max(2, len(graph_nodes) // 2)  # This assertion is kept.\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_4(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create disconnected components\n    for i in range(0, len(graph_nodes), 2):\n        if i + 1 < len(graph_nodes):\n            G.add_edge(graph_nodes[i], graph_nodes[i + 1])\n    clique_size = large_clique_size(G)\n    # Violating the property by returning a value that is not a valid clique size\n    clique_size = len(graph_nodes) + 10  # This manipulation violates the property\n    assert clique_size <= max(2, len(graph_nodes) // 2)  # This assertion is kept.\n\n@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_violation_of_networkx_algorithms_approximation_clique_large_clique_size_5(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create disconnected components\n    for i in range(0, len(graph_nodes), 2):\n        if i + 1 < len(graph_nodes):\n            G.add_edge(graph_nodes[i], graph_nodes[i + 1])\n    clique_size = large_clique_size(G)\n    # Violating the property by returning a value that is too small\n    clique_size = 0  # This manipulation violates the property\n    assert clique_size <= max(2, len(graph_nodes) // 2)  # This assertion is kept.\n```"], "property": "If the input graph \\( G \\) is disconnected (i.e., contains multiple components), the output size should reflect the largest clique found in any of the connected components of the graph.", "pbt": "@given(st.lists(st.integers(min_value=0, max_value=100), min_size=1, max_size=100))\ndef test_large_clique_size_disconnected_graph(graph_nodes):\n    G = nx.Graph()\n    G.add_nodes_from(graph_nodes)\n    # Create disconnected components\n    for i in range(0, len(graph_nodes), 2):\n        if i + 1 < len(graph_nodes):\n            G.add_edge(graph_nodes[i], graph_nodes[i + 1])\n    clique_size = large_clique_size(G)\n    assert clique_size <= max(2, len(graph_nodes) // 2)", "properties": ["1. The output size of the large clique must be a non-negative integer, as it represents the number of nodes in the clique.", "2. The output size of the large clique must not exceed the total number of nodes in the input graph \\( G \\).", "3. If the input graph \\( G \\) is empty (i.e., has no nodes), the output should be zero, indicating that there are no cliques.", "4. The output size of the large clique must be less than or equal to the maximum degree of the graph plus one, as this is a theoretical upper bound on the size of a clique.", "5. If the input graph \\( G \\) is disconnected (i.e., contains multiple components), the output size should reflect the largest clique found in any of the connected components of the graph."]}
