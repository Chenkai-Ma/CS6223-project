{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: The median of a non-empty list of numbers should always be a number (either an integer or a float).\nfrom hypothesis import given, strategies as st\nimport statistics\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_1(data):\n    result = \"not a number\"  # Violating the property by returning a string\n    assert isinstance(result, (int, float))\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_2(data):\n    result = None  # Violating the property by returning None\n    assert isinstance(result, (int, float))\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_3(data):\n    result = []  # Violating the property by returning an empty list\n    assert isinstance(result, (int, float))\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_4(data):\n    result = {}  # Violating the property by returning an empty dictionary\n    assert isinstance(result, (int, float))\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_5(data):\n    result = object()  # Violating the property by returning an object\n    assert isinstance(result, (int, float))\n```"], "property": "The median of a non-empty list of numbers should always be a number (either an integer or a float).", "pbt": "@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_median_non_empty_output_property(data):\n    result = statistics.median(data)\n    assert isinstance(result, (int, float))", "properties": ["1. The median of a non-empty list of numbers should always be a number (either an integer or a float).", "2. If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.", "3. If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.", "5. The median should raise a StatisticsError when the input list is empty."]}
{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.\nfrom hypothesis import given, strategies as st\nimport statistics\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_1(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        # Modify the result to be something other than the middle element\n        assert result != sorted_data[len(sorted_data) // 2]\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_2(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        # Change the result to be the first element of the sorted list\n        assert result != sorted_data[0]\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_3(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        # Change the result to be the last element of the sorted list\n        assert result != sorted_data[-1]\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_4(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        # Modify the result to be a value that is not in the sorted list\n        assert result != sorted_data[len(sorted_data) // 2] + 1\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_violation_of_statistics_median_5(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        # Change the result to be the average of the first and last elements\n        assert result != (sorted_data[0] + sorted_data[-1]) / 2\n```"], "property": "If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.", "pbt": "@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))\ndef test_median_odd_length_property(data):\n    if len(data) % 2 == 1:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        assert result == sorted_data[len(sorted_data) // 2]", "properties": ["1. The median of a non-empty list of numbers should always be a number (either an integer or a float).", "2. If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.", "3. If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.", "5. The median should raise a StatisticsError when the input list is empty."]}
{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.\nfrom hypothesis import given, strategies as st\nimport statistics\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_violation_of_statistics_median_1(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        assert result == (sorted_data[len(sorted_data) // 2 - 1] + sorted_data[len(sorted_data) // 2]) / 2 + 1  # Adding 1 to violate the property\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_violation_of_statistics_median_2(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        assert result == (sorted_data[len(sorted_data) // 2 - 1] + sorted_data[len(sorted_data) // 2]) / 2 - 1  # Subtracting 1 to violate the property\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_violation_of_statistics_median_3(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        assert result == (sorted_data[len(sorted_data) // 2 - 1] + sorted_data[len(sorted_data) // 2]) / 2 * 2  # Doubling the median to violate the property\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_violation_of_statistics_median_4(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        assert result == (sorted_data[len(sorted_data) // 2 - 1] + sorted_data[len(sorted_data) // 2]) / 2 / 2  # Halving the median to violate the property\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_violation_of_statistics_median_5(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        assert result == (sorted_data[len(sorted_data) // 2 - 1] + sorted_data[len(sorted_data) // 2]) / 2 + sorted_data[len(sorted_data) // 2]  # Adding an extra middle element to violate the property\n```"], "property": "If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.", "pbt": "@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2))\ndef test_median_even_length_property(data):\n    if len(data) % 2 == 0:\n        sorted_data = sorted(data)\n        result = statistics.median(sorted_data)\n        assert result == (sorted_data[len(sorted_data) // 2 - 1] + sorted_data[len(sorted_data) // 2]) / 2", "properties": ["1. The median of a non-empty list of numbers should always be a number (either an integer or a float).", "2. If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.", "3. If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.", "5. The median should raise a StatisticsError when the input list is empty."]}
{"function_name": "statistics.median", "mutants": ["```python\n# property to violate: The median should raise a StatisticsError when the input list is empty.\nfrom hypothesis import given, strategies as st\nimport statistics\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_violation_of_statistics_median_1(data):\n    if len(data) == 0:\n        # Modify to not raise an error\n        result = statistics.median(data)\n        assert result == 0, \"Expected result to be 0 for empty input\"  # Violation\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_violation_of_statistics_median_2(data):\n    if len(data) == 0:\n        # Modify to return a fixed number instead of raising an error\n        result = statistics.median(data)\n        assert result == 1, \"Expected result to be 1 for empty input\"  # Violation\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_violation_of_statistics_median_3(data):\n    if len(data) == 0:\n        # Modify to return None instead of raising an error\n        result = statistics.median(data)\n        assert result is None, \"Expected result to be None for empty input\"  # Violation\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_violation_of_statistics_median_4(data):\n    if len(data) == 0:\n        # Modify to return a random float instead of raising an error\n        result = statistics.median(data)\n        assert result == 42.0, \"Expected result to be 42.0 for empty input\"  # Violation\n\n@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_violation_of_statistics_median_5(data):\n    if len(data) == 0:\n        # Modify to return an empty string instead of raising an error\n        result = statistics.median(data)\n        assert result == \"\", \"Expected result to be an empty string for empty input\"  # Violation\n```"], "property": "The median should raise a StatisticsError when the input list is empty.", "pbt": "@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0))\ndef test_median_empty_input_property(data):\n    if len(data) == 0:\n        try:\n            statistics.median(data)\n            assert False, \"Expected StatisticsError for empty input\"\n        except statistics.StatisticsError:\n            pass  # Expected behavior", "properties": ["1. The median of a non-empty list of numbers should always be a number (either an integer or a float).", "2. If the input list has an odd number of elements, the median should be equal to the middle element when the list is sorted.", "3. If the input list has an even number of elements, the median should be the average of the two middle elements when the list is sorted.", "5. The median should raise a StatisticsError when the input list is empty."]}
