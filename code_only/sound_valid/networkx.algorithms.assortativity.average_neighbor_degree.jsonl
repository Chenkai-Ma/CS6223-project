{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "properties": ["1. The average neighbor degree for any node should be non-negative, as it represents an average of degrees of neighboring nodes.", "2. If a node has a degree of zero, its average neighbor degree should be exactly zero, since it has no neighbors.", "3. The average neighbor degree for a node should be equal to the total degree of its neighbors divided by the node's degree, ensuring that the calculation correctly reflects the average.", "4. In an undirected graph, the average neighbor degree should be symmetric; that is, the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "5. The average neighbor degree should be invariant under the addition of nodes with no edges, meaning that adding isolated nodes to the graph should not affect the average neighbor degrees of existing nodes."], "pbt": ["@given(st.data())\ndef test_average_neighbor_degree_non_negative_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    for avg in degrees.values():\n        assert avg >= 0", "@given(st.data())\ndef test_average_neighbor_degree_zero_degree_node_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    G.add_node(0)  # Add a node with zero degree\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    assert degrees.get(0, 0) == 0.0", "@given(st.data())\ndef test_average_neighbor_degree_correctness_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    for node in G.nodes:\n        avg = nx.algorithms.assortativity.average_neighbor_degree(G)[node]\n        neighbors = list(G.neighbors(node))\n        if len(neighbors) > 0:\n            total_degree = sum(G.degree[nbr] for nbr in neighbors)\n            assert avg == total_degree / G.degree[node]", "@given(st.data())\ndef test_average_neighbor_degree_symmetry_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2)))\n    for nodeA in G.nodes:\n        for nodeB in G.neighbors(nodeA):\n            avgA = nx.algorithms.assortativity.average_neighbor_degree(G)[nodeA]\n            avgB = nx.algorithms.assortativity.average_neighbor_degree(G)[nodeB]\n            assert avgA == avgB", "@given(st.data())\ndef test_average_neighbor_degree_invariance_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    original_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    G.add_node(1000)  # Add an isolated node\n    updated_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    for node in original_degrees.keys():\n        assert updated_degrees[node] == original_degrees[node]"], "api_doc": "average_neighbor_degree\naverage_neighbor_degree(G, source='out', target='out', nodes=None, weight=None)[source]\nReturns the average degree of the neighborhood of each node.\n\nIn an undirected graph, the neighborhood N(i) of node i contains the nodes that are connected to i by an edge.\n\nFor directed graphs, N(i) is defined according to the parameter source:\n\nif source is \u2018in\u2019, then N(i) consists of predecessors of node i.\n\nif source is \u2018out\u2019, then N(i) consists of successors of node i.\n\nif source is \u2018in+out\u2019, then N(i) is both predecessors and successors.\n\nThe average neighborhood degree of a node i is\n\n \n \nwhere N(i) are the neighbors of node i and k_j is the degree of node j which belongs to N(i). For weighted graphs, an analogous measure can be defined [1],\n\n \n \nwhere s_i is the weighted degree of node i, w_{ij} is the weight of the edge that links i and j and N(i) are the neighbors of node i.\n\nParameters\n:\nG\nNetworkX graph\nsource\nstring (\u201cin\u201d|\u201dout\u201d|\u201din+out\u201d), optional (default=\u201dout\u201d)\nDirected graphs only. Use \u201cin\u201d- or \u201cout\u201d-neighbors of source node.\n\ntarget\nstring (\u201cin\u201d|\u201dout\u201d|\u201din+out\u201d), optional (default=\u201dout\u201d)\nDirected graphs only. Use \u201cin\u201d- or \u201cout\u201d-degree for target node.\n\nnodes\nlist or iterable, optional (default=G.nodes)\nCompute neighbor degree only for specified nodes.\n\nweight\nstring or None, optional (default=None)\nThe edge attribute that holds the numerical value used as a weight. If None, then each edge has weight 1.\n\nReturns\n:\nd: dict\nA dictionary keyed by node to the average degree of its neighbors.\n\nRaises\n:\nNetworkXError\nIf either source or target are not one of \u2018in\u2019, \u2018out\u2019, or \u2018in+out\u2019. If either source or target is passed for an undirected graph.\n\nSee also\n\naverage_degree_connectivity\nReferences\n\n[1]\nA. Barrat, M. Barth\u00e9lemy, R. Pastor-Satorras, and A. Vespignani, \u201cThe architecture of complex weighted networks\u201d. PNAS 101 (11): 3747\u20133752 (2004).\n\nExamples\n\nG = nx.path_graph(4)\nG.edges[0, 1][\"weight\"] = 5\nG.edges[2, 3][\"weight\"] = 3\nnx.average_neighbor_degree(G)\n{0: 2.0, 1: 1.5, 2: 1.5, 3: 2.0}\nnx.average_neighbor_degree(G, weight=\"weight\")\n{0: 2.0, 1: 1.1666666666666667, 2: 1.25, 3: 2.0}\nG = nx.DiGraph()\nnx.add_path(G, [0, 1, 2, 3])\nnx.average_neighbor_degree(G, source=\"in\", target=\"in\")\n{0: 0.0, 1: 0.0, 2: 1.0, 3: 1.0}\nnx.average_neighbor_degree(G, source=\"out\", target=\"out\")\n{0: 1.0, 1: 1.0, 2: 0.0, 3: 0.0}"}
