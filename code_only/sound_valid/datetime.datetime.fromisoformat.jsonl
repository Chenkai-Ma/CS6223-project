{"function_name": "datetime.datetime.fromisoformat", "properties": ["1. The output should be an instance of the `datetime.datetime` class for valid ISO format strings.", "2. The year, month, and day components of the output should correspond to valid calendar dates, ensuring that the day does not exceed the number of days in the given month and year.", "3. If the input string represents a time of \"24:00\", the output should represent the next day at \"00:00:00\" (midnight) of the corresponding date.", "4. The output's hour, minute, second, and microsecond components should be within their valid ranges (0-23 for hours, 0-59 for minutes, 0-59 for seconds, and 0-999999 for microseconds).", "5. The output should raise a `ValueError` for any input string that does not conform to the ISO 8601 format or represents an invalid date or time."], "pbt": ["# Property 1: The output should be an instance of the datetime.datetime class for valid ISO format strings.\n@given(st.text(min_size=7))\ndef test_output_instance_property(date_string):\n    try:\n        result = datetime.datetime.fromisoformat(date_string)\n        assert isinstance(result, datetime.datetime)\n    except ValueError:\n        pass  # Expecting a ValueError for invalid strings", "# Property 2: The year, month, and day components of the output should correspond to valid calendar dates.\n@given(st.text(min_size=7))\ndef test_valid_calendar_date_property(date_string):\n    try:\n        result = datetime.datetime.fromisoformat(date_string)\n        year, month, day = result.year, result.month, result.day\n        assert 1 <= month <= 12\n        assert 1 <= day <= (datetime.datetime(year, month, 1) + datetime.timedelta(days=31)).day\n    except ValueError:\n        pass  # Expecting a ValueError for invalid strings", "# Property 3: If the input string represents a time of \"24:00\", the output should represent the next day at \"00:00:00\".\n@given(st.text(min_size=7))\ndef test_midnight_next_day_property(date_string):\n    if '24:00' in date_string:\n        try:\n            result = datetime.datetime.fromisoformat(date_string)\n            assert result.hour == 0 and result.minute == 0 and result.second == 0\n        except ValueError:\n            pass  # Expecting a ValueError for invalid strings", "# Property 4: The output's hour, minute, second, and microsecond components should be within their valid ranges.\n@given(st.text(min_size=7))\ndef test_valid_time_component_ranges_property(date_string):\n    try:\n        result = datetime.datetime.fromisoformat(date_string)\n        assert 0 <= result.hour < 24\n        assert 0 <= result.minute < 60\n        assert 0 <= result.second < 60\n        assert 0 <= result.microsecond < 1000000\n    except ValueError:\n        pass  # Expecting a ValueError for invalid strings", "# Property 5: The output should raise a ValueError for any input string that does not conform to the ISO 8601 format.\n@given(st.text())\ndef test_invalid_format_raises_value_error_property(date_string):\n    try:\n        result = datetime.datetime.fromisoformat(date_string)\n    except ValueError:\n        assert True  # Expecting a ValueError for invalid strings\n    else:\n        assert False  # If no exception is raised, then the test fails"], "api_doc": "classmethod datetime.fromisoformat(date_string)\nReturn a datetime corresponding to a date_string in any valid ISO 8601 format, with the following exceptions:\n\nTime zone offsets may have fractional seconds.\n\nThe T separator may be replaced by any single unicode character.\n\nFractional hours and minutes are not supported.\n\nReduced precision dates are not currently supported (YYYY-MM, YYYY).\n\nExtended date representations are not currently supported (\u00b1YYYYYY-MM-DD).\n\nOrdinal dates are not currently supported (YYYY-OOO).\n\nExamples:\n\n>>>\nfrom datetime import datetime\ndatetime.fromisoformat('2011-11-04')\ndatetime.datetime(2011, 11, 4, 0, 0)\ndatetime.fromisoformat('20111104')\ndatetime.datetime(2011, 11, 4, 0, 0)\ndatetime.fromisoformat('2011-11-04T00:05:23')\ndatetime.datetime(2011, 11, 4, 0, 5, 23)\ndatetime.fromisoformat('2011-11-04T00:05:23Z')\ndatetime.datetime(2011, 11, 4, 0, 5, 23, tzinfo=datetime.timezone.utc)\ndatetime.fromisoformat('20111104T000523')\ndatetime.datetime(2011, 11, 4, 0, 5, 23)\ndatetime.fromisoformat('2011-W01-2T00:05:23.283')\ndatetime.datetime(2011, 1, 4, 0, 5, 23, 283000)\ndatetime.fromisoformat('2011-11-04 00:05:23.283')\ndatetime.datetime(2011, 11, 4, 0, 5, 23, 283000)\ndatetime.fromisoformat('2011-11-04 00:05:23.283+00:00')\ndatetime.datetime(2011, 11, 4, 0, 5, 23, 283000, tzinfo=datetime.timezone.utc)\ndatetime.fromisoformat('2011-11-04T00:05:23+04:00')   \ndatetime.datetime(2011, 11, 4, 0, 5, 23,\n    tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))\nAdded in version 3.7.\n\nChanged in version 3.11: Previously, this method only supported formats that could be emitted by date.isoformat() or datetime.isoformat()."}
