{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The output cliques must be subsets of the input graph's nodes, ensuring that all nodes in each returned clique are present in the original graph.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.clique import find_cliques\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    cliques.append([max(graph.nodes) + 1])  # Adding a node that is not in the graph\n    for clique in cliques:\n        assert set(clique).issubset(graph.nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    cliques[0] = [node for node in cliques[0]] + [max(graph.nodes) + 2]  # Modifying the first clique to include a non-existent node\n    for clique in cliques:\n        assert set(clique).issubset(graph.nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    cliques = [[node for node in clique] + [max(graph.nodes) + 3] for clique in cliques]  # Adding an invalid node to all cliques\n    for clique in cliques:\n        assert set(clique).issubset(graph.nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    cliques[-1] = [max(graph.nodes) + 4]  # Changing the last clique to be a single invalid node\n    for clique in cliques:\n        assert set(clique).issubset(graph.nodes)\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    cliques.append([max(graph.nodes) + 5, max(graph.nodes) + 6])  # Adding a clique with two non-existent nodes\n    for clique in cliques:\n        assert set(clique).issubset(graph.nodes)\n```"], "property": "The output cliques must be subsets of the input graph's nodes, ensuring that all nodes in each returned clique are present in the original graph.", "pbt": "@given(st.data())\ndef test_output_nodes_are_subsets_property(data):\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    for clique in cliques:\n        assert set(clique).issubset(graph.nodes)", "properties": ["1. The output cliques must be subsets of the input graph's nodes, ensuring that all nodes in each returned clique are present in the original graph.", "2. Each returned clique must be a complete subgraph, meaning that every pair of nodes within the clique must be directly connected by an edge in the graph.", "3. The function should yield all maximal cliques, meaning no additional nodes can be added to any returned clique without breaking its completeness.", "4. If the input graph is empty, the function should yield no cliques, returning an empty output.", "5. If specific nodes are provided as input, the function should only yield cliques that include those nodes, and it should raise an error if the provided nodes do not form a clique."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: Each returned clique must be a complete subgraph, meaning that every pair of nodes within the clique must be directly connected by an edge in the graph.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.clique import find_cliques\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    # Modify cliques to ensure at least one pair of nodes in each clique is not connected\n    if cliques:\n        cliques[0].append(max(graph.nodes()) + 1)  # Adding a node that is not in the graph\n    for clique in cliques:\n        for i in range(len(clique)):\n            for j in range(i + 1, len(clique)):\n                assert graph.has_edge(clique[i], clique[j])\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    # Ensure to modify cliques to have an edge missing\n    if cliques:\n        cliques[0].remove(cliques[0][1])  # Remove one node to break the clique\n    for clique in cliques:\n        for i in range(len(clique)):\n            for j in range(i + 1, len(clique)):\n                assert graph.has_edge(clique[i], clique[j])\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    # Introduce a non-adjacent node into each clique\n    if cliques:\n        cliques[0].append(0)  # Assuming 0 is not connected\n    for clique in cliques:\n        for i in range(len(clique)):\n            for j in range(i + 1, len(clique)):\n                assert graph.has_edge(clique[i], clique[j])\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    # Remove edges between nodes in the first clique\n    if cliques:\n        for i in range(len(cliques[0]) - 1):\n            graph.remove_edge(cliques[0][i], cliques[0][i + 1])  # Break the connection\n    for clique in cliques:\n        for i in range(len(clique)):\n            for j in range(i + 1, len(clique)):\n                assert graph.has_edge(clique[i], clique[j])\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    # Create a clique with a missing edge\n    if cliques:\n        cliques[0].append(cliques[0][0])  # Duplicate a node to ensure a missing edge\n    for clique in cliques:\n        for i in range(len(clique)):\n            for j in range(i + 1, len(clique)):\n                assert graph.has_edge(clique[i], clique[j])\n```"], "property": "Each returned clique must be a complete subgraph, meaning that every pair of nodes within the clique must be directly connected by an edge in the graph.", "pbt": "@given(st.data())\ndef test_cliques_are_complete_subgraphs_property(data):\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    for clique in cliques:\n        for i in range(len(clique)):\n            for j in range(i + 1, len(clique)):\n                assert graph.has_edge(clique[i], clique[j])", "properties": ["1. The output cliques must be subsets of the input graph's nodes, ensuring that all nodes in each returned clique are present in the original graph.", "2. Each returned clique must be a complete subgraph, meaning that every pair of nodes within the clique must be directly connected by an edge in the graph.", "3. The function should yield all maximal cliques, meaning no additional nodes can be added to any returned clique without breaking its completeness.", "4. If the input graph is empty, the function should yield no cliques, returning an empty output.", "5. If specific nodes are provided as input, the function should only yield cliques that include those nodes, and it should raise an error if the provided nodes do not form a clique."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: The function should yield all maximal cliques, meaning no additional nodes can be added to any returned clique without breaking its completeness.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.clique import find_cliques\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    cliques[0].append(graph.nodes[0])  # Add a node to the first clique\n    for clique in cliques:\n        # Check that no nodes can be added to the clique without breaking its completeness\n        for node in graph.nodes:\n            if node not in clique and graph.has_edges_from((node, n) for n in clique):\n                assert False  # A node can be added to the clique\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    cliques[1] = cliques[1] + [graph.nodes[1]]  # Add a node to the second clique\n    for clique in cliques:\n        # Check that no nodes can be added to the clique without breaking its completeness\n        for node in graph.nodes:\n            if node not in clique and graph.has_edges_from((node, n) for n in clique):\n                assert False  # A node can be added to the clique\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    cliques.append([graph.nodes[2]])  # Add a new clique that is not maximal\n    for clique in cliques:\n        # Check that no nodes can be added to the clique without breaking its completeness\n        for node in graph.nodes:\n            if node not in clique and graph.has_edges_from((node, n) for n in clique):\n                assert False  # A node can be added to the clique\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    cliques[0] = cliques[0] + [graph.nodes[3]]  # Add a non-adjacent node to the first clique\n    for clique in cliques:\n        # Check that no nodes can be added to the clique without breaking its completeness\n        for node in graph.nodes:\n            if node not in clique and graph.has_edges_from((node, n) for n in clique):\n                assert False  # A node can be added to the clique\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5():\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    cliques[1] = cliques[1][:1]  # Remove nodes from the second clique, making it incomplete\n    for clique in cliques:\n        # Check that no nodes can be added to the clique without breaking its completeness\n        for node in graph.nodes:\n            if node not in clique and graph.has_edges_from((node, n) for n in clique):\n                assert False  # A node can be added to the clique\n```"], "property": "The function should yield all maximal cliques, meaning no additional nodes can be added to any returned clique without breaking its completeness.", "pbt": "@given(st.data())\ndef test_cliques_are_maximal_property(data):\n    graph = data.draw(st.builds(nx.Graph, nodes=st.sets(st.integers(), min_size=1, max_size=100)))\n    cliques = list(find_cliques(graph))\n    for clique in cliques:\n        # Check that no nodes can be added to the clique without breaking its completeness\n        for node in graph.nodes:\n            if node not in clique and graph.has_edges_from((node, n) for n in clique):\n                assert False  # A node can be added to the clique", "properties": ["1. The output cliques must be subsets of the input graph's nodes, ensuring that all nodes in each returned clique are present in the original graph.", "2. Each returned clique must be a complete subgraph, meaning that every pair of nodes within the clique must be directly connected by an edge in the graph.", "3. The function should yield all maximal cliques, meaning no additional nodes can be added to any returned clique without breaking its completeness.", "4. If the input graph is empty, the function should yield no cliques, returning an empty output.", "5. If specific nodes are provided as input, the function should only yield cliques that include those nodes, and it should raise an error if the provided nodes do not form a clique."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: If the input graph is empty, the function should yield no cliques, returning an empty output.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.clique import find_cliques\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1():\n    graph = nx.Graph()\n    cliques = list(find_cliques(graph))\n    assert cliques == [[0]]  # Violating the property by asserting a non-empty list.\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2():\n    graph = nx.Graph()\n    cliques = list(find_cliques(graph))\n    assert cliques == [None]  # Violating the property by asserting a list containing None.\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3():\n    graph = nx.Graph()\n    cliques = list(find_cliques(graph))\n    assert cliques == [[1, 2]]  # Violating the property by asserting a non-empty list with arbitrary nodes.\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4():\n    graph = nx.Graph()\n    cliques = list(find_cliques(graph))\n    assert cliques == [[], []]  # Violating the property by asserting a list containing empty lists.\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5():\n    graph = nx.Graph()\n    cliques = list(find_cliques(graph))\n    assert cliques == [[0, 1, 2]]  # Violating the property by asserting a non-empty list with multiple nodes.\n```"], "property": "If the input graph is empty, the function should yield no cliques, returning an empty output.", "pbt": "@given(st.data())\ndef test_empty_graph_yields_no_cliques_property(data):\n    graph = nx.Graph()\n    cliques = list(find_cliques(graph))\n    assert cliques == []", "properties": ["1. The output cliques must be subsets of the input graph's nodes, ensuring that all nodes in each returned clique are present in the original graph.", "2. Each returned clique must be a complete subgraph, meaning that every pair of nodes within the clique must be directly connected by an edge in the graph.", "3. The function should yield all maximal cliques, meaning no additional nodes can be added to any returned clique without breaking its completeness.", "4. If the input graph is empty, the function should yield no cliques, returning an empty output.", "5. If specific nodes are provided as input, the function should only yield cliques that include those nodes, and it should raise an error if the provided nodes do not form a clique."]}
{"function_name": "networkx.algorithms.clique.find_cliques", "mutants": ["```python\n# property to violate: If specific nodes are provided as input, the function should only yield cliques that include those nodes, and it should raise an error if the provided nodes do not form a clique.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\nfrom networkx.algorithms.clique import find_cliques\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_1():\n    nodes = data.draw(st.sets(st.integers(), min_size=2, max_size=10))\n    graph = nx.complete_graph(nodes)  # Create a complete graph\n    cliques = list(find_cliques(graph, nodes=list(nodes)))\n    assert len(cliques) > 0  # There must be at least one clique, the nodes themselves\n    for clique in cliques:\n        assert set(clique) != set(nodes)  # Must not yield the specified clique\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_2():\n    nodes = data.draw(st.sets(st.integers(), min_size=2, max_size=10))\n    graph = nx.complete_graph(nodes)  # Create a complete graph\n    cliques = list(find_cliques(graph, nodes=list(nodes)))\n    assert len(cliques) > 0  # There must be at least one clique, the nodes themselves\n    for clique in cliques:\n        assert len(clique) > len(nodes)  # Must yield cliques larger than the specified nodes\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_3():\n    nodes = data.draw(st.sets(st.integers(), min_size=2, max_size=10))\n    graph = nx.complete_graph(nodes)  # Create a complete graph\n    cliques = list(find_cliques(graph, nodes=list(nodes)))\n    assert len(cliques) > 0  # There must be at least one clique, the nodes themselves\n    for clique in cliques:\n        assert set(nodes).issubset(set(clique))  # Must yield cliques that do not include the specified nodes\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_4():\n    nodes = data.draw(st.sets(st.integers(), min_size=2, max_size=10))\n    graph = nx.complete_graph(nodes)  # Create a complete graph\n    cliques = list(find_cliques(graph, nodes=list(nodes)))\n    assert len(cliques) > 0  # There must be at least one clique, the nodes themselves\n    for clique in cliques:\n        assert len(clique) < len(nodes)  # Must yield cliques smaller than the specified nodes\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_clique_find_cliques_5():\n    nodes = data.draw(st.sets(st.integers(), min_size=2, max_size=10))\n    graph = nx.complete_graph(nodes)  # Create a complete graph\n    cliques = list(find_cliques(graph, nodes=list(nodes)))\n    assert len(cliques) > 0  # There must be at least one clique, the nodes themselves\n    for clique in cliques:\n        assert set(clique) != set(nodes) and len(clique) == len(nodes)  # Must yield cliques that are the same size but different\n```"], "property": "If specific nodes are provided as input, the function should only yield cliques that include those nodes, and it should raise an error if the provided nodes do not form a clique.", "pbt": "@given(st.data())\ndef test_specific_nodes_must_form_clique_property(data):\n    nodes = data.draw(st.sets(st.integers(), min_size=2, max_size=10))\n    graph = nx.complete_graph(nodes)  # Create a complete graph\n    cliques = list(find_cliques(graph, nodes=list(nodes)))\n    assert len(cliques) > 0  # There must be at least one clique, the nodes themselves\n    for clique in cliques:\n        assert set(clique) == set(nodes)  # Must yield the specified clique", "properties": ["1. The output cliques must be subsets of the input graph's nodes, ensuring that all nodes in each returned clique are present in the original graph.", "2. Each returned clique must be a complete subgraph, meaning that every pair of nodes within the clique must be directly connected by an edge in the graph.", "3. The function should yield all maximal cliques, meaning no additional nodes can be added to any returned clique without breaking its completeness.", "4. If the input graph is empty, the function should yield no cliques, returning an empty output.", "5. If specific nodes are provided as input, the function should only yield cliques that include those nodes, and it should raise an error if the provided nodes do not form a clique."]}
