{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The average neighbor degree for any node should be non-negative, as it represents an average of degrees of neighboring nodes.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    # Modify the output to include negative values\n    for node in degrees:\n        degrees[node] = -1 * abs(degrees[node])  # Ensure negative values\n    for avg in degrees.values():\n        assert avg >= 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    # Modify the output to include negative values\n    for node in degrees:\n        degrees[node] = -0.5  # Set all averages to a negative constant\n    for avg in degrees.values():\n        assert avg >= 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    # Modify the output to include negative values\n    for node in degrees:\n        degrees[node] = -10  # Set all averages to a negative constant\n    for avg in degrees.values():\n        assert avg >= 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    # Modify the output to include negative values\n    for node in degrees:\n        degrees[node] = -1 * (node + 1)  # Create negative averages based on node index\n    for avg in degrees.values():\n        assert avg >= 0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    # Modify the output to include negative values\n    for node in degrees:\n        degrees[node] = -1 * (degrees[node] + 1)  # Ensure all values are negative\n    for avg in degrees.values():\n        assert avg >= 0\n```"], "property": "The average neighbor degree for any node should be non-negative, as it represents an average of degrees of neighboring nodes.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_non_negative_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    for avg in degrees.values():\n        assert avg >= 0", "properties": ["1. The average neighbor degree for any node should be non-negative, as it represents an average of degrees of neighboring nodes.", "2. If a node has a degree of zero, its average neighbor degree should be exactly zero, since it has no neighbors.", "3. The average neighbor degree for a node should be equal to the total degree of its neighbors divided by the node's degree, ensuring that the calculation correctly reflects the average.", "4. In an undirected graph, the average neighbor degree should be symmetric; that is, the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "5. The average neighbor degree should be invariant under the addition of nodes with no edges, meaning that adding isolated nodes to the graph should not affect the average neighbor degrees of existing nodes."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: If a node has a degree of zero, its average neighbor degree should be exactly zero, since it has no neighbors.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    G.add_node(0)  # Add a node with zero degree\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    degrees[0] = 1.0  # Violate the property by setting average neighbor degree to 1.0\n    assert degrees.get(0, 0) == 0.0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    G.add_node(0)  # Add a node with zero degree\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    degrees[0] = -1.0  # Violate the property by setting average neighbor degree to -1.0\n    assert degrees.get(0, 0) == 0.0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    G.add_node(0)  # Add a node with zero degree\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    degrees[0] = 10.0  # Violate the property by setting average neighbor degree to 10.0\n    assert degrees.get(0, 0) == 0.0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    G.add_node(0)  # Add a node with zero degree\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    degrees[0] = 5.5  # Violate the property by setting average neighbor degree to 5.5\n    assert degrees.get(0, 0) == 0.0\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    G.add_node(0)  # Add a node with zero degree\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    degrees[0] = 3.0  # Violate the property by setting average neighbor degree to 3.0\n    assert degrees.get(0, 0) == 0.0\n```"], "property": "If a node has a degree of zero, its average neighbor degree should be exactly zero, since it has no neighbors.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_zero_degree_node_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    G.add_node(0)  # Add a node with zero degree\n    degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    assert degrees.get(0, 0) == 0.0", "properties": ["1. The average neighbor degree for any node should be non-negative, as it represents an average of degrees of neighboring nodes.", "2. If a node has a degree of zero, its average neighbor degree should be exactly zero, since it has no neighbors.", "3. The average neighbor degree for a node should be equal to the total degree of its neighbors divided by the node's degree, ensuring that the calculation correctly reflects the average.", "4. In an undirected graph, the average neighbor degree should be symmetric; that is, the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "5. The average neighbor degree should be invariant under the addition of nodes with no edges, meaning that adding isolated nodes to the graph should not affect the average neighbor degrees of existing nodes."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The average neighbor degree for a node should be equal to the total degree of its neighbors divided by the node's degree, ensuring that the calculation correctly reflects the average.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    for node in G.nodes:\n        avg = nx.algorithms.assortativity.average_neighbor_degree(G)[node]\n        neighbors = list(G.neighbors(node))\n        if len(neighbors) > 0:\n            total_degree = sum(G.degree[nbr] for nbr in neighbors)\n            assert avg != total_degree / G.degree[node]  # Violation: output is made unequal\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    for node in G.nodes:\n        avg = nx.algorithms.assortativity.average_neighbor_degree(G)[node]\n        neighbors = list(G.neighbors(node))\n        if len(neighbors) > 0:\n            total_degree = sum(G.degree[nbr] for nbr in neighbors)\n            assert avg != (total_degree / G.degree[node]) + 1  # Violation: output is offset by +1\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    for node in G.nodes:\n        avg = nx.algorithms.assortativity.average_neighbor_degree(G)[node]\n        neighbors = list(G.neighbors(node))\n        if len(neighbors) > 0:\n            total_degree = sum(G.degree[nbr] for nbr in neighbors)\n            assert avg != total_degree / (G.degree[node] + 1)  # Violation: denominator is increased by 1\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    for node in G.nodes:\n        avg = nx.algorithms.assortativity.average_neighbor_degree(G)[node]\n        neighbors = list(G.neighbors(node))\n        if len(neighbors) > 0:\n            total_degree = sum(G.degree[nbr] for nbr in neighbors)\n            assert avg != total_degree * 2 / G.degree[node]  # Violation: output is doubled\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    for node in G.nodes:\n        avg = nx.algorithms.assortativity.average_neighbor_degree(G)[node]\n        neighbors = list(G.neighbors(node))\n        if len(neighbors) > 0:\n            total_degree = sum(G.degree[nbr] for nbr in neighbors)\n            assert avg != (total_degree / G.degree[node]) * 0.5  # Violation: output is halved\n```"], "property": "The average neighbor degree for a node should be equal to the total degree of its neighbors divided by the node's degree, ensuring that the calculation correctly reflects the average.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_correctness_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    for node in G.nodes:\n        avg = nx.algorithms.assortativity.average_neighbor_degree(G)[node]\n        neighbors = list(G.neighbors(node))\n        if len(neighbors) > 0:\n            total_degree = sum(G.degree[nbr] for nbr in neighbors)\n            assert avg == total_degree / G.degree[node]", "properties": ["1. The average neighbor degree for any node should be non-negative, as it represents an average of degrees of neighboring nodes.", "2. If a node has a degree of zero, its average neighbor degree should be exactly zero, since it has no neighbors.", "3. The average neighbor degree for a node should be equal to the total degree of its neighbors divided by the node's degree, ensuring that the calculation correctly reflects the average.", "4. In an undirected graph, the average neighbor degree should be symmetric; that is, the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "5. The average neighbor degree should be invariant under the addition of nodes with no edges, meaning that adding isolated nodes to the graph should not affect the average neighbor degrees of existing nodes."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: In an undirected graph, the average neighbor degree should be symmetric; that is, the average neighbor degree of node A should equal that of node B if A and B are neighbors.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2)))\n    for nodeA in G.nodes:\n        for nodeB in G.neighbors(nodeA):\n            avgA = nx.algorithms.assortativity.average_neighbor_degree(G)[nodeA]\n            avgB = avgA + 1  # Modify avgB to be different from avgA\n            assert avgA == avgB\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2)))\n    for nodeA in G.nodes:\n        for nodeB in G.neighbors(nodeA):\n            avgA = nx.algorithms.assortativity.average_neighbor_degree(G)[nodeA]\n            avgB = avgA * 2  # Modify avgB to be twice avgA\n            assert avgA == avgB\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2)))\n    for nodeA in G.nodes:\n        for nodeB in G.neighbors(nodeA):\n            avgA = nx.algorithms.assortativity.average_neighbor_degree(G)[nodeA]\n            avgB = avgA - 5  # Modify avgB to be 5 less than avgA\n            assert avgA == avgB\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2)))\n    for nodeA in G.nodes:\n        for nodeB in G.neighbors(nodeA):\n            avgA = nx.algorithms.assortativity.average_neighbor_degree(G)[nodeA]\n            avgB = avgA + 3.5  # Modify avgB to be 3.5 more than avgA\n            assert avgA == avgB\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2)))\n    for nodeA in G.nodes:\n        for nodeB in G.neighbors(nodeA):\n            avgA = nx.algorithms.assortativity.average_neighbor_degree(G)[nodeA]\n            avgB = 0  # Set avgB to a constant value (0) regardless of avgA\n            assert avgA == avgB\n```"], "property": "In an undirected graph, the average neighbor degree should be symmetric; that is, the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_symmetry_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=2)))\n    for nodeA in G.nodes:\n        for nodeB in G.neighbors(nodeA):\n            avgA = nx.algorithms.assortativity.average_neighbor_degree(G)[nodeA]\n            avgB = nx.algorithms.assortativity.average_neighbor_degree(G)[nodeB]\n            assert avgA == avgB", "properties": ["1. The average neighbor degree for any node should be non-negative, as it represents an average of degrees of neighboring nodes.", "2. If a node has a degree of zero, its average neighbor degree should be exactly zero, since it has no neighbors.", "3. The average neighbor degree for a node should be equal to the total degree of its neighbors divided by the node's degree, ensuring that the calculation correctly reflects the average.", "4. In an undirected graph, the average neighbor degree should be symmetric; that is, the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "5. The average neighbor degree should be invariant under the addition of nodes with no edges, meaning that adding isolated nodes to the graph should not affect the average neighbor degrees of existing nodes."]}
{"function_name": "networkx.algorithms.assortativity.average_neighbor_degree", "mutants": ["```python\n# property to violate: The average neighbor degree should be invariant under the addition of nodes with no edges, meaning that adding isolated nodes to the graph should not affect the average neighbor degrees of existing nodes.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_1():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    original_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    G.add_node(1000)  # Add an isolated node\n    updated_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    for node in original_degrees.keys():\n        assert updated_degrees[node] != original_degrees[node]  # Violation: should not be equal\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_2():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    original_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    G.add_node(1000)  # Add an isolated node\n    updated_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    for node in original_degrees.keys():\n        assert updated_degrees[node] > original_degrees[node]  # Violation: should not be greater\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_3():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    original_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    G.add_node(1000)  # Add an isolated node\n    updated_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    for node in original_degrees.keys():\n        assert updated_degrees[node] < original_degrees[node]  # Violation: should not be less\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_4():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    original_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    G.add_node(1000)  # Add an isolated node\n    updated_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    for node in original_degrees.keys():\n        assert updated_degrees[node] == 0  # Violation: should not be zero\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_assortativity_average_neighbor_degree_5():\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    original_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    G.add_node(1000)  # Add an isolated node\n    updated_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    for node in original_degrees.keys():\n        assert updated_degrees[node] == 1  # Violation: should not be 1\n```"], "property": "The average neighbor degree should be invariant under the addition of nodes with no edges, meaning that adding isolated nodes to the graph should not affect the average neighbor degrees of existing nodes.", "pbt": "@given(st.data())\ndef test_average_neighbor_degree_invariance_property(data):\n    G = data.draw(st.builds(nx.Graph, nodes=st.lists(st.integers(), min_size=1)))\n    original_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    G.add_node(1000)  # Add an isolated node\n    updated_degrees = nx.algorithms.assortativity.average_neighbor_degree(G)\n    for node in original_degrees.keys():\n        assert updated_degrees[node] == original_degrees[node]", "properties": ["1. The average neighbor degree for any node should be non-negative, as it represents an average of degrees of neighboring nodes.", "2. If a node has a degree of zero, its average neighbor degree should be exactly zero, since it has no neighbors.", "3. The average neighbor degree for a node should be equal to the total degree of its neighbors divided by the node's degree, ensuring that the calculation correctly reflects the average.", "4. In an undirected graph, the average neighbor degree should be symmetric; that is, the average neighbor degree of node A should equal that of node B if A and B are neighbors.", "5. The average neighbor degree should be invariant under the addition of nodes with no edges, meaning that adding isolated nodes to the graph should not affect the average neighbor degrees of existing nodes."]}
