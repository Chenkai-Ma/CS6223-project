{"function_name": "datetime.date.weekday", "mutants": ["```python\n# property to violate: The output of the `weekday` function should always be an integer between 0 and 6, inclusive.\nfrom hypothesis import given, strategies as st\nimport datetime\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_1(date):\n    result = date.weekday() + 10  # Shift the result to always be >= 10\n    assert 0 <= result <= 6\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_2(date):\n    result = date.weekday() - 1  # Shift the result to always be < 0\n    assert 0 <= result <= 6\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_3(date):\n    result = date.weekday() * 2  # Multiply the result to always be >= 0 and even\n    assert 0 <= result <= 6\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_4(date):\n    result = date.weekday() + 7  # Shift the result to always be >= 7\n    assert 0 <= result <= 6\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_5(date):\n    result = date.weekday() + 3.5  # Change the result to a float\n    assert 0 <= result <= 6\n```"], "property": "The output of the `weekday` function should always be an integer between 0 and 6, inclusive.", "pbt": "@given(st.dates())\ndef test_weekday_output_range_property(date):\n    result = date.weekday()\n    assert 0 <= result <= 6", "properties": ["1. The output of the `weekday` function should always be an integer between 0 and 6, inclusive.", "2. The output value should represent the correct day of the week, where 0 corresponds to Monday and 6 corresponds to Sunday.", "3. The result of the `weekday` function should be consistent for the same date input, meaning that calling the function multiple times with the same date should yield the same result.", "4. The output should change predictably when the input date changes, specifically advancing by 1 for each day increment in the input.", "5. The output should exhibit periodicity, such that the `weekday` function returns the same value for dates that are exactly one week apart."]}
{"function_name": "datetime.date.weekday", "mutants": ["```python\n# property to violate: The output value should represent the correct day of the week, where 0 corresponds to Monday and 6 corresponds to Sunday.\nfrom hypothesis import given, strategies as st\nimport datetime\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_1(date):\n    result = date.weekday()\n    # Incorrectly mapping: 0 = Sunday, 1 = Monday, ..., 6 = Saturday\n    expected_day = (date.toordinal() + 0) % 7\n    assert result == expected_day\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_2(date):\n    result = date.weekday()\n    # Incorrectly mapping: 0 = Wednesday, 1 = Thursday, ..., 6 = Tuesday\n    expected_day = (date.toordinal() + 2) % 7\n    assert result == expected_day\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_3(date):\n    result = date.weekday()\n    # Incorrectly mapping: 0 = Tuesday, 1 = Wednesday, ..., 6 = Monday\n    expected_day = (date.toordinal() + 1) % 7\n    assert result == expected_day\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_4(date):\n    result = date.weekday()\n    # Incorrectly mapping: 0 = Friday, 1 = Saturday, ..., 6 = Thursday\n    expected_day = (date.toordinal() + 4) % 7\n    assert result == expected_day\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_5(date):\n    result = date.weekday()\n    # Incorrectly mapping: Always returning 7, which is out of range\n    expected_day = 7\n    assert result == expected_day\n```"], "property": "The output value should represent the correct day of the week, where 0 corresponds to Monday and 6 corresponds to Sunday.", "pbt": "@given(st.dates())\ndef test_weekday_correct_day_of_week_property(date):\n    result = date.weekday()\n    # Mapping: 0 = Monday, 1 = Tuesday, ..., 6 = Sunday\n    expected_day = (date.toordinal() + 6) % 7\n    assert result == expected_day", "properties": ["1. The output of the `weekday` function should always be an integer between 0 and 6, inclusive.", "2. The output value should represent the correct day of the week, where 0 corresponds to Monday and 6 corresponds to Sunday.", "3. The result of the `weekday` function should be consistent for the same date input, meaning that calling the function multiple times with the same date should yield the same result.", "4. The output should change predictably when the input date changes, specifically advancing by 1 for each day increment in the input.", "5. The output should exhibit periodicity, such that the `weekday` function returns the same value for dates that are exactly one week apart."]}
{"function_name": "datetime.date.weekday", "mutants": ["```python\n# property to violate: The result of the `weekday` function should be consistent for the same date input, meaning that calling the function multiple times with the same date should yield the same result.\nfrom hypothesis import given, strategies as st\nimport datetime\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_1(date):\n    result1 = date.weekday()\n    result2 = (result1 + 1) % 7  # Modify result2 to be inconsistent\n    assert result1 == result2\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_2(date):\n    result1 = date.weekday()\n    result2 = (result1 + 2) % 7  # Modify result2 to be inconsistent\n    assert result1 == result2\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_3(date):\n    result1 = date.weekday()\n    result2 = (result1 + 3) % 7  # Modify result2 to be inconsistent\n    assert result1 == result2\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_4(date):\n    result1 = date.weekday()\n    result2 = (result1 + 4) % 7  # Modify result2 to be inconsistent\n    assert result1 == result2\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_5(date):\n    result1 = date.weekday()\n    result2 = (result1 + 5) % 7  # Modify result2 to be inconsistent\n    assert result1 == result2\n```"], "property": "The result of the `weekday` function should be consistent for the same date input, meaning that calling the function multiple times with the same date should yield the same result.", "pbt": "@given(st.dates())\ndef test_weekday_consistency_property(date):\n    result1 = date.weekday()\n    result2 = date.weekday()\n    assert result1 == result2", "properties": ["1. The output of the `weekday` function should always be an integer between 0 and 6, inclusive.", "2. The output value should represent the correct day of the week, where 0 corresponds to Monday and 6 corresponds to Sunday.", "3. The result of the `weekday` function should be consistent for the same date input, meaning that calling the function multiple times with the same date should yield the same result.", "4. The output should change predictably when the input date changes, specifically advancing by 1 for each day increment in the input.", "5. The output should exhibit periodicity, such that the `weekday` function returns the same value for dates that are exactly one week apart."]}
{"function_name": "datetime.date.weekday", "mutants": ["```python\n# property to violate: The output should change predictably when the input date changes, specifically advancing by 1 for each day increment in the input.\nfrom hypothesis import given, strategies as st\nimport datetime\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_1(date):\n    result_today = date.weekday()\n    tomorrow = date + datetime.timedelta(days=1)\n    result_tomorrow = (result_today + 2) % 7  # Violation: advancing by 2 instead of 1\n    assert result_tomorrow == (result_today + 1) % 7\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_2(date):\n    result_today = date.weekday()\n    tomorrow = date + datetime.timedelta(days=1)\n    result_tomorrow = (result_today + 3) % 7  # Violation: advancing by 3 instead of 1\n    assert result_tomorrow == (result_today + 1) % 7\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_3(date):\n    result_today = date.weekday()\n    tomorrow = date + datetime.timedelta(days=1)\n    result_tomorrow = (result_today + 5) % 7  # Violation: advancing by 5 instead of 1\n    assert result_tomorrow == (result_today + 1) % 7\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_4(date):\n    result_today = date.weekday()\n    tomorrow = date + datetime.timedelta(days=1)\n    result_tomorrow = (result_today + 6) % 7  # Violation: wrapping around incorrectly\n    assert result_tomorrow == (result_today + 1) % 7\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_5(date):\n    result_today = date.weekday()\n    tomorrow = date + datetime.timedelta(days=1)\n    result_tomorrow = result_today  # Violation: no change in the weekday\n    assert result_tomorrow == (result_today + 1) % 7\n```"], "property": "The output should change predictably when the input date changes, specifically advancing by 1 for each day increment in the input.", "pbt": "@given(st.dates())\ndef test_weekday_predictable_change_property(date):\n    result_today = date.weekday()\n    tomorrow = date + datetime.timedelta(days=1)\n    result_tomorrow = tomorrow.weekday()\n    assert result_tomorrow == (result_today + 1) % 7", "properties": ["1. The output of the `weekday` function should always be an integer between 0 and 6, inclusive.", "2. The output value should represent the correct day of the week, where 0 corresponds to Monday and 6 corresponds to Sunday.", "3. The result of the `weekday` function should be consistent for the same date input, meaning that calling the function multiple times with the same date should yield the same result.", "4. The output should change predictably when the input date changes, specifically advancing by 1 for each day increment in the input.", "5. The output should exhibit periodicity, such that the `weekday` function returns the same value for dates that are exactly one week apart."]}
{"function_name": "datetime.date.weekday", "mutants": ["```python\n# property to violate: The output should exhibit periodicity, such that the `weekday` function returns the same value for dates that are exactly one week apart.\nfrom hypothesis import given, strategies as st\nimport datetime\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_1(date):\n    result_today = date.weekday()\n    one_week_later = date + datetime.timedelta(weeks=1)\n    result_one_week_later = (result_today + 1) % 7  # Change the result to be different\n    assert result_today == result_one_week_later\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_2(date):\n    result_today = date.weekday()\n    one_week_later = date + datetime.timedelta(weeks=1)\n    result_one_week_later = (result_today + 2) % 7  # Change the result to be different\n    assert result_today == result_one_week_later\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_3(date):\n    result_today = date.weekday()\n    one_week_later = date + datetime.timedelta(weeks=1)\n    result_one_week_later = (result_today + 3) % 7  # Change the result to be different\n    assert result_today == result_one_week_later\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_4(date):\n    result_today = date.weekday()\n    one_week_later = date + datetime.timedelta(weeks=1)\n    result_one_week_later = (result_today + 4) % 7  # Change the result to be different\n    assert result_today == result_one_week_later\n\n@given(st.dates())\ndef test_violation_of_datetime_date_weekday_5(date):\n    result_today = date.weekday()\n    one_week_later = date + datetime.timedelta(weeks=1)\n    result_one_week_later = (result_today + 5) % 7  # Change the result to be different\n    assert result_today == result_one_week_later\n```"], "property": "The output should exhibit periodicity, such that the `weekday` function returns the same value for dates that are exactly one week apart.", "pbt": "@given(st.dates())\ndef test_weekday_periodicity_property(date):\n    result_today = date.weekday()\n    one_week_later = date + datetime.timedelta(weeks=1)\n    result_one_week_later = one_week_later.weekday()\n    assert result_today == result_one_week_later", "properties": ["1. The output of the `weekday` function should always be an integer between 0 and 6, inclusive.", "2. The output value should represent the correct day of the week, where 0 corresponds to Monday and 6 corresponds to Sunday.", "3. The result of the `weekday` function should be consistent for the same date input, meaning that calling the function multiple times with the same date should yield the same result.", "4. The output should change predictably when the input date changes, specifically advancing by 1 for each day increment in the input.", "5. The output should exhibit periodicity, such that the `weekday` function returns the same value for dates that are exactly one week apart."]}
