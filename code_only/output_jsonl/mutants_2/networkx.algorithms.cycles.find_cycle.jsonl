{"function_name": "networkx.algorithms.cycles.find_cycle", "mutants": ["```python\n# property to violate: If the input graph is acyclic (i.e., it contains no cycles), the output should be an empty list.\nfrom hypothesis import given, strategies as st\nimport networkx as nx\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_cycles_find_cycle_1(data):\n    G = data.draw(st.builds(nx.Graph, st.lists(st.tuples(st.integers(), st.integers()))))\n    source = data.draw(st.one_of(st.none(), st.integers()))\n    orientation = data.draw(st.one_of(st.none(), st.just(\"original\"), st.just(\"reverse\"), st.just(\"ignore\")))\n\n    if nx.is_directed_acyclic_graph(G):\n        cycle = nx.algorithms.cycles.find_cycle(G, source, orientation)\n        assert cycle != []  # Violation: should be empty but is not.\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_cycles_find_cycle_2(data):\n    G = data.draw(st.builds(nx.Graph, st.lists(st.tuples(st.integers(), st.integers()))))\n    source = data.draw(st.one_of(st.none(), st.integers()))\n    orientation = data.draw(st.one_of(st.none(), st.just(\"original\"), st.just(\"reverse\"), st.just(\"ignore\")))\n\n    if nx.is_directed_acyclic_graph(G):\n        cycle = nx.algorithms.cycles.find_cycle(G, source, orientation)\n        assert cycle == [(0, 0)]  # Violation: returns a cycle instead of empty.\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_cycles_find_cycle_3(data):\n    G = data.draw(st.builds(nx.Graph, st.lists(st.tuples(st.integers(), st.integers()))))\n    source = data.draw(st.one_of(st.none(), st.integers()))\n    orientation = data.draw(st.one_of(st.none(), st.just(\"original\"), st.just(\"reverse\"), st.just(\"ignore\")))\n\n    if nx.is_directed_acyclic_graph(G):\n        cycle = nx.algorithms.cycles.find_cycle(G, source, orientation)\n        assert cycle == [(1, 2), (2, 3)]  # Violation: returns a non-empty cycle.\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_cycles_find_cycle_4(data):\n    G = data.draw(st.builds(nx.Graph, st.lists(st.tuples(st.integers(), st.integers()))))\n    source = data.draw(st.one_of(st.none(), st.integers()))\n    orientation = data.draw(st.one_of(st.none(), st.just(\"original\"), st.just(\"reverse\"), st.just(\"ignore\")))\n\n    if nx.is_directed_acyclic_graph(G):\n        cycle = nx.algorithms.cycles.find_cycle(G, source, orientation)\n        assert cycle == [(3, 4), (4, 5), (5, 3)]  # Violation: returns a cycle instead of empty.\n\n@given(st.data())\ndef test_violation_of_networkx_algorithms_cycles_find_cycle_5(data):\n    G = data.draw(st.builds(nx.Graph, st.lists(st.tuples(st.integers(), st.integers()))))\n    source = data.draw(st.one_of(st.none(), st.integers()))\n    orientation = data.draw(st.one_of(st.none(), st.just(\"original\"), st.just(\"reverse\"), st.just(\"ignore\")))\n\n    if nx.is_directed_acyclic_graph(G):\n        cycle = nx.algorithms.cycles.find_cycle(G, source, orientation)\n        assert cycle == [(0, 1), (1, 2), (2, 0)]  # Violation: returns a cycle instead of empty.\n```"], "property": "If the input graph is acyclic (i.e., it contains no cycles), the output should be an empty list.", "pbt": "@given(st.data())\ndef test_no_cycle_in_acyclic_graph_property(data):\n    G = data.draw(st.builds(nx.Graph, st.lists(st.tuples(st.integers(), st.integers()))))\n    source = data.draw(st.one_of(st.none(), st.integers()))\n    orientation = data.draw(st.one_of(st.none(), st.just(\"original\"), st.just(\"reverse\"), st.just(\"ignore\")))\n\n    if nx.is_directed_acyclic_graph(G):\n        cycle = nx.algorithms.cycles.find_cycle(G, source, orientation)\n        assert cycle == []", "properties": ["2. If the input graph is acyclic (i.e., it contains no cycles), the output should be an empty list."]}
